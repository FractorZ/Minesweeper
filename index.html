<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Min3s – Mobile Minesweeper Game No Guess with Leaderboards</title>
    <meta name="description" content="Play Minesweeper online at Min3s.click! No ads, Mobile‑friendly, no‑guess mode, and live global leaderboard.">
    
    <link rel="manifest" href="/manifest.webmanifest">
    
    <meta name="theme-color" content="#ffffff">

    <link rel="icon" type="image/x-icon" href="/icon.png">
    
    <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-firestore-compat.js"></script>
    
    <style>
        /* Base Styles (Dark Mode - Now Default) */
        :root {
            --bg-color: #333;
            --container-bg: #444;
            --grid-border-color: #666;
            --grid-bg-color: #555;
            --cell-bg-color: #666;
            --cell-border-color: #777;
            --revealed-cell-bg: #555;
            --revealed-cell-border: #888;
            --flagged-cell-bg: #4682B4; /* Steel Blue */
            --flagged-cell-color: #FFD700; /* Gold */
            --mine-bg-color: #B22222; /* Firebrick - Not used directly, see .mine */
            --mine-revealed-bg: #800000; /* Maroon */
            --mine-revealed-color: white;
            --incorrect-flag-bg: #A0522D; /* Sienna */
            --incorrect-flag-color: white;
            --text-color: white;
            --button-bg: #3e8e41;
            --button-hover-bg: #2e6e31;
            --button-text-color: white;
            --control-border-color: #aaa;
            --control-bg-color: #444;
            --cell-pressed-bg: #777; /* Added style for pressed cell */
            --input-bg-color: #555; /* Added for inputs */
            --input-border-color: #777; /* Added for inputs */
            --input-text-color: white; /* Added for inputs */
            --settings-panel-width: 300px; /* Width for the side panel */
            
            /* Dark mode number colors (lighter) */
            --num-1-color-dark: #ADD8E6; /* Light Blue */
            --num-2-color-dark: #90EE90; /* Light Green */
            --num-3-color-dark: #F08080; /* Light Coral */
            --num-4-color-dark: #B0C4DE; /* Light Steel Blue */
            --num-5-color-dark: #FFA07A; /* Light Salmon */
            --num-6-color-dark: #20B2AA; /* Light Sea Green */
            --num-7-color-dark: #E6E6FA; /* Lavender (lighter than grey) */
            --num-8-color-dark: #D3D3D3; /* Light Gray */
        }
        
        /* Light Mode Styles */
        .light-mode {
            --bg-color: #e0e0e0;
            --container-bg: white;
            --grid-border-color: #a0a0a0;
            --grid-bg-color: #c0c0c0;
            --cell-bg-color: #d0d0d0;
            --cell-border-color: #f0f0f0;
            --revealed-cell-bg: #f8f8f8;
            --revealed-cell-border: #909090;
            --flagged-cell-bg: #87CEEB; /* Sky Blue */
            --flagged-cell-color: #B22222; /* Firebrick */
            /* --mine-bg-color: #F08080; */ /* Light Coral - Not used directly */
            --mine-revealed-bg: #DC143C; /* Crimson */
            --mine-revealed-color: white;
            --incorrect-flag-bg: #FFD700; /* Gold */
            --incorrect-flag-color: black;
            --text-color: black;
            --button-bg: #4CAF50;
            --button-hover-bg: #3e8e41;
            --button-text-color: white;
            --control-border-color: #808080;
            --control-bg-color: #f0f0f0;
            --cell-pressed-bg: #e8e8e8; /* Added style for pressed cell */
            --input-bg-color: #fdfdfd; /* Added for inputs */
            --input-border-color: #bbb; /* Added for inputs */
            --input-text-color: black; /* Added for inputs */
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to the top */
            min-height: 100vh;
            margin: 0;
            padding-top: 20px; /* Add some padding at the top */
            background-color: var(--bg-color);
            color: var(--text-color);
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation; /* Prevent double-tap zoom */
            box-sizing: border-box;
        }
        
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center; /* Center the header-area and grid */
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            overflow: visible; /* Allow difficulty dropdown to overflow visually */
            background-color: var(--container-bg);
            padding: 15px; /* Increased padding slightly */
            position: relative; /* Needed for absolute positioning if used, but flex is fine */
        }
        
        /* Style for the header area containing logo and controls */
        #header-area {
            display: flex;
            align-items: center; /* Vertically align items */
            justify-content: center; /* Center the items horizontally */
            width: 100%; /* Take full width of the container */
            margin-bottom: 15px; /* Space below the header area */
            padding: 0;
            transition: gap 0.3s ease; /* Add smooth transition for gap changes */
        }
        
        /* CSS for dynamic header gap */
        #header-area.header-gap-small {
            gap: 20px;
        }
        
        #header-area.header-gap-medium {
            gap: 50px;
        }
        
        #header-area.header-gap-large {
            gap: 100px;
        }
        
        /* CSS for dynamic controls gap */
        #controls.controls-gap-small {
            gap: 10px;
        }
        
        #controls.controls-gap-medium {
            gap: 25px;
        }
        
        #controls.controls-gap-large {
            gap: 40px;
        }
        
        #logo {
            height: 70px;
            flex-shrink: 0;
        }
        
        /* New Difficulty Selector Area */
        #difficulty-selector-area {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px; /* Space below the dropdown */
            width: 100%;
        }
        
        #difficulty-selector-area label {
            margin-right: 10px;
            font-weight: bold;
        }
        
        #difficulty-selector {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--control-border-color);
            background-color: var(--input-bg-color);
            color: var(--text-color);
            font-size: 1em;
            cursor: pointer;
        }
        
        #difficulty-selector:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--button-bg);
        }
        
        #grid-container {
            display: grid;
            grid-gap: 1px;
            border: 3px solid var(--grid-border-color);
            background-color: var(--grid-bg-color);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .cell {
            width: 28px;
            height: 28px;
            background-color: var(--cell-bg-color);
            border: 2px outset var(--cell-border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            transition: background-color 0.1s; /* Faster transition */
        }
        
        .cell.pressed { /* Style for when left mouse is down */
            background-color: var(--cell-pressed-bg);
            border-style: inset; /* Give pressed appearance */
        }
        
        .cell.revealed {
            border: 1px solid var(--revealed-cell-border);
            background-color: var(--revealed-cell-bg);
            cursor: default;
        }
        
        .cell.flagged {
            background-color: var(--flagged-cell-bg);
            color: var(--flagged-cell-color);
        }
        
        .cell.mine { /* Style for the mine hit that ends the game */
            background-color: red !important; /* Make it stand out */
            color: white;
        }
        
        .cell.mine-revealed { /* Style for other mines shown on loss */
            background-color: var(--mine-revealed-bg);
            color: var(--mine-revealed-color);
        }
        
        .cell.incorrect-flag {
            background-color: var(--incorrect-flag-bg);
            color: var(--incorrect-flag-color);
        }
        
        /* Dark Mode Number colors */
        .cell[data-adjacent="1"] { color: var(--num-1-color-dark); }
        .cell[data-adjacent="2"] { color: var(--num-2-color-dark); }
        .cell[data-adjacent="3"] { color: var(--num-3-color-dark); }
        .cell[data-adjacent="4"] { color: var(--num-4-color-dark); }
        .cell[data-adjacent="5"] { color: var(--num-5-color-dark); }
        .cell[data-adjacent="6"] { color: var(--num-6-color-dark); }
        .cell[data-adjacent="7"] { color: var(--num-7-color-dark); }
        .cell[data-adjacent="8"] { color: var(--num-8-color-dark); }
        
        /* Light mode number colors (standard/original) */
        .light-mode .cell[data-adjacent="1"] { color: blue; }
        .light-mode .cell[data-adjacent="2"] { color: green; }
        .light-mode .cell[data-adjacent="3"] { color: red; }
        .light-mode .cell[data-adjacent="4"] { color: navy; }
        .light-mode .cell[data-adjacent="5"] { color: maroon; }
        .light-mode .cell[data-adjacent="6"] { color: teal; }
        .light-mode .cell[data-adjacent="7"] { color: black; }
        .light-mode .cell[data-adjacent="8"] { color: gray; }
        
        #controls {
            display: flex;
            /* gap: 10px; -- Removed fixed gap, now controlled by classes */
            margin-bottom: 0;
            align-items: center;
            flex-shrink: 0;
            transition: gap 0.3s ease; /* Add smooth transition for gap changes */
        }
        
        #timer, #mines-left {
            font-size: 1.1em;
            font-weight: bold;
            padding: 6px 12px;
            border: 2px solid var(--control-border-color);
            background-color: var(--control-bg-color);
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 80px; /* Increased min-width to accommodate decimals */
            text-align: center;
        }
        
        #timer-label, #mines-left-label {
            font-size: 0.8em;
            color: var(--text-color);
            margin-bottom: 2px;
        }
        
        /* Settings Toggle Button (New Side Button) */
        #settings-toggle-button {
            position: fixed;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            writing-mode: vertical-rl; /* Rotate text */
            text-orientation: mixed;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            padding: 15px 8px;
            font-size: 1.1em;
            cursor: pointer;
            border-radius: 8px 0 0 8px; /* Rounded corners on the left */
            box-shadow: -2px 0px 5px rgba(0,0,0,0.2);
            z-index: 1005; /* Above game, below panel overlay */
            transition: background-color 0.3s;
        }
        
        #settings-toggle-button:hover {
            background-color: var(--button-hover-bg);
        }
        
        /* Settings Panel (New Side Panel) */
        #settings-panel {
            display: block; /* Always block, position controls visibility */
            position: fixed;
            top: 0;
            right: calc(-1 * var(--settings-panel-width) - 10px); /* Start hidden off-screen */
            width: var(--settings-panel-width);
            height: 100vh; /* Full viewport height */
            background-color: var(--container-bg);
            color: var(--text-color);
            padding: 25px;
            border-left: 2px solid var(--grid-border-color); /* Border on the visible edge */
            box-shadow: -5px 0px 15px rgba(0,0,0,0.3);
            z-index: 1010; /* Above toggle button and overlay */
            overflow-y: auto; /* Enable vertical scrolling */
            box-sizing: border-box; /* Include padding in width */
            transition: right 0.3s ease-in-out; /* Slide animation */
        }
        
        #settings-panel.open {
            right: 0; /* Slide into view */
        }
        
        #settings-panel h2 {
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
        }
        
        #settings-panel label {
            display: block;
            margin-bottom: 6px;
            font-weight: bold;
        }
        
        #settings-panel input[type="number"],
        #settings-panel input[type="range"],
        #settings-panel input[type="text"],
        #settings-panel select { /* Apply styles to select too */
            width: calc(100% - 20px); /* Adjusted width calculation */
            margin-bottom: 12px;
            padding: 8px;
            border: 1px solid var(--input-border-color);
            border-radius: 5px;
            font-size: 1em;
            background-color: var(--input-bg-color);
            color: var(--input-text-color);
            box-sizing: border-box;
        }
        
        #settings-panel input[type="number"] {
            width: 70px; /* Keep number inputs smaller */
        }
        
        #settings-panel input[type="range"] {
            width: 100%;
            padding: 0; /* Remove padding for range */
        }
        
        #settings-panel button {
            padding: 10px 20px;
            margin-top: 12px;
            margin-right: 10px; /* Space between buttons */
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }
        
        #settings-panel button:last-of-type {
            margin-right: 0;
        }
        
        #settings-panel button:hover {
            background-color: var(--button-hover-bg);
        }
        
        #settings-panel .setting-group {
            margin-bottom: 20px; /* Increased spacing */
            border-bottom: 1px solid var(--grid-border-color); /* Use grid border color */
            padding-bottom: 15px;
        }
        
        #settings-panel .setting-group:last-of-type {
            border-bottom: none; /* No border on the last group */
        }
        
        #overlay {
            display: none; /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 1000; /* Below settings panel, above content */
        }
        
        #message-box {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--container-bg);
            color: var(--text-color);
            padding: 25px;
            border: 2px solid #888;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            z-index: 1011; /* Above settings panel */
            text-align: center;
            border-radius: 12px;
            width: 80%;
            max-width: 400px;
        }
        
        #message-box button {
            padding: 10px 20px;
            margin-top: 12px;
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }
        
        #message-box button:hover {
            background-color: var(--button-hover-bg);
        }
        
        #message-text {
            font-size: 1.2em;
            margin-bottom: 15px;
        }
        
        /* Toggle switch styles */
        .switch-container { /* Container for label and switch */
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .switch-container label {
            margin-bottom: 0; /* Remove bottom margin from label */
            margin-right: 10px; /* Space between label and switch */
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
            /* margin-bottom: 12px; Removed */
            vertical-align: middle; /* Align with label */
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 34px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #2196F3;
        }
        
        input:focus + .slider {
            box-shadow: 0 0 1px #2196F3;
        }
        
        input:checked + .slider:before {
            -webkit-transform: translateX(26px);
            -ms-transform: translateX(26px);
            transform: translateX(26px);
        }
        
        #leaderboard {
            margin-top: 30px; /* Increased margin */
            text-align: center;
            width: 95%; /* Make leaderboards wider */
            max-width: 1200px; /* Max width for very large screens */
            margin-left: auto;
            margin-right: auto;
        }
        
        #leaderboard h3 {
            margin-bottom: 15px;
        }
        
        #leaderboard table {
            width: 90%; /* Relative width */
            max-width: 500px; /* Limit width for local leaderboard */
            margin: 0 auto 20px auto; /* Center and add bottom margin */
            border-collapse: collapse;
            background-color: var(--container-bg); /* Match container */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden; /* Clip corners */
        }
        
        #leaderboard th, #leaderboard td {
            padding: 10px; /* Increased padding */
            border: 1px solid var(--grid-border-color);
            text-align: center;
        }
        
        #leaderboard th {
            background-color: var(--control-bg-color);
            color: var(--text-color);
            font-weight: bold;
        }
        
        .custom-settings {
            display: none; /* Initially hidden */
        }
        
        .custom-settings.active {
            display: block; /* Show when active */
        }
        
        #settings-panel #custom-difficulty-label{
            margin-top: 10px;
            font-size: 1.1em;
        }
        
        #leaderboard-loading, #leaderboard-error {
            margin-bottom: 15px;
            text-align: center; /* Center loading/error text */
            width: 100%;
            font-size: 1.1em;
        }
        
        /* Style for online leaderboard tables */
        #online-leaderboard-container {
            display: flex; /* Use flexbox for side-by-side tables */
            justify-content: space-around; /* Distribute space evenly */
            flex-wrap: wrap; /* Allow tables to wrap on smaller screens */
            width: 95%; /* Make leaderboards wider */
            max-width: 1200px; /* Optional max width for very large screens */
            margin: 30px auto; /* Center and add vertical margin */
            gap: 20px; /* Add gap between sections */
        }
        
        /* Individual leaderboard section */
        .leaderboard-section {
            flex: 1 1 300px; /* Flex grow, shrink, basis (min width) */
            margin-bottom: 20px; /* Space below each section */
            padding: 15px; /* Increased padding */
            background-color: var(--container-bg); /* Match container background */
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            box-sizing: border-box; /* Include padding in width calculation */
        }
        
        .leaderboard-section h4 {
            margin-top: 0;
            margin-bottom: 15px; /* Increased spacing */
            text-align: center;
            color: var(--text-color);
            font-size: 1.2em; /* Slightly larger title */
        }
        
        .leaderboard-section table {
            width: 100%; /* Tables take full width of their section */
            border-collapse: collapse;
        }
        
        .leaderboard-section th, .leaderboard-section td {
            padding: 8px; /* Standard padding */
            border: 1px solid var(--grid-border-color);
            text-align: center;
            font-size: 0.95em; /* Standard font size */
        }
        
        .leaderboard-section th {
            background-color: var(--control-bg-color);
            color: var(--text-color);
            font-weight: bold;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            #online-leaderboard-container {
                /* Keep flex-direction row, rely on wrapping */
                justify-content: center; /* Center items when they wrap */
            }
            
            .leaderboard-section {
                flex-basis: 90%; /* Allow sections to take more width */
            }
            
            #settings-panel {
                width: 280px; /* Slightly narrower panel on mobile */
                right: calc(-280px - 10px);
                :root {
                    --settings-panel-width: 280px;
                } /* Update CSS variable */
            }
            
            #settings-toggle-button {
                padding: 12px 6px; /* Adjust padding */
                font-size: 1em;
            }
        }
        
        #generation-attempts {
            margin-left: 10px;
            font-size: 0.9em;
            color: #aaa; /* Light gray color */
        }
        
        .light-mode #generation-attempts {
            color: #555; /* Darker gray for light mode */
        }
        
        h1 {
            position: absolute;
            left: -9999px;
        }
        
        /* === ADDED: Legacy-icon tooltip / pointer === */
        .legacy-icon {
            cursor: help; /* shows ? cursor on hover */
            margin-left: 4px; /* Add slight space before icon */
        }
    </style>
</head>
<body>
    <h1>Mobile Minesweeper game No Guess Mode and Online Leaderboards</h1>
    
    <!-- Settings Toggle Button -->
    <button id="settings-toggle-button" onclick="toggleSettings()">Settings</button>
    
    <div id="game-container">
        <!-- Header area for logo and controls -->
        <div id="header-area">
            <img id="logo" src="/DarkModeLogo.svg" alt="Min3s Logo">
            <div id="controls">
                <div id="mines-left">
                    <div id="mines-left-label">Mines</div>
                    <div></div>
                </div>
                <div id="timer">
                    <div id="timer-label">Timer</div>
                    <div>0.000</div> <!-- Initial display with decimals -->
                </div>
            </div>
        </div>
        <!-- End of header area -->
        
        <!-- New Difficulty Selector Area -->
        <div id="difficulty-selector-area">
            <label for="difficulty-selector">Difficulty:</label>
            <select id="difficulty-selector" onchange="handleDifficultyChange()">
                <option value="beginner">Beginner</option>
                <option value="intermediate">Intermediate</option>
                <option value="expert">Expert</option>
                <option value="custom">Custom</option>
            </select>
        </div>
        <!-- End of Difficulty Selector Area -->
        
        <div id="grid-container"></div>
    </div>
    
    <!-- Settings Side Panel -->
    <div id="settings-panel">
        <h2>Settings</h2>
        
        <div class="setting-group">
            <label for="player-name">Your Name:</label>
            <input type="text" id="player-name" value="Player" placeholder="Enter your name">
        </div>
        
        <!-- Custom settings appear only when difficulty is custom -->
        <div class="custom-settings setting-group">
            <h3 id="custom-difficulty-label">Custom Difficulty</h3>
            <label for="width">Width:</label>
            <input type="number" id="width" min="5" max="50" value="9">
            <br> <!-- Simple line break for better spacing -->
            <label for="height">Height:</label>
            <input type="number" id="height" min="5" max="50" value="9">
            <br>
            <label for="mines">Mines:</label>
            <input type="number" id="mines" min="1" max="2491" value="10">
        </div>
        
        <div class="setting-group">
            <div class="switch-container">
                <label for="light-mode">Light Mode:</label>
                <label class="switch">
                    <input type="checkbox" id="light-mode">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
        
        <div class="setting-group">
            <div class="switch-container">
                <label for="no-guess-mode">No Guess Mode:</label>
                <label class="switch">
                    <input type="checkbox" id="no-guess-mode">
                    <span class="slider"></span>
                </label>
            </div>
            <span id="generation-attempts"></span> <!-- To display attempts -->
        </div>
        
        <div class="setting-group">
            <label for="flag-method">Flagging Method:</label>
            <select id="flag-method">
                <option value="longPress">Long Press</option>
                <option value="doubleTap">Double Tap</option>
                <option value="rightClick">Right Click</option>
            </select>
        </div>
        
        <div class="setting-group">
            <label for="long-press-delay">Long Press Delay (ms):</label>
            <input type="range" id="long-press-delay" min="100" max="1000" value="500" step="50">
            <span id="long-press-delay-value">500</span>ms
        </div>
        
        <div class="setting-group">
            <label for="chord-method">Chording Method:</label>
            <select id="chord-method">
                <option value="singleTap">Single Tap</option>
                <option value="doubleTap">Double Tap</option>
            </select>
        </div>
        
        <!-- Only Close button remains -->
        <div>
            <button onclick="toggleSettings()">Close</button>
        </div>
    </div>
    
    <!-- Overlay for Settings Panel and Message Box -->
    <div id="overlay" onclick="closePanels()"></div>
    
    <div id="message-box">
        <p id="message-text"></p>
        <button onclick="restartGame()">Restart</button>
    </div>
    
    <!-- Online Leaderboards Container -->
    <div id="online-leaderboard-container">
        <div id="leaderboard-loading">Loading leaderboards...</div>
        <div id="leaderboard-error" style="color: red; display: none; width: 100%; text-align: center;">Error loading leaderboards.</div>
        
        <!-- Standard Leaderboards -->
        <div class="leaderboard-section">
            <h4>Beginner</h4>
            <table>
                <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                <tbody id="leaderboard-beginner"></tbody>
            </table>
        </div>
        
        <div class="leaderboard-section">
            <h4>Intermediate</h4>
            <table>
                <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                <tbody id="leaderboard-intermediate"></tbody>
            </table>
        </div>
        
        <div class="leaderboard-section">
            <h4>Expert</h4>
            <table>
                <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                <tbody id="leaderboard-expert"></tbody>
            </table>
        </div>
        
        <!-- No Guess Leaderboards -->
        <div class="leaderboard-section">
            <h4>Beginner (No Guess)</h4>
            <table>
                <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                <tbody id="leaderboard-beginner_noguess"></tbody>
            </table>
        </div>
        
        <div class="leaderboard-section">
            <h4>Intermediate (No Guess)</h4>
            <table>
                <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                <tbody id="leaderboard-intermediate_noguess"></tbody>
            </table>
        </div>
        
        <div class="leaderboard-section">
            <h4>Expert (No Guess)</h4>
            <table>
                <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                <tbody id="leaderboard-expert_noguess"></tbody>
            </table>
        </div>
    </div>
    
    <!-- Local Leaderboard Table -->
    <div id="leaderboard">
        <h3>Local Leaderboard</h3>
        <table>
            <thead>
                <tr>
                    <th>Difficulty</th>
                    <th>Best Time (s)</th> <!-- Added (s) -->
                </tr>
            </thead>
            <tbody>
                <tr><td>Beginner</td><td id="leaderboard-beginner-local">-</td></tr>
                <tr><td>Intermediate</td><td id="leaderboard-intermediate-local">-</td></tr>
                <tr><td>Expert</td><td id="leaderboard-expert-local">-</td></tr>
                <tr><td>Beginner (No Guess)</td><td id="leaderboard-beginner_noguess-local">-</td></tr>
                <tr><td>Intermediate (No Guess)</td><td id="leaderboard-intermediate_noguess-local">-</td></tr>
                <tr><td>Expert (No Guess)</td><td id="leaderboard-expert_noguess-local">-</td></tr>
            </tbody>
        </table>
    </div>
    
    <script>
        /* ========= SANITISE UTILITY ========= */
        function sanitize(str) {
            if (typeof str !== 'string') return '';
            return str.replace(/[&<>"'`=\\/]/g, s => ({
                '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;',
                "'": '&#39;', '`': '&#96;', '=': '&#61;', '/': '&#x2F;'
            })[s] || s);
        }
        
        /* ========= HAPTIC FEEDBACK UTILITY (iOS 18+ Hack & Android) ========= */
        function initHaptics() {
            // Create the hidden elements required for the iOS 18+ haptic hack
            // We avoid display:none as WebKit sometimes ignores hidden inputs
            if (!document.getElementById('haptic-switch')) {
                const switchInput = document.createElement('input');
                switchInput.type = 'checkbox';
                switchInput.id = 'haptic-switch';
                // The 'switch' attribute is the key for the iOS 18 WebKit haptic behavior
                switchInput.setAttribute('switch', ''); 
                switchInput.style.cssText = 'position: absolute; opacity: 0; pointer-events: none; width: 0; height: 0; top: 0; left: 0; z-index: -1;';
        
                const switchLabel = document.createElement('label');
                switchLabel.id = 'haptic-trigger';
                switchLabel.htmlFor = 'haptic-switch';
                switchLabel.style.cssText = 'position: absolute; opacity: 0; pointer-events: none; width: 0; height: 0; top: 0; left: 0; z-index: -1;';
        
                document.body.appendChild(switchInput);
                document.body.appendChild(switchLabel);
            }
        }
        
        function triggerHaptic() {
            // 1. Try standard Vibration API (Android/Desktop)
            if (navigator.vibrate) {
                navigator.vibrate(15); // Short, sharp tick
                return;
            }
        
            // 2. Fallback to iOS Switch Hack (iOS 18+)
            // This requires a valid user gesture stack.
            const trigger = document.getElementById('haptic-trigger');
            if (trigger) {
                trigger.click(); 
            }
        }
    
        /* ========= FIREBASE CONFIG ========= */
        const firebaseConfig = {
            apiKey: "AIzaSyAV_27osmUzqrYbJIatByVHigyKh0naSNM",
            authDomain: "min3s-d13d8.firebaseapp.com",
            projectId: "min3s-d13d8",
            storageBucket: "min3s-d13d8.appspot.com",
            messagingSenderId: "561325595032",
            appId: "1:561325595032:web:19657730940427fb4073ed",
            measurementId: "G-N25M3ZT9NQ"
        };
        
        const firebaseApp = firebase.initializeApp(firebaseConfig);
        const db = firebaseApp.firestore();
        
        // --- Global Variables ---
        let grid = [];
        let width = 9;
        let height = 9;
        let numMines = 10;
        let minesLeft = numMines;
        let timerDisplayInterval = null; 
        let timerStartTime = null; 
        let time = 0.000; 
        const timerUpdateDelay = 50; 
        let gameStarted = false;
        let gameOver = false;
        let firstClick = true;
        let touchLongPressTimerId = null;
        let mouseLongPressTimerId = null;
        let ignoreNextClick = false;
        let longPressFlaggedThisTouch = false;
        let longPressJustFinishedMouse = false;
        let isLeftMouseDown = false;
        let pressedCellElement = null;
        let initialMouseDownCell = null;
        let longPressDelay = 500;
        let flagMethod = "longPress";
        let chordMethod = "singleTap";
        let doubleTapChordTimer = null;
        let doubleTapFlagTimer = null;
        let currentDifficulty = "beginner";
        let playerName = "Player";
        let noGuessMode = false;
        let generationAttempts = 0;
        
        // --- DOM Elements Cache ---
        const gridContainer = document.getElementById('grid-container');
        const timerDisplay = document.querySelector('#timer > div:nth-child(2)');
        const minesLeftDisplay = document.querySelector('#mines-left > div:nth-child(2)');
        const settingsPanel = document.getElementById('settings-panel');
        const overlay = document.getElementById('overlay');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const difficultySelector = document.getElementById('difficulty-selector');
        const customSettingsDiv = document.querySelector('.custom-settings');
        const widthInput = document.getElementById('width');
        const heightInput = document.getElementById('height');
        const minesInput = document.getElementById('mines');
        const playerNameInput = document.getElementById('player-name');
        const lightModeCheckbox = document.getElementById('light-mode');
        const noGuessCheckbox = document.getElementById('no-guess-mode');
        const flagMethodSelect = document.getElementById('flag-method');
        const longPressDelayInput = document.getElementById('long-press-delay');
        const longPressDelayValueSpan = document.getElementById('long-press-delay-value');
        const chordMethodSelect = document.getElementById('chord-method');
        const attemptsSpan = document.getElementById('generation-attempts');
        const logoElement = document.getElementById('logo');
        const headerArea = document.getElementById('header-area');
        const controlsDiv = document.getElementById('controls');
        const leaderboardLoadingDiv = document.getElementById('leaderboard-loading');
        const leaderboardErrorDiv = document.getElementById('leaderboard-error');
        
        // --- Auto-save settings function ---
        function autoSaveSettings() {
            localStorage.setItem('playerName', playerNameInput.value.trim() || "Player");
            localStorage.setItem('darkMode', lightModeCheckbox.checked ? 'enabled' : 'disabled');
            localStorage.setItem('flagMethod', flagMethodSelect.value);
            localStorage.setItem('longPressDelay', longPressDelayInput.value);
            localStorage.setItem('chordMethod', chordMethodSelect.value);
            
            playerName = playerNameInput.value.trim() || "Player";
            const isLightMode = lightModeCheckbox.checked;
            
            if (isLightMode) {
                document.body.classList.add('light-mode');
                if (logoElement) logoElement.src = "/LightModeLogo.svg";
            } else {
                document.body.classList.remove('light-mode');
                if (logoElement) logoElement.src = "/DarkModeLogo.svg";
            }
            
            flagMethod = flagMethodSelect.value;
            longPressDelay = parseInt(longPressDelayInput.value);
            chordMethod = chordMethodSelect.value;
            
            updateAllFlagMethodListeners();
        }
        
        function autoSaveWithRestart() {
            localStorage.setItem('noGuessMode', noGuessCheckbox.checked);
            noGuessMode = noGuessCheckbox.checked;
            
            if (currentDifficulty === 'custom') {
                const newWidth = parseInt(widthInput.value);
                const newHeight = parseInt(heightInput.value);
                const newNumMines = parseInt(minesInput.value);
                
                if (isNaN(newWidth) || newWidth < 5 || newWidth > 50) {
                    alert('Width must be between 5 and 50.');
                    widthInput.value = width;
                    return;
                }
                if (isNaN(newHeight) || newHeight < 5 || newHeight > 50) {
                    alert('Height must be between 5 and 50.');
                    heightInput.value = height;
                    return;
                }
                const maxMines = (newWidth * newHeight) - 9;
                if (isNaN(newNumMines) || newNumMines < 1 || newNumMines > maxMines) {
                    alert(`Mines must be between 1 and ${maxMines}.`);
                    minesInput.value = numMines;
                    return;
                }
                
                width = newWidth;
                height = newHeight;
                numMines = newNumMines;
                localStorage.setItem('width', width);
                localStorage.setItem('height', height);
                localStorage.setItem('numMines', numMines);
                
                minesLeft = numMines;
                restartGame();
            } else {
                restartGame();
            }
        }
        
        function addAutoSaveListeners() {
            playerNameInput.addEventListener('input', autoSaveSettings);
            lightModeCheckbox.addEventListener('change', autoSaveSettings);
            flagMethodSelect.addEventListener('change', autoSaveSettings);
            longPressDelayInput.addEventListener('input', () => {
                longPressDelayValueSpan.textContent = longPressDelayInput.value;
                autoSaveSettings();
            });
            chordMethodSelect.addEventListener('change', autoSaveSettings);
            noGuessCheckbox.addEventListener('change', autoSaveWithRestart);
            
            widthInput.addEventListener('blur', () => {
                if (currentDifficulty === 'custom') {
                    autoSaveWithRestart();
                }
            });
            heightInput.addEventListener('blur', () => {
                if (currentDifficulty === 'custom') {
                    autoSaveWithRestart();
                }
            });
            minesInput.addEventListener('blur', () => {
                if (currentDifficulty === 'custom') {
                    autoSaveWithRestart();
                }
            });
            
            widthInput.addEventListener('input', updateCustomMaxMines);
            heightInput.addEventListener('input', updateCustomMaxMines);
        }
        
        function updateCustomMaxMines() {
            if (currentDifficulty === 'custom') {
                const currentW = parseInt(widthInput.value) || width;
                const currentH = parseInt(heightInput.value) || height;
                const maxMines = (currentW * currentH) - 9;
                minesInput.max = maxMines > 0 ? maxMines : 1;
            }
        }
        
        function createGrid() {
            gridContainer.innerHTML = '';
            gridContainer.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
            grid = [];
            
            for (let y = 0; y < height; y++) {
                grid[y] = [];
                for (let x = 0; x < width; x++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.addEventListener('click', handleClick);
                    cell.addEventListener('mousedown', handleCellMouseDown);
                    // contextmenu is used for Right Click on desktop AND Long Press haptics on iOS
                    cell.addEventListener('contextmenu', handleRightClick);
                    cell.addEventListener('mouseover', handleCellMouseOver);
                    cell.addEventListener('mouseout', handleCellMouseOut);
                    updateFlagMethodListeners(cell, x, y);
                    gridContainer.appendChild(cell);
                    
                    grid[y][x] = {
                        isMine: false,
                        isRevealed: false,
                        isFlagged: false,
                        adjacentMines: 0,
                        element: cell,
                    };
                }
            }
            
            updateMinesLeftDisplay();
            updateTimerDisplay();
            
            gridContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            document.addEventListener('mouseup', handleDocumentMouseUp);
        }
        
        // --- Event Handlers ---
        function handleRightClick(event) {
            event.preventDefault(); // Always prevent context menu
            
            // iOS Haptic Fix for Long Press:
            // The 'addLongPressListener' timer handles the flagging logic (visual update).
            // However, iOS Safari blocks the programmatic haptic click inside that setTimeout.
            // BUT, the native 'contextmenu' event fires shortly after the timer on iOS.
            // Since 'contextmenu' is a valid user interaction, we use it to fire the haptic we missed.
            if (flagMethod === 'longPress' && longPressFlaggedThisTouch) {
                triggerHaptic();
            }
            
            // Note: For Desktop right-click, handleCellMouseDown(button 2) handles the flag logic,
            // so we don't need to do anything else here.
        }
        
        function handleCellMouseDown(event) {
            if (gameOver) return;
            const targetCell = event.target.closest('.cell');
            if (!targetCell) return;
            
            // --- Right Click (Button 2) ---
            if (event.button === 2) {
                event.preventDefault();
                if (flagMethod === 'rightClick' && !gameOver) {
                    handleFlag(event);
                }
                return;
            }
            
            // --- Left Click (Button 0) ---
            if (event.button === 0) {
                initialMouseDownCell = targetCell;
                isLeftMouseDown = true;
                
                if (flagMethod === 'longPress') {
                    clearTimeout(mouseLongPressTimerId);
                    longPressJustFinishedMouse = false;
                    mouseLongPressTimerId = setTimeout(() => {
                        handleFlag(event);
                        longPressJustFinishedMouse = true;
                        mouseLongPressTimerId = null;
                        if (pressedCellElement) pressedCellElement.classList.remove('pressed');
                        pressedCellElement = null;
                        isLeftMouseDown = false;
                    }, longPressDelay);
                }
                
                const cellData = grid[parseInt(targetCell.dataset.y)][parseInt(targetCell.dataset.x)];
                if (cellData && !cellData.isRevealed && !cellData.isFlagged) {
                    targetCell.classList.add('pressed');
                    pressedCellElement = targetCell;
                } else {
                    pressedCellElement = null;
                }
            }
        }
        
        function handleCellMouseOver(event) {
            if (!isLeftMouseDown || gameOver) return;
            const targetCell = event.target.closest('.cell');
            if (!targetCell) {
                if(pressedCellElement) {
                    pressedCellElement.classList.remove('pressed');
                    pressedCellElement = null;
                }
                return;
            }
            
            const cellData = grid[parseInt(targetCell.dataset.y)][parseInt(targetCell.dataset.x)];
            if (!cellData) return;
            
            if (targetCell !== pressedCellElement) {
                if (pressedCellElement) {
                    pressedCellElement.classList.remove('pressed');
                }
                if (!cellData.isRevealed && !cellData.isFlagged) {
                    targetCell.classList.add('pressed');
                    pressedCellElement = targetCell;
                } else {
                    pressedCellElement = null;
                }
            }
        }
        
        function handleCellMouseOut(event) {
            if (!isLeftMouseDown || gameOver) return;
            const relatedTarget = event.relatedTarget;
            if (!relatedTarget || !relatedTarget.closest('#grid-container')) {
                if(pressedCellElement) {
                    pressedCellElement.classList.remove('pressed');
                    pressedCellElement = null;
                }
            }
        }
        
        function handleDocumentMouseUp(event) {
            if (event.button === 0 && isLeftMouseDown) {
                isLeftMouseDown = false;
                const mouseUpTargetElement = document.elementFromPoint(event.clientX, event.clientY);
                const mouseUpCellElement = mouseUpTargetElement ? mouseUpTargetElement.closest('.cell') : null;
                
                clearTimeout(mouseLongPressTimerId);
                mouseLongPressTimerId = null;
                
                if (longPressJustFinishedMouse) {
                    longPressJustFinishedMouse = false;
                    initialMouseDownCell = null;
                    if (pressedCellElement) {
                        pressedCellElement.classList.remove('pressed');
                        pressedCellElement = null;
                    }
                    return;
                }
                
                if (pressedCellElement) {
                    pressedCellElement.classList.remove('pressed');
                }
                pressedCellElement = null;
                
                if (gameOver) {
                    initialMouseDownCell = null;
                    return;
                }
                
                if (mouseUpCellElement) {
                    const x = parseInt(mouseUpCellElement.dataset.x);
                    const y = parseInt(mouseUpCellElement.dataset.y);
                    const cellData = grid[y]?.[x];
                    
                    if (cellData) {
                        if (firstClick) {
                            triggerHaptic(); // Haptic on first click
                            handleFirstClick(x, y);
                        } else if (cellData.isRevealed) {
                            chord(x, y);
                        } else if (!cellData.isFlagged) {
                            triggerHaptic(); // Haptic on normal reveal
                            revealCell(x, y);
                        }
                    }
                }
                initialMouseDownCell = null;
            } else {
                isLeftMouseDown = false;
                clearTimeout(mouseLongPressTimerId);
                mouseLongPressTimerId = null;
                if (pressedCellElement) {
                    pressedCellElement.classList.remove('pressed');
                    pressedCellElement = null;
                }
                initialMouseDownCell = null;
                longPressJustFinishedMouse = false;
            }
        }
        
        function handleClick(event) {
            if (ignoreNextClick) {
                ignoreNextClick = false;
                return;
            }
            if (gameOver) return;
            
            if (event.pointerType === 'mouse' && event.button === 0) return;
            
            const targetCell = event.target.closest('.cell');
            if (!targetCell) return;
            
            const x = parseInt(targetCell.dataset.x);
            const y = parseInt(targetCell.dataset.y);
            const cell = grid[y]?.[x];
            if (!cell) return;
            
            if (firstClick) {
                triggerHaptic();
                handleFirstClick(x, y);
                return;
            }
            
            if (cell.isRevealed) {
                if (chordMethod === 'doubleTap') {
                    handleDoubleTapChord(event);
                } else {
                    chord(x, y);
                }
            } else if (!cell.isFlagged) {
                if (flagMethod === 'doubleTap') {
                    if (doubleTapFlagTimer === null) {
                        triggerHaptic();
                        revealCell(x, y);
                    }
                } else {
                    triggerHaptic();
                    revealCell(x, y);
                }
            }
        }
        
        // --- Game Logic ---
        let firstClickInProgress = false;
        
        function handleFirstClick(x, y) {
            if (!firstClick || gameOver || firstClickInProgress) return;
            
            firstClickInProgress = true;
            
            attemptsSpan.textContent = '';
            if (noGuessMode) {
                generationAttempts = 0;
                let solvable = false;
                console.log("No Guess Mode: Starting generation...");
                attemptsSpan.textContent = 'Generating...';
                setTimeout(() => {
                    while (!solvable) {
                        generationAttempts++;
                        for (let r = 0; r < height; r++) {
                            for (let c = 0; c < width; c++) {
                                if(grid[r]?.[c]){
                                    grid[r][c].isMine = false;
                                    grid[r][c].adjacentMines = 0;
                                }
                            }
                        }
                        placeMines(x, y);
                        if (isSolvableWithoutGuessing(x, y)) {
                            solvable = true;
                            console.log(`No Guess Mode: Solvable grid found after ${generationAttempts} attempts.`);
                            attemptsSpan.textContent = `(${generationAttempts} attempts)`;
                            startTimer();
                            firstClick = false;
                            firstClickInProgress = false;
                            revealCell(x, y);
                        } else {
                            if (generationAttempts % 100 === 0) {
                                console.log(`No Guess Mode: Attempt ${generationAttempts}...`);
                                attemptsSpan.textContent = `Generating... (${generationAttempts})`;
                            }
                            if (generationAttempts > 50000) {
                                console.error(`No Guess Mode: Generation timed out after ${generationAttempts} attempts.`);
                                alert(`Failed to generate a solvable grid in No Guess Mode after ${generationAttempts} tries. Try reducing density or grid size, or disable No Guess Mode.`);
                                attemptsSpan.textContent = '(Generation Failed)';
                                firstClickInProgress = false;
                                restartGame();
                                return;
                            }
                        }
                    }
                }, 0);
            } else {
                placeMines(x, y);
                startTimer();
                firstClick = false;
                firstClickInProgress = false;
                revealCell(x, y);
            }
        }
        
        function updateFlagMethodListeners(cell, x, y) {
            if(!cell) return;
            
            removeLongPressListener(cell);
            cell.removeEventListener('touchstart', handleDoubleTapFlag);
            
            if (flagMethod === 'longPress') {
                addLongPressListener(cell, handleFlag);
            } else if (flagMethod === 'doubleTap') {
                cell.addEventListener('touchstart', handleDoubleTapFlag);
            }
        }
        
        function updateAllFlagMethodListeners() {
            for(let r = 0; r < height; r++){
                for(let c = 0; c < width; c++){
                    if (grid[r]?.[c]?.element) {
                        updateFlagMethodListeners(grid[r][c].element, c, r);
                    }
                }
            }
        }
        
        function handleDoubleTapFlag(event){
            if(gameOver || flagMethod !== 'doubleTap') return;
            
            const targetCell = event.target.closest('.cell');
            if (!targetCell) return;
            
            if(doubleTapFlagTimer === null){
                const timerId = setTimeout(() => event.preventDefault(), 150);
                doubleTapFlagTimer = setTimeout(() => {
                    doubleTapFlagTimer = null;
                    clearTimeout(timerId);
                    handleClick(event);
                }, 300);
                
                if (!targetCell.classList.contains('revealed') && !targetCell.classList.contains('flagged')) {
                    targetCell.classList.add('pressed');
                    setTimeout(() => {
                        if (doubleTapFlagTimer !== null) {
                            targetCell.classList.remove('pressed');
                        }
                    }, 150);
                }
            } else {
                clearTimeout(doubleTapFlagTimer);
                doubleTapFlagTimer = null;
                targetCell.classList.remove('pressed');
                handleFlag(event);
                ignoreNextClick = true;
                event.preventDefault();
            }
        }
        
        function handleDoubleTapChord(event){
            if(gameOver || chordMethod !== 'doubleTap') return;
            
            const targetCell = event.target.closest('.cell');
            if (!targetCell) return;
            
            const x = parseInt(targetCell.dataset.x);
            const y = parseInt(targetCell.dataset.y);
            const cell = grid[y]?.[x];
            if(!cell || !cell.isRevealed) return;
            
            if (doubleTapChordTimer === null) {
                const timerId = setTimeout(() => event.preventDefault(), 150);
                doubleTapChordTimer = setTimeout(() => {
                    doubleTapChordTimer = null;
                    clearTimeout(timerId);
                    targetCell.classList.remove('pressed');
                }, 300);
                
                targetCell.classList.add('pressed');
            } else {
                clearTimeout(doubleTapChordTimer);
                doubleTapChordTimer = null;
                targetCell.classList.remove('pressed');
                chord(x, y);
                ignoreNextClick = true;
                event.preventDefault();
            }
        }
        
        function placeMines(safeX, safeY) {
            let minesPlaced = 0;
            let availableSquares = [];
            
            const safeZone = new Set();
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    safeZone.add(`${safeX + dx},${safeY + dy}`);
                }
            }
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (!safeZone.has(`${x},${y}`)) {
                        availableSquares.push({x, y});
                    }
                }
            }
            
            for (let i = availableSquares.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [availableSquares[i], availableSquares[j]] = [availableSquares[j], availableSquares[i]];
            }
            
            const minesToPlace = Math.min(numMines, availableSquares.length);
            for (let i = 0; i < minesToPlace; i++) {
                const { x, y } = availableSquares[i];
                if(grid[y]?.[x]) {
                    grid[y][x].isMine = true;
                    minesPlaced++;
                }
            }
            
            calculateAdjacentMines();
        }
        
        function calculateAdjacentMines() {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = grid[y]?.[x];
                    if (cell && !cell.isMine) {
                        let count = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const newX = x + dx;
                                const newY = y + dy;
                                if (newX >= 0 && newX < width && newY >= 0 && newY < height && grid[newY]?.[newX]?.isMine) {
                                    count++;
                                }
                            }
                        }
                        cell.adjacentMines = count;
                        if(cell.element) cell.element.dataset.adjacent = count;
                    } else if (cell) {
                        cell.adjacentMines = -1;
                        if(cell.element) delete cell.element.dataset.adjacent;
                    }
                }
            }
        }
        
        function revealCell(x, y) {
            if (isNaN(x) || isNaN(y) || x < 0 || x >= width || y < 0 || y >= height || gameOver) return;
            
            const cell = grid[y]?.[x];
            if (!cell || cell.isRevealed || cell.isFlagged) return;
            
            cell.isRevealed = true;
            cell.element.classList.remove('pressed', 'flagged');
            cell.element.classList.add('revealed');
            cell.element.textContent = '';
            
            if (cell.isMine) {
                cell.element.classList.add('mine');
                cell.element.textContent = "💣";
                revealAllMines(x, y);
                showMessage("Game Over!");
            } else {
                cell.element.dataset.adjacent = cell.adjacentMines;
                if (cell.adjacentMines > 0) {
                    cell.element.textContent = cell.adjacentMines;
                } else {
                    cell.element.textContent = '';
                    
                    const revealQueue = [];
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nextX = x + dx;
                            const nextY = y + dy;
                            if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height) {
                                const neighborCell = grid[nextY]?.[nextX];
                                if(neighborCell && !neighborCell.isRevealed && !neighborCell.isFlagged){
                                    revealQueue.push({nx: nextX, ny: nextY});
                                }
                            }
                        }
                    }
                    
                    let processed = new Set([`${x},${y}`]);
                    
                    while(revealQueue.length > 0) {
                        const current = revealQueue.shift();
                        const currentX = current.nx;
                        const currentY = current.ny;
                        const currentKey = `${currentX},${currentY}`;
                        
                        if (processed.has(currentKey) || currentX < 0 || currentX >= width || currentY < 0 || currentY >= height) continue;
                        
                        const currentCell = grid[currentY]?.[currentX];
                        
                        if (!currentCell || currentCell.isRevealed || currentCell.isFlagged) {
                            processed.add(currentKey);
                            continue;
                        }
                        
                        processed.add(currentKey);
                        currentCell.isRevealed = true;
                        currentCell.element.classList.add('revealed');
                        currentCell.element.classList.remove('pressed', 'flagged');
                        currentCell.element.textContent = '';
                        currentCell.element.dataset.adjacent = currentCell.adjacentMines;
                        
                        if (currentCell.adjacentMines > 0) {
                            currentCell.element.textContent = currentCell.adjacentMines;
                        } else {
                            currentCell.element.textContent = '';
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    const nextX = currentX + dx;
                                    const nextY = currentY + dy;
                                    const nextKey = `${nextX},${nextY}`;
                                    
                                    if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height && !processed.has(nextKey)) {
                                        const neighborCell = grid[nextY]?.[nextX];
                                        if(neighborCell && !neighborCell.isRevealed && !neighborCell.isFlagged){
                                            revealQueue.push({nx: nextX, ny: nextY});
                                        } else {
                                            processed.add(nextKey);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            if (!gameOver) checkWin();
        }
        
        function handleFlag(event) {
            if (gameOver) return;
            
            const targetCell = event.target.closest('.cell');
            if (!targetCell) return;
            
            const x = parseInt(targetCell.dataset.x);
            const y = parseInt(targetCell.dataset.y);
            const cell = grid[y]?.[x];
            
            if (!cell || cell.isRevealed) return;
            
            // Try to trigger haptic feedback
            // On iOS, this might fail if called from the timer (setTimeout)
            // But it works if called from a direct event (click, contextmenu)
            triggerHaptic();
    
            if (cell.isFlagged) {
                cell.isFlagged = false;
                cell.element.classList.remove('flagged');
                cell.element.textContent = '';
                minesLeft++;
            } else if (minesLeft > 0) {
                cell.isFlagged = true;
                cell.element.classList.add('flagged');
                cell.element.textContent = '🚩';
                minesLeft--;
            } else {
                console.log("No flags left!");
            }
            
            updateMinesLeftDisplay();
            checkWin();
        }
        
        function chord(x, y){
            if (isNaN(x) || isNaN(y) || x < 0 || x >= width || y < 0 || y >= height || gameOver) return;
            
            const cell = grid[y]?.[x];
            
            if(!cell || !cell.isRevealed || cell.adjacentMines <= 0) return;
            
            let flaggedNeighbors = 0;
            let unknownAndUnflaggedNeighbors = [];
            
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const newX = x + dx;
                    const newY = y + dy;
                    if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                        const neighbor = grid[newY]?.[newX];
                        if (neighbor) {
                            if (neighbor.isFlagged) {
                                flaggedNeighbors++;
                            } else if (!neighbor.isRevealed) {
                                unknownAndUnflaggedNeighbors.push({x: newX, y: newY});
                            }
                        }
                    }
                }
            }
            
            if(flaggedNeighbors === cell.adjacentMines){
                // Trigger haptic for successful chord
                triggerHaptic();
                unknownAndUnflaggedNeighbors.forEach(pos => {
                    revealCell(pos.x, pos.y);
                });
            }
        }
        
        function revealAllMines(clickedX, clickedY) {
            gameOver = true;
            stopTimer();
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = grid[y]?.[x];
                    if (cell?.element) {
                        cell.element.classList.remove('pressed');
                        if (cell.isMine) {
                            if (!cell.isFlagged) {
                                cell.element.classList.add('mine-revealed');
                                cell.element.textContent = "💣";
                                
                                if (x === clickedX && y === clickedY) {
                                    cell.element.classList.remove('mine-revealed');
                                    cell.element.classList.add('mine');
                                }
                            }
                        } else if (cell.isFlagged) {
                            cell.element.classList.remove('flagged');
                            cell.element.classList.add('incorrect-flag');
                            cell.element.textContent = 'X';
                        }
                    }
                }
            }
        }
        
        function checkWin() {
            if (gameOver || firstClick) return;
            
            let revealedNonMineCount = 0;
            let totalNonMineCells = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = grid[y]?.[x];
                    if (!cell) continue;
                    
                    if (!cell.isMine) {
                        totalNonMineCells++;
                        if (cell.isRevealed) {
                            revealedNonMineCount++;
                        }
                    }
                }
            }
            
            if (revealedNonMineCount === totalNonMineCells && totalNonMineCells > 0) {
                const expectedNonMines = (width * height) - numMines;
                if(totalNonMineCells !== expectedNonMines) {
                    console.warn(`Win check discrepancy: Actual non-mines (${totalNonMineCells}) vs Expected (${expectedNonMines}). Win declared based on actual.`);
                }
                winGame(true);
            }
        }
        
        function winGame(autoFlag = true) {
            if (gameOver) return;
            
            gameOver = true;
            stopTimer();
            console.log("Win condition met!");
            
            let flagsPlaced = 0;
            if (autoFlag) {
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const cell = grid[y]?.[x];
                        if (cell?.isMine && !cell.isRevealed && !cell.isFlagged) {
                            cell.isFlagged = true;
                            if(cell.element) {
                                cell.element.classList.add('flagged');
                                cell.element.textContent = '🚩';
                            }
                            flagsPlaced++;
                        }
                    }
                }
                
                minesLeft -= flagsPlaced;
                if(minesLeft < 0) minesLeft = 0;
                updateMinesLeftDisplay();
            }
            
            flagIncorrectlyPlaced();
            updateLeaderboard();
            
            showMessage("You Win! Time: " + time.toFixed(3) + " seconds");
            
            if (pressedCellElement) {
                pressedCellElement.classList.remove('pressed');
                pressedCellElement = null;
            }
            isLeftMouseDown = false;
            clearTimeout(touchLongPressTimerId);
            touchLongPressTimerId = null;
            clearTimeout(mouseLongPressTimerId);
            mouseLongPressTimerId = null;
            clearTimeout(doubleTapFlagTimer);
            doubleTapFlagTimer = null;
            clearTimeout(doubleTapChordTimer);
            doubleTapChordTimer = null;
        }
        
        function flagIncorrectlyPlaced(){
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = grid[y]?.[x];
                    if (cell?.isFlagged && !cell.isMine) {
                        if(cell.element){
                            cell.element.classList.remove('flagged');
                            cell.element.classList.add('incorrect-flag');
                            cell.element.textContent = 'X';
                        }
                    }
                }
            }
        }
        
        // --- NEW Timer Functions using performance.now() ---
        function startTimer() {
            if (!gameStarted && timerStartTime === null) {
                gameStarted = true;
                timerStartTime = performance.now();
                time = 0.000;
                updateTimerDisplay();
                
                clearInterval(timerDisplayInterval);
                
                timerDisplayInterval = setInterval(() => {
                    if (!gameOver && timerStartTime !== null) {
                        const now = performance.now();
                        time = (now - timerStartTime) / 1000;
                        updateTimerDisplay();
                    } else {
                        clearInterval(timerDisplayInterval);
                        timerDisplayInterval = null;
                    }
                }, timerUpdateDelay);
            }
        }
        
        function stopTimer() {
            clearInterval(timerDisplayInterval);
            timerDisplayInterval = null;
            
            if (gameStarted && timerStartTime !== null) {
                const endTime = performance.now();
                time = (endTime - timerStartTime) / 1000;
                timerStartTime = null;
            }
            
            timerStartTime = null;
            updateTimerDisplay();
        }
        
        // --- Touch / Long Press Handling ---
        function addLongPressListener(element, callback) {
            let elementTouchTimerId = null;
            longPressFlaggedThisTouch = false;
            let startX, startY;
            
            const handleTouchStart = (e) => {
                if (e.touches.length === 1 && elementTouchTimerId === null) {
                    longPressFlaggedThisTouch = false;
                    ignoreNextClick = false;
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    
                    elementTouchTimerId = setTimeout(() => {
                        longPressFlaggedThisTouch = true;
                        callback(e); // Performs the VISUAL Flag (but haptic might fail on iOS here)
                        ignoreNextClick = true;
                        elementTouchTimerId = null;
                        e.preventDefault();
                        const tc = e.target.closest('.cell');
                        if (tc) tc.classList.remove('pressed');
                    }, longPressDelay);
                    
                    const tc = e.target.closest('.cell');
                    if (tc && !tc.classList.contains('revealed') && !tc.classList.contains('flagged')) {
                        tc.classList.add('pressed');
                    }
                }
            };
            
            const handleTouchEnd = (e) => {
                const tc = e.target.closest('.cell');
                if (tc) tc.classList.remove('pressed');
                
                if (elementTouchTimerId !== null) {
                    clearTimeout(elementTouchTimerId);
                    elementTouchTimerId = null;
                }
                
                if (longPressFlaggedThisTouch) {
                    longPressFlaggedThisTouch = false;
                    e.preventDefault();
                }
            };
            
            const handleTouchMove = (e) => {
                if (elementTouchTimerId !== null) {
                    const currentX = e.touches[0].clientX;
                    const currentY = e.touches[0].clientY;
                    const deltaX = Math.abs(currentX - startX);
                    const deltaY = Math.abs(currentY - startY);
                    
                    if (deltaX > 10 || deltaY > 10) {
                        clearTimeout(elementTouchTimerId);
                        elementTouchTimerId = null;
                        longPressFlaggedThisTouch = false;
                        ignoreNextClick = false;
                        const tc = e.target.closest('.cell');
                        if (tc) tc.classList.remove('pressed');
                    }
                }
            };
            
            element.addEventListener('touchstart', handleTouchStart, { passive: false });
            element.addEventListener('touchend', handleTouchEnd, { passive: false });
            element.addEventListener('touchmove', handleTouchMove, { passive: false });
            
            element._touchStartHandlerLP = handleTouchStart;
            element._touchEndHandlerLP = handleTouchEnd;
            element._touchMoveHandlerLP = handleTouchMove;
        }
        
        function removeLongPressListener(element) {
            if (element._touchStartHandlerLP) {
                element.removeEventListener('touchstart', element._touchStartHandlerLP, { passive: false });
                delete element._touchStartHandlerLP;
            }
            if (element._touchEndHandlerLP) {
                element.removeEventListener('touchend', element._touchEndHandlerLP, { passive: false });
                delete element._touchEndHandlerLP;
            }
            if (element._touchMoveHandlerLP) {
                element.removeEventListener('touchmove', element._touchMoveHandlerLP, { passive: false });
                delete element._touchMoveHandlerLP;
            }
        }
        
        // --- Settings / UI ---
        function handleDifficultyChange() {
            const selectedDifficulty = difficultySelector.value;
            setDifficulty(selectedDifficulty);
        }
        
        function toggleSettings() {
            const isOpen = settingsPanel.classList.contains('open');
            if (isOpen) {
                settingsPanel.classList.remove('open');
                overlay.style.display = 'none';
                
                if (noGuessMode && firstClick && generationAttempts > 0) {
                    attemptsSpan.textContent = `(${generationAttempts} attempts)`;
                } else if (!firstClick && noGuessMode) {
                    attemptsSpan.textContent = `(${generationAttempts} attempts)`;
                } else {
                    attemptsSpan.textContent = '';
                }
            } else {
                longPressDelayValueSpan.textContent = longPressDelay;
                longPressDelayInput.value = longPressDelay;
                widthInput.value = width;
                heightInput.value = height;
                minesInput.value = numMines;
                playerNameInput.value = playerName;
                lightModeCheckbox.checked = document.body.classList.contains('light-mode');
                noGuessCheckbox.checked = noGuessMode;
                flagMethodSelect.value = flagMethod;
                chordMethodSelect.value = chordMethod;
                
                if (currentDifficulty === 'custom') {
                    customSettingsDiv.classList.add('active');
                    const currentW = parseInt(widthInput.value) || width;
                    const currentH = parseInt(heightInput.value) || height;
                    const maxMines = (currentW * currentH) - 9;
                    minesInput.max = maxMines > 0 ? maxMines : 1;
                } else {
                    customSettingsDiv.classList.remove('active');
                }
                
                attemptsSpan.textContent = '';
                
                settingsPanel.classList.add('open');
                overlay.style.display = 'block';
            }
        }
        
        function closePanels() {
            if (settingsPanel.classList.contains('open')) {
                toggleSettings();
            }
        }
        
        function updateTimerDisplay(){
            if (timerDisplay) {
                timerDisplay.textContent = time.toFixed(3);
            }
        }
        
        function updateMinesLeftDisplay(){
            if (minesLeftDisplay) minesLeftDisplay.textContent = minesLeft < 0 ? 0 : minesLeft;
        }
        
        function setDifficulty(difficulty) {
            const needsRestart = currentDifficulty !== difficulty || difficulty === 'custom';
            currentDifficulty = difficulty;
            difficultySelector.value = currentDifficulty;
            attemptsSpan.textContent = '';
            
            if (difficulty === 'custom') {
                customSettingsDiv.classList.add('active');
                if (!customSettingsDiv.classList.contains('active-before-change')) {
                    widthInput.value = width;
                    heightInput.value = height;
                    minesInput.value = numMines;
                }
                const maxMinesCustom = (parseInt(widthInput.value) * parseInt(heightInput.value)) - 9;
                minesInput.max = maxMinesCustom > 0 ? maxMinesCustom : 1;
                customSettingsDiv.classList.add('active-before-change');
                
                return;
            } else {
                customSettingsDiv.classList.remove('active');
                customSettingsDiv.classList.remove('active-before-change');
                
                switch (difficulty) {
                    case 'beginner':
                        width = 9; height = 9; numMines = 10;
                        break;
                    case 'intermediate':
                        width = 16; height = 16; numMines = 40;
                        break;
                    case 'expert':
                        width = 30; height = 16; numMines = 99;
                        break;
                }
                
                widthInput.value = width;
                heightInput.value = height;
                minesInput.value = numMines;
                const maxMinesStandard = (width * height) - 9;
                minesInput.max = maxMinesStandard > 0 ? maxMinesStandard : 1;
            }
            
            localStorage.setItem('currentDifficulty', currentDifficulty);
            localStorage.setItem('width', width);
            localStorage.setItem('height', height);
            localStorage.setItem('numMines', numMines);
            
            minesLeft = numMines;
            
            if (needsRestart) {
                restartGame();
            }
        }
        
        function showMessage(message) {
            messageText.textContent = message;
            messageBox.style.display = 'block';
            overlay.style.display = 'block';
            
            if (settingsPanel.classList.contains('open')) {
                settingsPanel.classList.remove('open');
            }
        }
        
        function restartGame() {
            stopTimer();
            time = 0.000;
            updateTimerDisplay();
            gameStarted = false;
            firstClick = true;
            gameOver = false;
            minesLeft = numMines;
            updateMinesLeftDisplay();
            generationAttempts = 0;
            if(attemptsSpan) attemptsSpan.textContent = '';
            
            ignoreNextClick = false;
            longPressFlaggedThisTouch = false;
            longPressJustFinishedMouse = false;
            isLeftMouseDown = false;
            if (pressedCellElement) {
                pressedCellElement.classList.remove('pressed');
                pressedCellElement = null;
            }
            initialMouseDownCell = null;
            clearTimeout(touchLongPressTimerId);
            touchLongPressTimerId = null;
            clearTimeout(mouseLongPressTimerId);
            mouseLongPressTimerId = null;
            clearTimeout(doubleTapFlagTimer);
            doubleTapFlagTimer = null;
            clearTimeout(doubleTapChordTimer);
            doubleTapChordTimer = null;
            
            document.removeEventListener('mouseup', handleDocumentMouseUp);
            
            if (headerArea && controlsDiv) {
                headerArea.classList.remove('header-gap-small', 'header-gap-medium', 'header-gap-large');
                controlsDiv.classList.remove('controls-gap-small', 'controls-gap-medium', 'controls-gap-large');
                
                if (width <= 12) {
                    headerArea.classList.add('header-gap-small');
                    controlsDiv.classList.add('controls-gap-small');
                } else if (width <= 22) {
                    headerArea.classList.add('header-gap-medium');
                    controlsDiv.classList.add('controls-gap-medium');
                } else {
                    headerArea.classList.add('header-gap-large');
                    controlsDiv.classList.add('controls-gap-large');
                }
            }
            
            createGrid();
            
            messageBox.style.display = 'none';
            if (!settingsPanel.classList.contains('open')) {
                overlay.style.display = 'none';
            }
            
            updateAllFlagMethodListeners();
        }
        
        // --- Leaderboard Handling ---
        function getLeaderboardDifficultyString() {
            if (currentDifficulty === 'custom') return null;
            let ds = currentDifficulty;
            if (noGuessMode) ds += "_noguess";
            return ds;
        }
        
        function updateLeaderboard() {
            const difficultyString = getLeaderboardDifficultyString();
            if (!difficultyString) {
                console.log("Score not submitted for custom difficulty.");
                return;
            }
            
            const finalTime = time;
            const currentName = playerNameInput.value.trim() || "Player";
            
            if (!currentName) {
                console.log(`Score not submitted for ${difficultyString}: Enter a valid name.`);
                
                let bestTimeLocalStr = localStorage.getItem(`leaderboard-${difficultyString}`);
                let bestTimeLocal = parseFloat(bestTimeLocalStr);
                
                if (bestTimeLocalStr === null || isNaN(bestTimeLocal) || finalTime < bestTimeLocal) {
                    localStorage.setItem(`leaderboard-${difficultyString}`, finalTime.toString());
                    bestTimeLocal = finalTime;
                }
                
                const localTimeCell = document.getElementById(`leaderboard-${difficultyString}-local`);
                if (localTimeCell) localTimeCell.textContent = bestTimeLocalStr === null || isNaN(bestTimeLocal) ? '-' : bestTimeLocal.toFixed(3);
                return;
            }
            
            db.collection('leaderboard').add({
                playerName: currentName,
                difficulty: difficultyString,
                score: finalTime,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            })
            .then(() => {
                console.log(`Score submitted for ${difficultyString}!`);
                loadOnlineLeaderboard();
            })
            .catch((error) => {
                console.error(`Error submitting score for ${difficultyString}: `, error);
                leaderboardErrorDiv.textContent='Error submitting score.';
                leaderboardErrorDiv.style.display='block';
                leaderboardLoadingDiv.style.display = 'none';
            });
            
            let bestTimeLocalStr = localStorage.getItem(`leaderboard-${difficultyString}`);
            let bestTimeLocal = parseFloat(bestTimeLocalStr);
            
            if (bestTimeLocalStr === null || isNaN(bestTimeLocal) || finalTime < bestTimeLocal) {
                localStorage.setItem(`leaderboard-${difficultyString}`, finalTime.toString());
                bestTimeLocal = finalTime;
            }
            
            const localTimeCell = document.getElementById(`leaderboard-${difficultyString}-local`);
            if (localTimeCell) localTimeCell.textContent = bestTimeLocalStr === null || isNaN(bestTimeLocal) ? '-' : bestTimeLocal.toFixed(3);
        }
        
        async function fetchScoresRecursive(difficulty, targetCount, collectedScores = [], lastVisible = null) {
            let q = db.collection('leaderboard')
                .where('difficulty', '==', difficulty)
                .where('score', '>', 0)
                .orderBy('score', 'asc');
            
            if (lastVisible) {
                q = q.startAfter(lastVisible);
            }
            
            q = q.limit(targetCount * 2);
            
            try {
                const querySnapshot = await q.get();
                const nextLastVisible = querySnapshot.docs[querySnapshot.docs.length - 1];
                let addedCount = 0;
                
                querySnapshot.forEach((doc) => {
                    if (collectedScores.length >= targetCount) return;
                    
                    const data = doc.data();
                    if (typeof data.score === 'number' && data.score >= 0 && 
                        typeof data.playerName === 'string' && data.playerName.trim() !== '') {
                        collectedScores.push(data);
                        addedCount++;
                    } else {
                        console.warn("Skipping invalid score data:", data);
                    }
                });
                
                if (collectedScores.length < targetCount && addedCount > 0 && nextLastVisible && querySnapshot.docs.length === (targetCount * 2)) {
                    console.log(`Fetching more for ${difficulty}, currently have ${collectedScores.length}/${targetCount}`);
                    return fetchScoresRecursive(difficulty, targetCount, collectedScores, nextLastVisible);
                } else {
                    return collectedScores;
                }
            } catch (error) {
                console.error(`Error fetching scores for ${difficulty}:`, error);
                const errorDisplay = document.getElementById('leaderboard-error');
                if(errorDisplay) {
                    errorDisplay.textContent=`Error loading ${difficulty} leaderboard.`;
                    errorDisplay.style.display='block';
                }
                return collectedScores;
            }
        }
        
        async function loadOnlineLeaderboard() {
            leaderboardLoadingDiv.style.display = 'block';
            leaderboardErrorDiv.style.display = 'none';
            
            const difficulties = [
                'beginner','intermediate','expert',
                'beginner_noguess','intermediate_noguess','expert_noguess'
            ];
            const targetCount = 10;
            
            difficulties.forEach(d => {
                const tbody = document.getElementById(`leaderboard-${d}`);
                if (tbody) tbody.innerHTML = '';
            });
            
            try {
                const promises = difficulties.map(async diff => {
                    const tbody = document.getElementById(`leaderboard-${diff}`);
                    if (!tbody) return;
                    
                    tbody.innerHTML = '<tr><td colspan="3">Loading...</td></tr>';
                    
                    const rawScores = await fetchScoresRecursive(diff, targetCount * 2, []);
                    
                    tbody.innerHTML = '';
                    
                    const adjusted = rawScores.map(s => {
                        const legacy = Number.isInteger(s.score);
                        const adjustedScore = legacy ? s.score + 0.999 : s.score;
                        return { ...s, adjustedScore, legacy };
                    }).sort((a,b) => a.adjustedScore - b.adjustedScore)
                      .slice(0, targetCount);
                    
                    if(adjusted.length === 0){
                        tbody.innerHTML = '<tr><td colspan="3">No scores yet.</td></tr>';
                        return;
                    }
                    
                    let rank = 1;
                    adjusted.forEach(data => {
                        const row = tbody.insertRow();
                        row.insertCell().textContent = rank++;
                        const nameCell = row.insertCell();
                        nameCell.textContent = sanitize(String(data.playerName || 'Anonymous').slice(0, 20));
                        const scoreCell = row.insertCell();
                        const scoreString = data.adjustedScore.toFixed(3);
                        const legacyIconHtml = data.legacy ? 
                            `<span class="legacy-icon" title="Legacy score recorded under the old integer timing system – displayed as the slowest possible time for that second.">🕰️</span>` : '';
                        scoreCell.innerHTML = `${scoreString}${legacyIconHtml}`;
                    });
                });
                
                await Promise.all(promises);
                leaderboardLoadingDiv.style.display = 'none';
                
            } catch (err) {
                console.error("Overall leaderboard loading/rendering error:", err);
                leaderboardLoadingDiv.style.display = 'none';
                
                if (leaderboardErrorDiv.style.display === 'none') {
                    leaderboardErrorDiv.textContent = 'Error loading one or more leaderboards.';
                    leaderboardErrorDiv.style.display = 'block';
                }
            }
        }
        
        function loadLeaderboard() {
            const difficulties = ['beginner','intermediate','expert','beginner_noguess','intermediate_noguess','expert_noguess'];
            difficulties.forEach(d => {
                const bestTimeStr = localStorage.getItem(`leaderboard-${d}`);
                const bestTime = parseFloat(bestTimeStr);
                const timeCell = document.getElementById(`leaderboard-${d}-local`);
                if (timeCell) {
                    timeCell.textContent = bestTimeStr === null || isNaN(bestTime) ? '-' : bestTime.toFixed(3);
                }
            });
        }
        
        function loadSettings() {
            playerName = localStorage.getItem('playerName') || 'Player';
            playerNameInput.value = playerName;
            
            const savedDarkMode = localStorage.getItem('darkMode');
            const isLightMode = savedDarkMode === 'enabled';
            lightModeCheckbox.checked = isLightMode;
            
            if (isLightMode) {
                document.body.classList.add('light-mode');
                if (logoElement) logoElement.src = "/LightModeLogo.svg";
            } else {
                document.body.classList.remove('light-mode');
                if (logoElement) logoElement.src = "/DarkModeLogo.svg";
            }
            
            flagMethod = localStorage.getItem('flagMethod') || 'longPress';
            flagMethodSelect.value = flagMethod;
            
            longPressDelay = parseInt(localStorage.getItem('longPressDelay')) || 500;
            longPressDelayInput.value = longPressDelay;
            longPressDelayValueSpan.textContent = longPressDelay;
            
            chordMethod = localStorage.getItem('chordMethod') || 'singleTap';
            chordMethodSelect.value = chordMethod;
            
            noGuessMode = localStorage.getItem('noGuessMode') === 'true';
            noGuessCheckbox.checked = noGuessMode;
            attemptsSpan.textContent = '';
            
            currentDifficulty = localStorage.getItem('currentDifficulty') || 'beginner';
            width = parseInt(localStorage.getItem('width')) || 9;
            height = parseInt(localStorage.getItem('height')) || 9;
            numMines = parseInt(localStorage.getItem('numMines')) || 10;
            
            setDifficulty(currentDifficulty);
            
            if (currentDifficulty === 'custom') {
                widthInput.value = width;
                heightInput.value = height;
                minesInput.value = numMines;
                const maxMines = (width * height) - 9;
                minesInput.max = maxMines > 0 ? maxMines : 1;
                customSettingsDiv.classList.add('active');
            }
            
            minesLeft = numMines;
            restartGame();
        }
        
        // --- No Guess Mode Solver Logic ---
        function getNeighbors(x, y, W, H) {
            const n = [];
            for (let dy = -1; dy <= 1; dy++)
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < W && ny >= 0 && ny < H) n.push({ x: nx, y: ny });
                }
            return n;
        }
        
        function isSolvableWithoutGuessing(startX, startY) {
            const solverGrid = Array(height).fill(null).map(() => Array(width).fill(null).map(() => ({
                state: -2
            })));
            
            let revealedCount = 0;
            let minesFound = 0;
            const totalNonMines = (width * height) - numMines;
            const processQueue = [];
            const W = width;
            const H = height;
            
            const solverReveal = (x, y) => {
                if (x < 0 || x >= W || y < 0 || y >= H || solverGrid[y]?.[x]?.state !== -2) return false;
                
                const actualCellData = grid[y]?.[x];
                if (!actualCellData || actualCellData.isMine) return false;
                
                const adjacentMines = actualCellData.adjacentMines;
                solverGrid[y][x].state = adjacentMines;
                revealedCount++;
                
                if (adjacentMines === 0) {
                    getNeighbors(x, y, W, H).forEach(n => {
                        if (solverGrid[n.y]?.[n.x]?.state === -2) {
                            processQueue.push(n);
                        }
                    });
                }
                return true;
            };
            
            const solverFlag = (x, y) => {
                if (x < 0 || x >= W || y < 0 || y >= H || solverGrid[y]?.[x]?.state !== -2) return false;
                
                const actualCellData = grid[y]?.[x];
                if (!actualCellData || !actualCellData.isMine) return false;
                
                solverGrid[y][x].state = -1;
                minesFound++;
                return true;
            };
            
            if(startX >= 0 && startX < W && startY >= 0 && startY < H){
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const cx = startX + dx, cy = startY + dy;
                        if (cx >= 0 && cx < W && cy >= 0 && cy < H) {
                            if(!grid[cy]?.[cx]?.isMine){
                                solverReveal(cx, cy);
                            }
                        }
                    }
                }
            } else {
                console.error("Invalid start coordinates for solver:", startX, startY);
                return false;
            }
            
            let madeProgress = true;
            while (madeProgress) {
                madeProgress = false;
                
                while (processQueue.length > 0) {
                    const { x, y } = processQueue.shift();
                    if (solverGrid[y]?.[x]?.state === -2 && solverReveal(x, y)) {
                        madeProgress = true;
                    }
                }
                
                let innerProgress = true;
                while(innerProgress){
                    innerProgress = false;
                    for (let y = 0; y < H; y++) {
                        for (let x = 0; x < W; x++) {
                            if (!solverGrid[y]?.[x]) continue;
                            const cellState = solverGrid[y][x].state;
                            if (cellState >= 1 && cellState <= 8) {
                                const neighbors = getNeighbors(x, y, W, H);
                                let unknownNeighbors = [];
                                let flaggedNeighborCount = 0;
                                
                                neighbors.forEach(n => {
                                    const neighborState = solverGrid[n.y]?.[n.x]?.state;
                                    if (neighborState === -2) { unknownNeighbors.push(n); }
                                    else if (neighborState === -1) { flaggedNeighborCount++; }
                                });
                                
                                if (flaggedNeighborCount === cellState && unknownNeighbors.length > 0) {
                                    unknownNeighbors.forEach(n => {
                                        if (solverReveal(n.x, n.y)) {
                                            innerProgress = true;
                                            madeProgress = true;
                                        }
                                    });
                                    if(innerProgress) continue;
                                }
                                
                                if (unknownNeighbors.length > 0 && (flaggedNeighborCount + unknownNeighbors.length === cellState)) {
                                    let failedFlag = false;
                                    unknownNeighbors.forEach(n => {
                                        if (!solverFlag(n.x, n.y)) {
                                            if(solverGrid[n.y]?.[n.x]?.state !== -1) {
                                                failedFlag = true;
                                            }
                                        } else {
                                            innerProgress = true;
                                            madeProgress = true;
                                        }
                                    });
                                    if(failedFlag) {
                                        console.error("Solver inconsistency: Tried to flag a cell that couldn't be flagged as a mine.");
                                        return false;
                                    }
                                    if(innerProgress) continue;
                                }
                            }
                        }
                    }
                    
                    while (processQueue.length > 0) {
                        const { x, y } = processQueue.shift();
                        if (solverGrid[y]?.[x]?.state === -2 && solverReveal(x, y)) {
                            innerProgress = true;
                            madeProgress = true;
                        }
                    }
                }
                
                if (!madeProgress) break;
            }
            
            return revealedCount === totalNonMines && revealedCount > 0;
        }
        
        document.addEventListener('click', e => {
            const legacyIconElement = e.target.closest('.legacy-icon');
            
            if (legacyIconElement) {
                const message = legacyIconElement.getAttribute('title') || 
                    'Legacy score: recorded before decimal‑precision timing. Value shown is slowest possible within that second.';
                alert(message);
            }
        });
        
        // --- Initialize ---
        document.addEventListener('DOMContentLoaded', () => {
            initHaptics(); // Initialize the haptic elements
            loadSettings();
            loadLeaderboard();
            loadOnlineLeaderboard();
            addAutoSaveListeners();
        });
        </script>
</body>
</html>
