<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Min3s – Mobile Minesweeper Game No Guess with Leaderboards</title>
    <meta name="description" content="Play Minesweeper online at Min3s.click! No ads, Mobile‑friendly, no‑guess mode, and live global leaderboard.">
    
    <link rel="manifest" href="/manifest.webmanifest">
    
    <meta name="theme-color" content="#ffffff">

    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-firestore-compat.js"></script>
    
    <style>
        /* Base Styles (Dark Mode - Now Default) */
        :root {
            --bg-color: #333;
            --container-bg: #444;
            --grid-border-color: #666;
            --grid-bg-color: #555;
            --cell-bg-color: #666;
            --cell-border-color: #777;
            --revealed-cell-bg: #555;
            --revealed-cell-border: #888;
            --flagged-cell-bg: #4682B4; /* Steel Blue */
            --flagged-cell-color: #FFD700; /* Gold */
            --mine-bg-color: #B22222; /* Firebrick - Not used directly, see .mine */
            --mine-revealed-bg: #800000; /* Maroon */
            --mine-revealed-color: white;
            --incorrect-flag-bg: #A0522D; /* Sienna */
            --incorrect-flag-color: white;
            --text-color: white;
            --button-bg: #3e8e41;
            --button-hover-bg: #2e6e31;
            --button-text-color: white;
            --control-border-color: #aaa;
            --control-bg-color: #444;
            --cell-pressed-bg: #777; /* Added style for pressed cell */
            --input-bg-color: #555; /* Added for inputs */
            --input-border-color: #777; /* Added for inputs */
            --input-text-color: white; /* Added for inputs */
            --settings-panel-width: 300px; /* Width for the side panel */
            
            /* Dark mode number colors (lighter) */
            --num-1-color-dark: #ADD8E6; /* Light Blue */
            --num-2-color-dark: #90EE90; /* Light Green */
            --num-3-color-dark: #F08080; /* Light Coral */
            --num-4-color-dark: #B0C4DE; /* Light Steel Blue */
            --num-5-color-dark: #FFA07A; /* Light Salmon */
            --num-6-color-dark: #20B2AA; /* Light Sea Green */
            --num-7-color-dark: #E6E6FA; /* Lavender (lighter than grey) */
            --num-8-color-dark: #D3D3D3; /* Light Gray */
        }
        
        /* Light Mode Styles */
        .light-mode {
            --bg-color: #e0e0e0;
            --container-bg: white;
            --grid-border-color: #a0a0a0;
            --grid-bg-color: #c0c0c0;
            --cell-bg-color: #d0d0d0;
            --cell-border-color: #f0f0f0;
            --revealed-cell-bg: #f8f8f8;
            --revealed-cell-border: #909090;
            --flagged-cell-bg: #87CEEB; /* Sky Blue */
            --flagged-cell-color: #B22222; /* Firebrick */
            /* --mine-bg-color: #F08080; */ /* Light Coral - Not used directly */
            --mine-revealed-bg: #DC143C; /* Crimson */
            --mine-revealed-color: white;
            --incorrect-flag-bg: #FFD700; /* Gold */
            --incorrect-flag-color: black;
            --text-color: black;
            --button-bg: #4CAF50;
            --button-hover-bg: #3e8e41;
            --button-text-color: white;
            --control-border-color: #808080;
            --control-bg-color: #f0f0f0;
            --cell-pressed-bg: #e8e8e8; /* Added style for pressed cell */
            --input-bg-color: #fdfdfd; /* Added for inputs */
            --input-border-color: #bbb; /* Added for inputs */
            --input-text-color: black; /* Added for inputs */
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to the top */
            min-height: 100vh;
            margin: 0;
            padding-top: 20px; /* Add some padding at the top */
            background-color: var(--bg-color);
            color: var(--text-color);
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation; /* Prevent double-tap zoom */
            box-sizing: border-box;
        }
        
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center; /* Center the header-area and grid */
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            overflow: visible; /* Allow difficulty dropdown to overflow visually */
            background-color: var(--container-bg);
            padding: 15px; /* Increased padding slightly */
            position: relative; /* Needed for absolute positioning if used, but flex is fine */
        }
        
        /* Style for the header area containing logo and controls */
        #header-area {
            display: flex;
            align-items: center; /* Vertically align items */
            justify-content: center; /* Center the items horizontally */
            width: 100%; /* Take full width of the container */
            margin-bottom: 15px; /* Space below the header area */
            padding: 0;
            transition: gap 0.3s ease; /* Add smooth transition for gap changes */
        }
        
        /* CSS for dynamic header gap */
        #header-area.header-gap-small {
            gap: 20px;
        }
        
        #header-area.header-gap-medium {
            gap: 50px;
        }
        
        #header-area.header-gap-large {
            gap: 100px;
        }
        
        /* CSS for dynamic controls gap */
        #controls.controls-gap-small {
            gap: 10px;
        }
        
        #controls.controls-gap-medium {
            gap: 25px;
        }
        
        #controls.controls-gap-large {
            gap: 40px;
        }
        
        #logo {
            height: 70px;
            flex-shrink: 0;
        }
        
        /* New Difficulty Selector Area */
        #difficulty-selector-area {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px; /* Space below the dropdown */
            width: 100%;
        }
        
        #difficulty-selector-area label {
            margin-right: 10px;
            font-weight: bold;
        }
        
        #difficulty-selector {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--control-border-color);
            background-color: var(--input-bg-color);
            color: var(--text-color);
            font-size: 1em;
            cursor: pointer;
        }
        
        #difficulty-selector:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--button-bg);
        }
        
        #grid-container {
            display: grid;
            grid-gap: 1px;
            border: 3px solid var(--grid-border-color);
            background-color: var(--grid-bg-color);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .cell {
            width: 28px;
            height: 28px;
            background-color: var(--cell-bg-color);
            border: 2px outset var(--cell-border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            transition: background-color 0.1s; /* Faster transition */
        }
        
        .cell.pressed { /* Style for when left mouse is down */
            background-color: var(--cell-pressed-bg);
            border-style: inset; /* Give pressed appearance */
        }
        
        .cell.revealed {
            border: 1px solid var(--revealed-cell-border);
            background-color: var(--revealed-cell-bg);
            cursor: default;
        }
        
        .cell.flagged {
            background-color: var(--flagged-cell-bg);
            color: var(--flagged-cell-color);
        }
        
        .cell.mine { /* Style for the mine hit that ends the game */
            background-color: red !important; /* Make it stand out */
            color: white;
        }
        
        .cell.mine-revealed { /* Style for other mines shown on loss */
            background-color: var(--mine-revealed-bg);
            color: var(--mine-revealed-color);
        }
        
        .cell.incorrect-flag {
            background-color: var(--incorrect-flag-bg);
            color: var(--incorrect-flag-color);
        }
        
        /* Dark Mode Number colors */
        .cell[data-adjacent="1"] { color: var(--num-1-color-dark); }
        .cell[data-adjacent="2"] { color: var(--num-2-color-dark); }
        .cell[data-adjacent="3"] { color: var(--num-3-color-dark); }
        .cell[data-adjacent="4"] { color: var(--num-4-color-dark); }
        .cell[data-adjacent="5"] { color: var(--num-5-color-dark); }
        .cell[data-adjacent="6"] { color: var(--num-6-color-dark); }
        .cell[data-adjacent="7"] { color: var(--num-7-color-dark); }
        .cell[data-adjacent="8"] { color: var(--num-8-color-dark); }
        
        /* Light mode number colors (standard/original) */
        .light-mode .cell[data-adjacent="1"] { color: blue; }
        .light-mode .cell[data-adjacent="2"] { color: green; }
        .light-mode .cell[data-adjacent="3"] { color: red; }
        .light-mode .cell[data-adjacent="4"] { color: navy; }
        .light-mode .cell[data-adjacent="5"] { color: maroon; }
        .light-mode .cell[data-adjacent="6"] { color: teal; }
        .light-mode .cell[data-adjacent="7"] { color: black; }
        .light-mode .cell[data-adjacent="8"] { color: gray; }
        
        #controls {
            display: flex;
            /* gap: 10px; -- Removed fixed gap, now controlled by classes */
            margin-bottom: 0;
            align-items: center;
            flex-shrink: 0;
            transition: gap 0.3s ease; /* Add smooth transition for gap changes */
        }
        
        #timer, #mines-left {
            font-size: 1.1em;
            font-weight: bold;
            padding: 6px 12px;
            border: 2px solid var(--control-border-color);
            background-color: var(--control-bg-color);
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 80px; /* Increased min-width to accommodate decimals */
            text-align: center;
        }
        
        #timer-label, #mines-left-label {
            font-size: 0.8em;
            color: var(--text-color);
            margin-bottom: 2px;
        }
        
        /* Settings Toggle Button (New Side Button) */
        #settings-toggle-button {
            position: fixed;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            writing-mode: vertical-rl; /* Rotate text */
            text-orientation: mixed;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            padding: 15px 8px;
            font-size: 1.1em;
            cursor: pointer;
            border-radius: 8px 0 0 8px; /* Rounded corners on the left */
            box-shadow: -2px 0px 5px rgba(0,0,0,0.2);
            z-index: 1005; /* Above game, below panel overlay */
            transition: background-color 0.3s;
        }
        
        #settings-toggle-button:hover {
            background-color: var(--button-hover-bg);
        }
        
        /* Settings Panel (New Side Panel) */
        #settings-panel {
            display: block; /* Always block, position controls visibility */
            position: fixed;
            top: 0;
            right: calc(-1 * var(--settings-panel-width) - 10px); /* Start hidden off-screen */
            width: var(--settings-panel-width);
            height: 100vh; /* Full viewport height */
            background-color: var(--container-bg);
            color: var(--text-color);
            padding: 25px;
            border-left: 2px solid var(--grid-border-color); /* Border on the visible edge */
            box-shadow: -5px 0px 15px rgba(0,0,0,0.3);
            z-index: 1010; /* Above toggle button and overlay */
            overflow-y: auto; /* Enable vertical scrolling */
            box-sizing: border-box; /* Include padding in width */
            transition: right 0.3s ease-in-out; /* Slide animation */
        }
        
        #settings-panel.open {
            right: 0; /* Slide into view */
        }
        
        #settings-panel h2 {
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
        }
        
        #settings-panel label {
            display: block;
            margin-bottom: 6px;
            font-weight: bold;
        }
        
        #settings-panel input[type="number"],
        #settings-panel input[type="range"],
        #settings-panel input[type="text"],
        #settings-panel select { /* Apply styles to select too */
            width: calc(100% - 20px); /* Adjusted width calculation */
            margin-bottom: 12px;
            padding: 8px;
            border: 1px solid var(--input-border-color);
            border-radius: 5px;
            font-size: 1em;
            background-color: var(--input-bg-color);
            color: var(--input-text-color);
            box-sizing: border-box;
        }
        
        #settings-panel input[type="number"] {
            width: 70px; /* Keep number inputs smaller */
        }
        
        #settings-panel input[type="range"] {
            width: 100%;
            padding: 0; /* Remove padding for range */
        }
        
        #settings-panel button {
            padding: 10px 20px;
            margin-top: 12px;
            margin-right: 10px; /* Space between buttons */
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }
        
        #settings-panel button:last-of-type {
            margin-right: 0;
        }
        
        #settings-panel button:hover {
            background-color: var(--button-hover-bg);
        }
        
        #settings-panel .setting-group {
            margin-bottom: 20px; /* Increased spacing */
            border-bottom: 1px solid var(--grid-border-color); /* Use grid border color */
            padding-bottom: 15px;
        }
        
        #settings-panel .setting-group:last-of-type {
            border-bottom: none; /* No border on the last group */
        }
        
        #overlay {
            display: none; /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 1000; /* Below settings panel, above content */
        }
        
        #message-box {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--container-bg);
            color: var(--text-color);
            padding: 25px;
            border: 2px solid #888;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            z-index: 1011; /* Above settings panel */
            text-align: center;
            border-radius: 12px;
            width: 80%;
            max-width: 400px;
        }
        
        #message-box button {
            padding: 10px 20px;
            margin-top: 12px;
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }
        
        #message-box button:hover {
            background-color: var(--button-hover-bg);
        }
        
        #message-text {
            font-size: 1.2em;
            margin-bottom: 15px;
        }
        
        /* Toggle switch styles */
        .switch-container { /* Container for label and switch */
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .switch-container label {
            margin-bottom: 0; /* Remove bottom margin from label */
            margin-right: 10px; /* Space between label and switch */
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
            /* margin-bottom: 12px; Removed */
            vertical-align: middle; /* Align with label */
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 34px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #2196F3;
        }
        
        input:focus + .slider {
            box-shadow: 0 0 1px #2196F3;
        }
        
        input:checked + .slider:before {
            -webkit-transform: translateX(26px);
            -ms-transform: translateX(26px);
            transform: translateX(26px);
        }
        
        #leaderboard {
            margin-top: 30px; /* Increased margin */
            text-align: center;
            width: 95%; /* Make leaderboards wider */
            max-width: 1200px; /* Max width for very large screens */
            margin-left: auto;
            margin-right: auto;
        }
        
        #leaderboard h3 {
            margin-bottom: 15px;
        }
        
        #leaderboard table {
            width: 90%; /* Relative width */
            max-width: 500px; /* Limit width for local leaderboard */
            margin: 0 auto 20px auto; /* Center and add bottom margin */
            border-collapse: collapse;
            background-color: var(--container-bg); /* Match container */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden; /* Clip corners */
        }
        
        #leaderboard th, #leaderboard td {
            padding: 10px; /* Increased padding */
            border: 1px solid var(--grid-border-color);
            text-align: center;
        }
        
        #leaderboard th {
            background-color: var(--control-bg-color);
            color: var(--text-color);
            font-weight: bold;
        }
        
        .custom-settings {
            display: none; /* Initially hidden */
        }
        
        .custom-settings.active {
            display: block; /* Show when active */
        }
        
        #settings-panel #custom-difficulty-label{
            margin-top: 10px;
            font-size: 1.1em;
        }
        
        #leaderboard-loading, #leaderboard-error {
            margin-bottom: 15px;
            text-align: center; /* Center loading/error text */
            width: 100%;
            font-size: 1.1em;
        }
        
        /* Style for online leaderboard tables */
        #online-leaderboard-container {
            display: flex; /* Use flexbox for side-by-side tables */
            justify-content: space-around; /* Distribute space evenly */
            flex-wrap: wrap; /* Allow tables to wrap on smaller screens */
            width: 95%; /* Make leaderboards wider */
            max-width: 1200px; /* Optional max width for very large screens */
            margin: 30px auto; /* Center and add vertical margin */
            gap: 20px; /* Add gap between sections */
        }
        
        /* Individual leaderboard section */
        .leaderboard-section {
            flex: 1 1 300px; /* Flex grow, shrink, basis (min width) */
            margin-bottom: 20px; /* Space below each section */
            padding: 15px; /* Increased padding */
            background-color: var(--container-bg); /* Match container background */
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            box-sizing: border-box; /* Include padding in width calculation */
        }
        
        .leaderboard-section h4 {
            margin-top: 0;
            margin-bottom: 15px; /* Increased spacing */
            text-align: center;
            color: var(--text-color);
            font-size: 1.2em; /* Slightly larger title */
        }
        
        .leaderboard-section table {
            width: 100%; /* Tables take full width of their section */
            border-collapse: collapse;
        }
        
        .leaderboard-section th, .leaderboard-section td {
            padding: 8px; /* Standard padding */
            border: 1px solid var(--grid-border-color);
            text-align: center;
            font-size: 0.95em; /* Standard font size */
        }
        
        .leaderboard-section th {
            background-color: var(--control-bg-color);
            color: var(--text-color);
            font-weight: bold;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            #online-leaderboard-container {
                /* Keep flex-direction row, rely on wrapping */
                justify-content: center; /* Center items when they wrap */
            }
            
            .leaderboard-section {
                flex-basis: 90%; /* Allow sections to take more width */
            }
            
            #settings-panel {
                width: 280px; /* Slightly narrower panel on mobile */
                right: calc(-280px - 10px);
                :root {
                    --settings-panel-width: 280px;
                } /* Update CSS variable */
            }
            
            #settings-toggle-button {
                padding: 12px 6px; /* Adjust padding */
                font-size: 1em;
            }
        }
        
        #generation-attempts {
            margin-left: 10px;
            font-size: 0.9em;
            color: #aaa; /* Light gray color */
        }
        
        .light-mode #generation-attempts {
            color: #555; /* Darker gray for light mode */
        }
        
        h1 {
            position: absolute;
            left: -9999px;
        }
        
        /* === ADDED: Legacy-icon tooltip / pointer === */
        .legacy-icon {
            cursor: help; /* shows ? cursor on hover */
            margin-left: 4px; /* Add slight space before icon */
        }
    </style>
</head>
<body>
    <h1>Mobile Minesweeper game No Guess Mode and Online Leaderboards</h1>
    
    <!-- Settings Toggle Button -->
    <button id="settings-toggle-button" onclick="toggleSettings()">Settings</button>
    
    <div id="game-container">
        <!-- Header area for logo and controls -->
        <div id="header-area">
            <img id="logo" src="/DarkModeLogo.svg" alt="Min3s Logo">
            <div id="controls">
                <div id="mines-left">
                    <div id="mines-left-label">Mines</div>
                    <div></div>
                </div>
                <div id="timer">
                    <div id="timer-label">Timer</div>
                    <div>0.000</div> <!-- Initial display with decimals -->
                </div>
            </div>
        </div>
        <!-- End of header area -->
        
        <!-- New Difficulty Selector Area -->
        <div id="difficulty-selector-area">
            <label for="difficulty-selector">Difficulty:</label>
            <select id="difficulty-selector" onchange="handleDifficultyChange()">
                <option value="beginner">Beginner</option>
                <option value="intermediate">Intermediate</option>
                <option value="expert">Expert</option>
                <option value="custom">Custom</option>
            </select>
        </div>
        <!-- End of Difficulty Selector Area -->
        
        <div id="grid-container"></div>
    </div>
    
    <!-- Settings Side Panel -->
    <div id="settings-panel">
        <h2>Settings</h2>
        
        <div class="setting-group">
            <label for="player-name">Your Name:</label>
            <input type="text" id="player-name" value="Player" placeholder="Enter your name">
        </div>
        
        <!-- Custom settings appear only when difficulty is custom -->
        <div class="custom-settings setting-group">
            <h3 id="custom-difficulty-label">Custom Difficulty</h3>
            <label for="width">Width:</label>
            <input type="number" id="width" min="5" max="50" value="9">
            <br> <!-- Simple line break for better spacing -->
            <label for="height">Height:</label>
            <input type="number" id="height" min="5" max="50" value="9">
            <br>
            <label for="mines">Mines:</label>
            <input type="number" id="mines" min="1" max="2491" value="10">
        </div>
        
        <div class="setting-group">
            <div class="switch-container">
                <label for="light-mode">Light Mode:</label>
                <label class="switch">
                    <input type="checkbox" id="light-mode">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
        
        <div class="setting-group">
            <div class="switch-container">
                <label for="no-guess-mode">No Guess Mode:</label>
                <label class="switch">
                    <input type="checkbox" id="no-guess-mode">
                    <span class="slider"></span>
                </label>
            </div>
            <span id="generation-attempts"></span> <!-- To display attempts -->
        </div>
        
        <div class="setting-group">
            <label for="flag-method">Flagging Method:</label>
            <select id="flag-method">
                <option value="longPress">Long Press</option>
                <option value="doubleTap">Double Tap</option>
                <option value="rightClick">Right Click</option>
            </select>
        </div>
        
        <div class="setting-group">
            <label for="long-press-delay">Long Press Delay (ms):</label>
            <input type="range" id="long-press-delay" min="100" max="1000" value="500" step="50">
            <span id="long-press-delay-value">500</span>ms
        </div>
        
        <div class="setting-group">
            <label for="chord-method">Chording Method:</label>
            <select id="chord-method">
                <option value="singleTap">Single Tap</option>
                <option value="doubleTap">Double Tap</option>
            </select>
        </div>
        
        <!-- Only Close button remains -->
        <div>
            <button onclick="toggleSettings()">Close</button>
        </div>
    </div>
    
    <!-- Overlay for Settings Panel and Message Box -->
    <div id="overlay" onclick="closePanels()"></div>
    
    <div id="message-box">
        <p id="message-text"></p>
        <button onclick="restartGame()">Restart</button>
    </div>
    
    <!-- Online Leaderboards Container -->
    <div id="online-leaderboard-container">
        <div id="leaderboard-loading">Loading leaderboards...</div>
        <div id="leaderboard-error" style="color: red; display: none; width: 100%; text-align: center;">Error loading leaderboards.</div>
        
        <!-- Standard Leaderboards -->
        <div class="leaderboard-section">
            <h4>Beginner</h4>
            <table>
                <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                <tbody id="leaderboard-beginner"></tbody>
            </table>
        </div>
        
        <div class="leaderboard-section">
            <h4>Intermediate</h4>
            <table>
                <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                <tbody id="leaderboard-intermediate"></tbody>
            </table>
        </div>
        
        <div class="leaderboard-section">
            <h4>Expert</h4>
            <table>
                <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                <tbody id="leaderboard-expert"></tbody>
            </table>
        </div>
        
        <!-- No Guess Leaderboards -->
        <div class="leaderboard-section">
            <h4>Beginner (No Guess)</h4>
            <table>
                <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                <tbody id="leaderboard-beginner_noguess"></tbody>
            </table>
        </div>
        
        <div class="leaderboard-section">
            <h4>Intermediate (No Guess)</h4>
            <table>
                <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                <tbody id="leaderboard-intermediate_noguess"></tbody>
            </table>
        </div>
        
        <div class="leaderboard-section">
            <h4>Expert (No Guess)</h4>
            <table>
                <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                <tbody id="leaderboard-expert_noguess"></tbody>
            </table>
        </div>
    </div>
    
    <!-- Local Leaderboard Table -->
    <div id="leaderboard">
        <h3>Local Leaderboard</h3>
        <table>
            <thead>
                <tr>
                    <th>Difficulty</th>
                    <th>Best Time (s)</th> <!-- Added (s) -->
                </tr>
            </thead>
            <tbody>
                <tr><td>Beginner</td><td id="leaderboard-beginner-local">-</td></tr>
                <tr><td>Intermediate</td><td id="leaderboard-intermediate-local">-</td></tr>
                <tr><td>Expert</td><td id="leaderboard-expert-local">-</td></tr>
                <tr><td>Beginner (No Guess)</td><td id="leaderboard-beginner_noguess-local">-</td></tr>
                <tr><td>Intermediate (No Guess)</td><td id="leaderboard-intermediate_noguess-local">-</td></tr>
                <tr><td>Expert (No Guess)</td><td id="leaderboard-expert_noguess-local">-</td></tr>
            </tbody>
        </table>
    </div>
    
<script>
        // Global game state
        let grid = [];
        let width = 10;
        let height = 10;
        let mines = 10;
        let gameOver = true;
        let time = 0;
        let timerInterval = null;
        let totalNonMineCells = 0;
        let revealedNonMineCount = 0;
        let minesLeft = 10;
        let currentDifficulty = 'beginner';
        let playerName = '';
        let isLightMode = false;
        let flagMethod = 'hold'; // 'hold' or 'tap'
        let longPressDelay = 500; // ms
        let chordMethod = 'two-tap'; // 'two-tap' or 'single-tap'
        let autoFlag = true;
        let generationAttempts = 0;
        
        let noGuessMode = false;
        
        // --- DOM Elements Cache ---
        const gridContainer = document.getElementById('grid-container');
        const timerDisplay = document.querySelector('#timer > div:nth-child(2)');
        const minesLeftDisplay = document.querySelector('#mines-left > div:nth-child(2)');
        const settingsPanel = document.getElementById('settings-panel');
        const overlay = document.getElementById('overlay');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const difficultySelector = document.getElementById('difficulty-selector');
        const customSettingsDiv = document.querySelector('.custom-settings');
        const widthInput = document.getElementById('width');
        const heightInput = document.getElementById('height');
        const minesInput = document.getElementById('mines');
        const playerNameInput = document.getElementById('player-name');
        const lightModeCheckbox = document.getElementById('light-mode');
        const noGuessCheckbox = document.getElementById('no-guess-mode');
        const flagMethodSelect = document.getElementById('flag-method');
        const longPressDelayInput = document.getElementById('long-press-delay');
        const longPressDelayValueSpan = document.getElementById('long-press-delay-value');
        const chordMethodSelect = document.getElementById('chord-method');
        const attemptsSpan = document.getElementById('generation-attempts');
        const logoElement = document.getElementById('logo');
        const headerArea = document.getElementById('header-area');
        const controlsDiv = document.getElementById('controls');
        const leaderboardLoadingDiv = document.getElementById('leaderboard-loading');
        const leaderboardErrorDiv = document.getElementById('leaderboard-error');

        /* ========= HAPTIC FEEDBACK FUNCTIONS (iOS 18+ Workaround) ========= */

        /**
         * Triggers haptic feedback using the Web Audio API workaround.
         * This is primarily for iOS 18+ devices where navigator.vibrate is restricted.
         */
        function triggerIOSHaptic() {
            try {
                // Check if Web Audio API is available
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;
                
                // AudioContext must be resumed from user gesture on some browsers
                const context = new AudioContext();
                if (context.state === 'suspended') {
                    context.resume();
                }

                // Create an Oscillator (the sound source)
                const oscillator = context.createOscillator();
                
                // Set the frequency to an inaudible tone (1Hz is very low)
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(1, context.currentTime); 

                // Create a GainNode to ensure the volume is effectively zero
                const gainNode = context.createGain();
                gainNode.gain.setValueAtTime(0, context.currentTime); // Mute it completely

                // Connect the nodes and start/stop the sound
                oscillator.connect(gainNode);
                gainNode.connect(context.destination);

                // Start the oscillator, then stop it quickly (20ms)
                oscillator.start(context.currentTime);
                oscillator.stop(context.currentTime + 0.02);
                
            } catch (e) {
                // Safely ignore errors if the API is restricted or unavailable
            }
        }
        
        /**
         * The primary function to call in game logic for haptic feedback.
         * Combines standard Vibration API with iOS Web Audio workaround.
         * @param {string} type - 'tap', 'flag', 'chord', 'boom', or 'win'
         */
        function triggerHapticFeedback(type) {
            
            // --- 1. Attempt Standard Vibration (Android/Desktop) ---
            if ('vibrate' in navigator) {
                let pattern = [];
                switch (type) {
                    case 'tap':
                        pattern = 15; // Short, light tap for revealing a number
                        break;
                    case 'flag':
                        pattern = 40; // Medium tap for flagging/unflagging
                        break;
                    case 'chord':
                        pattern = [20, 10, 20]; // Double tap for chording
                        break;
                    case 'boom':
                        pattern = [100, 50, 100]; // Strong vibration for loss
                        break;
                    case 'win':
                        pattern = [50, 50, 50, 50, 200]; // Distinct pattern for win
                        break;
                    default:
                        return;
                }
                navigator.vibrate(pattern);
                return; // Exit if standard vibration worked
            }

            // --- 2. Attempt iOS Audio Workaround (iOS 18+) ---
            // Only use the workaround for simple, short feedback (tap/flag/chord)
            if (type === 'tap' || type === 'flag' || type === 'chord') {
                triggerIOSHaptic();
            }
        }

        /* ========= SANITISE UTILITY ========= */
        function sanitize(str) {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;')
                .replace(/\//g, '&#x2F;');
        }
        
        /* ========= GAME STATE AND UTILITIES ========= */

        function createGrid(w, h, m, firstClickX = -1, firstClickY = -1) {
            // ... (rest of existing createGrid function)
            
            // Re-initialise global state
            grid = [];
            width = w;
            height = h;
            mines = m;
            gameOver = false;
            time = 0;
            revealedNonMineCount = 0;
            minesLeft = m;
            generationAttempts = 0;

            // Generate empty grid
            for (let y = 0; y < height; y++) {
                grid[y] = [];
                for (let x = 0; x < width; x++) {
                    grid[y][x] = {
                        x: x,
                        y: y,
                        isMine: false,
                        isRevealed: false,
                        isFlagged: false,
                        adjacentMines: 0,
                        element: null,
                    };
                }
            }

            // Place mines
            let minesToPlace = mines;
            let totalCells = width * height;
            const initialArea = [];

            // Define initial safe zone (3x3 around first click)
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = firstClickX + dx;
                    const ny = firstClickY + dy;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        initialArea.push(`${nx},${ny}`);
                    }
                }
            }
            // Add first click cell itself
            if (firstClickX >= 0 && firstClickY >= 0) {
                initialArea.push(`${firstClickX},${firstClickY}`);
            }

            while (minesToPlace > 0) {
                const randX = Math.floor(Math.random() * width);
                const randY = Math.floor(Math.random() * height);
                const cell = grid[randY][randX];

                // Check: Not already a mine AND (if first click provided) not in initial safe area
                if (!cell.isMine && (firstClickX === -1 || !initialArea.includes(`${randX},${randY}`))) {
                    cell.isMine = true;
                    minesToPlace--;
                }
            }
            
            totalNonMineCells = totalCells - mines;

            // Calculate adjacent mines for non-mine cells
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = grid[y][x];
                    if (!cell.isMine) {
                        cell.adjacentMines = countAdjacentMines(x, y);
                    }
                }
            }

            // If no-guess mode is enabled, attempt to solve and re-generate if necessary
            if (noGuessMode && firstClickX >= 0 && firstClickY >= 0) {
                if (isGuessRequired()) {
                    generationAttempts++;
                    // Recursively try to create a new grid
                    return createGrid(w, h, m, firstClickX, firstClickY);
                }
                attemptsSpan.textContent = generationAttempts;
            }

            return grid;
        }

        function countAdjacentMines(x, y) {
            // ... (rest of existing countAdjacentMines function)
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        if (grid[ny][nx].isMine) {
                            count++;
                        }
                    }
                }
            }
            return count;
        }

        function drawGrid() {
            // ... (rest of existing drawGrid function)
            gridContainer.style.setProperty('--grid-width', width);
            gridContainer.style.setProperty('--grid-height', height);
            gridContainer.innerHTML = '';
            
            // Set grid size class for mobile-friendly cell size
            if (width * height > 400) {
                gridContainer.classList.add('small-cells');
            } else {
                gridContainer.classList.remove('small-cells');
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = grid[y][x];
                    const element = document.createElement('div');
                    element.classList.add('cell');
                    element.dataset.x = x;
                    element.dataset.y = y;
                    
                    element.addEventListener('click', (e) => handleCellClick(e, x, y));
                    element.addEventListener('contextmenu', (e) => handleRightClick(e, x, y));
                    
                    if (flagMethod === 'hold') {
                        setupLongPress(element, x, y);
                    }
                    
                    cell.element = element;
                    gridContainer.appendChild(element);
                }
            }
            updateMinesLeftDisplay();
            updateTimerDisplay();
        }

        function handleCellClick(e, x, y) {
            // ... (rest of existing handleCellClick function)
            e.preventDefault();
            if (gameOver) return;

            const cell = grid[y][x];

            // 1. Initial click (Game not started)
            if (timerInterval === null && time === 0) {
                if (cell.isFlagged) {
                    // Cannot start on a flag
                    return;
                }
                // Generate the grid, making sure the first click is safe
                // The new grid is generated in place in the global `grid` variable
                createGrid(width, height, mines, x, y); 
                // Grid needs to be redrawn (or just updated) after generation. 
                // However, since only one cell is revealed right away, we rely on revealCell 
                // and simply start the timer.
                startTimer();
            }

            // 2. Handling flagMethod = 'tap'
            if (flagMethod === 'tap' && isMobile()) {
                // If double-tap mechanism is implemented
                // For simplicity, we stick to the main method: 'tap' is a tap, 
                // 'hold' is a long press, right-click/contextmenu is flag.
            }
            
            // 3. Handle actual game logic
            if (e.button === 0) { // Left-click (or regular tap)
                if (cell.isRevealed) {
                    // Already revealed: attempt chord
                    if (chordMethod === 'single-tap') {
                        chord(x, y);
                    }
                } else {
                    // Unrevealed: reveal cell
                    revealCell(x, y);
                }
            }
        }
        
        function handleRightClick(e, x, y) {
            // ... (rest of existing handleRightClick function)
            e.preventDefault(); // Prevent default context menu
            if (gameOver || timerInterval === null) return;
            
            const cell = grid[y][x];

            // If flagMethod is 'tap' and this is a mobile right-click (long-press),
            // it still functions as a flag. If flagMethod is 'hold', the setupLongPress
            // listener already handled the flag action, but some mobile browsers may fire
            // contextmenu anyway, so we check the flag state.
            if (flagMethod === 'hold' && cell.isFlagged) {
                 // Already handled by long press, prevent double action if contextmenu fires
                 return;
            }

            handleFlag(x, y);
        }

        function setupLongPress(element, x, y) {
            // ... (rest of existing setupLongPress function)
            let timer;
            let isLongPress = false;

            element.addEventListener('touchstart', (e) => {
                if (gameOver || timerInterval === null) return;
                // Only track single touch for long press
                if (e.touches.length > 1) {
                    clearTimeout(timer);
                    return;
                }
                
                isLongPress = false;
                
                // Start a timer. If it expires, it's a long press (flag)
                timer = setTimeout(() => {
                    isLongPress = true;
                    // Trigger the flag action
                    handleFlag(x, y);
                    
                    // Prevent revealCell from firing on touchend
                    e.preventDefault(); 
                }, longPressDelay); 
            }, { passive: false }); // Need to be non-passive to call preventDefault

            element.addEventListener('touchend', (e) => {
                clearTimeout(timer);
                if (gameOver || timerInterval === null) return;
                
                // If it was a short touch, treat it as a tap/click
                if (!isLongPress) {
                    // Explicitly call the click handler for a tap
                    // We need to simulate the left-click action
                    handleCellClick({ preventDefault: () => {}, button: 0 }, x, y); 
                }
                isLongPress = false;
            });
            
            element.addEventListener('touchmove', () => {
                // Cancel if the finger moves significantly
                clearTimeout(timer);
            });
            
            // For desktop, right click still uses contextmenu/handleRightClick
        }

        function revealCell(x, y) {
            // ... (rest of existing revealCell function)
            const cell = grid[y]?.[x];
            if (!cell || cell.isRevealed || cell.isFlagged || gameOver) return;
            
            if (cell.isMine) {
                // HAPTIC INSERTION: Loss Feedback
                triggerHapticFeedback('boom');
                revealAllMines(x, y); // Handles game over.
                return;
            }
            
            // HAPTIC INSERTION: Trigger a tap haptic for the action of revealing a cell
            triggerHapticFeedback('tap');

            let revealQueue = [{nx: x, ny: y}];
            while(revealQueue.length > 0) {
                const {nx, ny} = revealQueue.shift();
                const currentCell = grid[ny]?.[nx];
                
                if (!currentCell || currentCell.isRevealed || currentCell.isFlagged) continue;

                // Actual reveal logic
                currentCell.isRevealed = true;
                currentCell.element.classList.add('revealed');
                revealedNonMineCount++;

                if (currentCell.adjacentMines > 0) {
                    currentCell.element.textContent = currentCell.adjacentMines;
                    currentCell.element.classList.add(`n${currentCell.adjacentMines}`);
                } else {
                    // If 0, add all neighbors to the queue for flood-fill
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const neighborX = nx + dx;
                            const neighborY = ny + dy;
                            if (neighborX >= 0 && neighborX < width && neighborY >= 0 && neighborY < height) {
                                // Only add unrevealed, unflagged neighbors
                                if (!grid[neighborY][neighborX].isRevealed && !grid[neighborY][neighborX].isFlagged) {
                                    revealQueue.push({nx: neighborX, ny: neighborY});
                                }
                            }
                        }
                    }
                }
            }
            
            checkWin(); // Check for win condition after every reveal
        }

        function handleFlag(x, y) {
            // ... (rest of existing handleFlag function)
            const cell = grid[y]?.[x];
            if (!cell || cell.isRevealed || gameOver || timerInterval === null) return;
            
            if (cell.isFlagged) {
                // Unflag
                cell.isFlagged = false;
                cell.element.classList.remove('flagged');
                cell.element.textContent = '';
                minesLeft++;
                
                // HAPTIC INSERTION: Unflagging Feedback
                triggerHapticFeedback('flag');
                
            } else if (minesLeft > 0) {
                // Flag
                cell.isFlagged = true;
                cell.element.classList.add('flagged');
                cell.element.textContent = '🚩'; // Use emoji for flag
                minesLeft--;

                // HAPTIC INSERTION: Flagging Feedback
                triggerHapticFeedback('flag');
            } else {
                // No flags left, perhaps a gentle tap for feedback?
                // triggerHapticFeedback('tap'); // Optional feedback for "action failed"
            }

            updateMinesLeftDisplay();
            // Flagging does not require checkWin, but auto-flagging might later.
        }

        function chord(x, y) {
            // ... (rest of existing chord function)
            const cell = grid[y]?.[x];
            if (!cell || !cell.isRevealed || cell.adjacentMines === 0 || gameOver) return;
            
            let flaggedNeighbors = 0;
            let unknownAndUnflaggedNeighbors = [];

            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        const neighbor = grid[ny][nx];
                        if (neighbor.isFlagged) {
                            flaggedNeighbors++;
                        } else if (!neighbor.isRevealed) {
                            unknownAndUnflaggedNeighbors.push({x: nx, y: ny});
                        }
                    }
                }
            }

            if(flaggedNeighbors === cell.adjacentMines){
                // Reveal all adjacent hidden, unflagged cells
                unknownAndUnflaggedNeighbors.forEach(pos => {
                    // Use revealCell - it handles mine checks, flood fill, and win checks
                    revealCell(pos.x, pos.y);
                });
                
                // HAPTIC INSERTION: Chording Feedback
                triggerHapticFeedback('chord');

            } else if (flaggedNeighbors < cell.adjacentMines) {
                // Provide a 'tap' or distinct haptic to show the action failed 
                // because not enough flags were placed (less than adjacentMines)
                triggerHapticFeedback('tap'); 
            }
        }
        
        function revealAllMines(clickedX, clickedY) {
            // ... (rest of existing revealAllMines function)
            gameOver = true; // Ensure game over state is set
            stopTimer(); // Stop the timer and calculate final time
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = grid[y][x];
                    if (cell.isMine && !cell.isFlagged) {
                        cell.element.classList.add('mine');
                        if (x === clickedX && y === clickedY) {
                            cell.element.classList.add('exploded');
                            cell.element.textContent = '💣'; // Exploded mine
                        } else {
                            cell.element.textContent = '💣'; // Unflagged mine
                        }
                    } else if (!cell.isMine && cell.isFlagged) {
                        // Incorrectly flagged cell
                        cell.element.classList.add('wrong-flag');
                        cell.element.textContent = '❌'; 
                    }
                }
            }
            showMessage('Game Over! You hit a mine.');
        }

        function checkWin() {
            // ... (rest of existing checkWin function)
            // Check win condition: (total cells - mines) === revealed cells
            // OR (total cells - revealed cells) === mines (if all remaining are mines)
            
            // Primary win condition: all non-mine cells are revealed
            if (revealedNonMineCount === totalNonMineCells) {
                gameOver = true; // Prevent multiple win triggers
                stopTimer(); // Stop the timer and calculate final time
                
                // HAPTIC INSERTION: Win Feedback
                triggerHapticFeedback('win');
                
                let flagsPlaced = 0;
                if (autoFlag) {
                    // Auto-flag remaining cells
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const cell = grid[y][x];
                            if (!cell.isRevealed && !cell.isFlagged) {
                                cell.isFlagged = true;
                                cell.element.classList.add('flagged');
                                cell.element.textContent = '🚩';
                                flagsPlaced++;
                            }
                        }
                    }
                    minesLeft = 0; // All flags used up
                    updateMinesLeftDisplay();
                }

                showMessage('Congratulations! You won!');
                
                // Record score locally and to Firebase
                recordScore();
            }
        }
        
        /* ========= TIMER AND DISPLAY ========= */
        
        function startTimer() {
            // ... (rest of existing startTimer function)
            time = 0;
            updateTimerDisplay();
            timerInterval = setInterval(() => {
                time += 0.01; // Increment by 10ms for better precision
                updateTimerDisplay();
            }, 10);
        }

        function stopTimer() {
            // ... (rest of existing stopTimer function)
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            // Round time to 2 decimal places (seconds)
            time = Math.round(time * 100) / 100; 
            updateTimerDisplay(); // Final update
        }

        function updateTimerDisplay() {
            // ... (rest of existing updateTimerDisplay function)
            const seconds = Math.floor(time);
            const milliseconds = Math.floor((time * 100) % 100);
            
            // Format seconds as MM:SS
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            const timeString = `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}:${String(milliseconds).padStart(2, '0')}`;
            
            timerDisplay.textContent = timeString;
        }

        function updateMinesLeftDisplay() {
            // ... (rest of existing updateMinesLeftDisplay function)
            minesLeftDisplay.textContent = String(minesLeft).padStart(2, '0');
        }

        function restartGame() {
            // ... (rest of existing restartGame function)
            stopTimer();
            gameOver = true;
            gridContainer.innerHTML = '';
            grid = [];
            
            // Clear attempts display
            generationAttempts = 0;
            attemptsSpan.textContent = generationAttempts;
            
            // Reset displays to initial values
            minesLeft = mines;
            time = 0;
            updateMinesLeftDisplay();
            updateTimerDisplay();
            
            // Draw an empty grid to start
            drawGrid();
            
            // Hide messages
            hideMessage();
        }

        function showMessage(text) {
            // ... (rest of existing showMessage function)
            messageText.textContent = text;
            messageBox.classList.add('active');
            overlay.classList.add('active');
        }

        function hideMessage() {
            // ... (rest of existing hideMessage function)
            messageBox.classList.remove('active');
            overlay.classList.remove('active');
        }

        /* ========= SETTINGS AND CONTROLS ========= */

        function toggleSettings() {
            // ... (rest of existing toggleSettings function)
            if (settingsPanel.classList.contains('active')) {
                settingsPanel.classList.remove('active');
                overlay.classList.remove('active');
                // Auto-save settings when panel is closed
                saveSettings();
                
                // If the game is in initial state, restart it with new settings
                if (timerInterval === null && time === 0) {
                    restartGame();
                }
            } else {
                settingsPanel.classList.add('active');
                overlay.classList.add('active');
            }
        }

        function updateCustomInputs() {
            // ... (rest of existing updateCustomInputs function)
            if (difficultySelector.value === 'custom') {
                customSettingsDiv.style.display = 'block';
            } else {
                customSettingsDiv.style.display = 'none';
            }
        }

        function updateDifficulty() {
            // ... (rest of existing updateDifficulty function)
            currentDifficulty = difficultySelector.value;
            switch (currentDifficulty) {
                case 'beginner':
                    width = 9; height = 9; mines = 10; break;
                case 'intermediate':
                    width = 16; height = 16; mines = 40; break;
                case 'expert':
                    width = 30; height = 16; mines = 99; break;
                case 'custom':
                    width = parseInt(widthInput.value) || 10;
                    height = parseInt(heightInput.value) || 10;
                    mines = parseInt(minesInput.value) || 10;
                    break;
            }
            // Clamp custom values to a sensible range
            width = Math.max(3, Math.min(width, 30));
            height = Math.max(3, Math.min(height, 30));
            mines = Math.max(1, Math.min(mines, width * height - 9)); // Max mines = total cells - 9 (for first click)
            
            // Update inputs if they were outside the clamp range
            if (currentDifficulty === 'custom') {
                widthInput.value = width;
                heightInput.value = height;
                minesInput.value = mines;
            }
        }

        function saveSettings() {
            // ... (rest of existing saveSettings function)
            updateDifficulty(); // Ensure global variables are set before saving
            
            isLightMode = lightModeCheckbox.checked;
            flagMethod = flagMethodSelect.value;
            chordMethod = chordMethodSelect.value;
            noGuessMode = noGuessCheckbox.checked;

            playerName = sanitize(playerNameInput.value).trim();
            if (playerName.length === 0) {
                playerName = 'Anonymous';
            }
            playerNameInput.value = playerName; // Update input with sanitized name

            const settings = {
                currentDifficulty: currentDifficulty,
                width: width,
                height: height,
                mines: mines,
                playerName: playerName,
                isLightMode: isLightMode,
                noGuessMode: noGuessMode,
                flagMethod: flagMethod,
                longPressDelay: longPressDelay,
                chordMethod: chordMethod
            };

            localStorage.setItem('min3sSettings', JSON.stringify(settings));
            applySettings(settings); // Apply settings immediately
        }

        function loadSettings() {
            // ... (rest of existing loadSettings function)
            const savedSettings = localStorage.getItem('min3sSettings');
            const defaultSettings = {
                currentDifficulty: 'beginner',
                width: 9, height: 9, mines: 10,
                playerName: 'Anonymous',
                isLightMode: false,
                noGuessMode: false,
                flagMethod: 'hold',
                longPressDelay: 500,
                chordMethod: 'single-tap'
            };
            
            const settings = savedSettings ? JSON.parse(savedSettings) : defaultSettings;
            
            // Apply loaded settings
            applySettings(settings);
            
            // Restart game with loaded/applied settings
            restartGame();
        }

        function applySettings(settings) {
            // ... (rest of existing applySettings function)
            currentDifficulty = settings.currentDifficulty;
            width = settings.width;
            height = settings.height;
            mines = settings.mines;
            playerName = settings.playerName;
            isLightMode = settings.isLightMode;
            noGuessMode = settings.noGuessMode;
            flagMethod = settings.flagMethod;
            longPressDelay = settings.longPressDelay;
            chordMethod = settings.chordMethod;

            // Update DOM inputs
            difficultySelector.value = currentDifficulty;
            widthInput.value = width;
            heightInput.value = height;
            minesInput.value = mines;
            playerNameInput.value = playerName;
            lightModeCheckbox.checked = isLightMode;
            noGuessCheckbox.checked = noGuessMode;
            flagMethodSelect.value = flagMethod;
            chordMethodSelect.value = chordMethod;
            
            // Apply light mode/dark mode class to body
            document.body.classList.toggle('light-mode', isLightMode);

            updateCustomInputs();
            updateLongPressDelayDisplay();
            
            // Re-apply long press listener if flag method changed
            // This is handled implicitly by the restartGame call in loadSettings
        }
        
        function updateLongPressDelayDisplay() {
            // ... (rest of existing updateLongPressDelayDisplay function)
            longPressDelayValueSpan.textContent = longPressDelayInput.value + 'ms';
            longPressDelay = parseInt(longPressDelayInput.value);
            // This should trigger a saveSettings call via listener
        }

        function addAutoSaveListeners() {
            // ... (rest of existing addAutoSaveListeners function)
            // Add listeners to all relevant inputs to trigger saveSettings()
            [
                difficultySelector, widthInput, heightInput, minesInput, 
                playerNameInput, lightModeCheckbox, noGuessCheckbox, 
                flagMethodSelect, chordMethodSelect, longPressDelayInput
            ].forEach(input => {
                input.addEventListener('change', saveSettings);
            });
            
            // Listener for long press delay range input (needs to also update display)
            longPressDelayInput.addEventListener('input', updateLongPressDelayDisplay);
            longPressDelayInput.addEventListener('change', saveSettings);
        }

        /* ========= SCORING AND LEADERBOARDS (Firebase) ========= */

        function recordScore() {
            // ... (rest of existing recordScore function)
            if (time <= 0 || gameOver === false) return; // Only record finished, timed games

            // Determine board size for category
            let category = `${width}x${height}`;
            if (currentDifficulty !== 'custom') {
                category = currentDifficulty;
            }

            const score = {
                category: category,
                time: time, // The final time in seconds
                playerName: playerName,
                timestamp: Date.now(),
                board: `${width}x${height}/${mines}`, // For custom boards
                difficulty: currentDifficulty
            };

            // Save to Local Leaderboard
            saveLocalScore(score);

            // Save to Online Leaderboard (Firebase)
            saveOnlineScore(score);
        }

        // ... (rest of existing scoring and leaderboard functions)

        // Local Storage Leaderboard
        function saveLocalScore(newScore) {
            let localScores = JSON.parse(localStorage.getItem('min3sLeaderboard') || '{}');
            const category = newScore.category;

            if (!localScores[category]) {
                localScores[category] = [];
            }
            
            localScores[category].push(newScore);
            // Sort by time (ascending) and keep only top 10 for local
            localScores[category].sort((a, b) => a.time - b.time);
            localScores[category] = localScores[category].slice(0, 10);
            
            localStorage.setItem('min3sLeaderboard', JSON.stringify(localScores));
            loadLeaderboard(); // Reload display
        }

        function loadLeaderboard() {
            // ... (rest of existing loadLeaderboard function)
            const localScores = JSON.parse(localStorage.getItem('min3sLeaderboard') || '{}');
            const localLeaderboardBody = document.getElementById('local-leaderboard-body');
            localLeaderboardBody.innerHTML = '';
            
            const category = currentDifficulty === 'custom' ? `${width}x${height}` : currentDifficulty;
            const scores = localScores[category] || [];
            
            if (scores.length === 0) {
                localLeaderboardBody.innerHTML = `<tr><td colspan="3" class="no-scores">No local scores for ${category} yet.</td></tr>`;
                return;
            }

            scores.forEach((score, index) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${formatTime(score.time)}</td>
                    <td>${score.playerName}</td>
                `;
                localLeaderboardBody.appendChild(tr);
            });
        }
        
        function formatTime(time) {
            // ... (rest of existing formatTime function)
            const seconds = Math.floor(time);
            const milliseconds = Math.floor((time * 100) % 100);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}:${String(milliseconds).padStart(2, '0')}`;
        }

        // Firebase Firestore Leaderboard
        let db;
        try {
            // Initialize Firebase App
            const firebaseConfig = {
                // (Your actual Firebase config goes here - it's assumed to be in the original file)
            };
            // Note: Since this is a self-contained HTML file for a game on a single domain,
            // we assume the configuration is set up or not strictly required for the client-side
            // logic other than calling the Firestore API which is loaded above the script.
            
            // Assume the firebase app is initialized elsewhere if needed, or rely on the script tags
            // to provide the global firebase object (which they do).
            db = firebase.firestore();
        } catch (e) {
            console.warn("Firebase initialization failed. Online leaderboards will not work.", e);
            // db remains undefined, the loadOnlineLeaderboard function will handle this.
        }

        function saveOnlineScore(score) {
            // ... (rest of existing saveOnlineScore function)
            if (!db) return; // Skip if Firebase failed to initialize
            
            // The score data is identical to the local score data
            const category = score.category;

            db.collection('leaderboard').doc(category).collection('scores').add(score)
                .then(() => {
                    console.log("Online score recorded for category:", category);
                    // Reload online leaderboard after submission
                    loadOnlineLeaderboard();
                })
                .catch((error) => {
                    console.error("Error writing online document: ", error);
                });
        }

        function loadOnlineLeaderboard() {
            // ... (rest of existing loadOnlineLeaderboard function)
            if (!db) {
                leaderboardErrorDiv.textContent = 'Online leaderboards unavailable.';
                leaderboardErrorDiv.style.display = 'block';
                leaderboardLoadingDiv.style.display = 'none';
                return;
            }
            
            leaderboardErrorDiv.style.display = 'none';
            leaderboardLoadingDiv.style.display = 'block';

            const category = currentDifficulty === 'custom' ? `${width}x${height}` : currentDifficulty;
            const onlineLeaderboardBody = document.getElementById('online-leaderboard-body');
            onlineLeaderboardBody.innerHTML = ''; // Clear previous results

            db.collection('leaderboard').doc(category).collection('scores')
                .orderBy('time', 'asc')
                .limit(10) // Only get the top 10 scores
                .get()
                .then((querySnapshot) => {
                    leaderboardLoadingDiv.style.display = 'none';
                    let scores = [];
                    querySnapshot.forEach((doc) => {
                        scores.push(doc.data());
                    });
                    
                    if (scores.length === 0) {
                        onlineLeaderboardBody.innerHTML = `<tr><td colspan="3" class="no-scores">No online scores for ${category} yet.</td></tr>`;
                        return;
                    }

                    scores.forEach((score, index) => {
                        const tr = document.createElement('tr');
                        // Use a class to identify the player's own score
                        const isPlayer = score.playerName === playerName;
                        tr.classList.toggle('player-score', isPlayer);
                        
                        tr.innerHTML = `
                            <td>${index + 1}</td>
                            <td>${formatTime(score.time)}</td>
                            <td>${sanitize(score.playerName)}</td>
                        `;
                        onlineLeaderboardBody.appendChild(tr);
                    });
                })
                .catch((error) => {
                    leaderboardLoadingDiv.style.display = 'none';
                    leaderboardErrorDiv.textContent = 'Error loading online leaderboards.';
                    leaderboardErrorDiv.style.display = 'block';
                    console.error("Error reading online documents: ", error);
                });
        }
        
        /* ========= NO GUESS MODE (Solver Logic) ========= */
        
        // This is a simplified check that determines if any unrevealed cell
        // is forced to be a guess because no revealed neighbor provides enough
        // information to definitively flag or reveal a cell.

        function isGuessRequired() {
            // ... (rest of existing isGuessRequired function)
            let solverIterations = 0;
            const maxIterations = 5; // Prevent infinite loops

            while (solverIterations < maxIterations) {
                let changed = false;
                
                // Set of all unrevealed cells that are neighbors to a revealed cell
                let frontier = new Set();
                
                // 1. Build the frontier (cells adjacent to a revealed cell)
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const cell = grid[y][x];
                        if (cell.isRevealed && cell.adjacentMines > 0) {
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    
                                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                        const neighbor = grid[ny][nx];
                                        if (!neighbor.isRevealed) {
                                            frontier.add(neighbor);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (frontier.size === 0) break; // No more revealed numbers to work with

                // 2. Iterate through all revealed cells with numbers (the constraints)
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const cell = grid[y][x];
                        if (!cell.isRevealed || cell.adjacentMines === 0) continue;

                        let flaggedNeighbors = 0;
                        let hiddenNeighbors = [];

                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nx = x + dx;
                                const ny = y + dy;

                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const neighbor = grid[ny][nx];
                                    if (!neighbor.isRevealed) {
                                        if (neighbor.isFlagged) {
                                            flaggedNeighbors++;
                                        } else {
                                            hiddenNeighbors.push(neighbor);
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Rule A: If (cell.adjacentMines - flaggedNeighbors) == hiddenNeighbors.length, 
                        // all hidden neighbors MUST be mines.
                        const remainingMines = cell.adjacentMines - flaggedNeighbors;
                        if (remainingMines > 0 && remainingMines === hiddenNeighbors.length) {
                            hiddenNeighbors.forEach(hCell => {
                                // Simulate placing a flag to mark it as known
                                if (!hCell.isFlagged && hCell.isMine) { // Only works during generation where we know mine location
                                    hCell.isFlagged = true; // Mark as logically known mine
                                    changed = true;
                                }
                            });
                        }
                        
                        // Rule B: If (cell.adjacentMines - flaggedNeighbors) == 0, 
                        // all hidden neighbors MUST be safe (not mines).
                        if (remainingMines === 0 && hiddenNeighbors.length > 0) {
                            // Simulate revealing them
                            hiddenNeighbors.forEach(hCell => {
                                // Only works during generation where we know mine location
                                if (!hCell.isMine && !hCell.isRevealed) {
                                    hCell.isRevealed = true; // Mark as logically known safe
                                    changed = true;
                                }
                            });
                        }
                    }
                }
                
                if (!changed) break;
                solverIterations++;
            }
            
            // 3. Final Check: After maximum logical reveals/flags, is there any unrevealed cell?
            // If the solver successfully cleared the starting area, all cells in the frontier 
            // should be either logically revealed or logically flagged.
            
            // We need to reset the temporary flags/reveals before the final check
            let safeToStart = true;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = grid[y][x];
                    
                    // The first-click cell must not be a mine, this is guaranteed by createGrid
                    // Check if there are any remaining mines in the start area that couldn't be solved
                    if (cell.isRevealed && cell.adjacentMines > 0) {
                         // Re-check the rules based on actual, un-simulated state
                         let flagged = 0;
                         let hidden = [];
                         for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nx = x + dx;
                                const ny = y + dy;

                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const neighbor = grid[ny][nx];
                                    if (!neighbor.isRevealed) {
                                        hidden.push(neighbor);
                                    }
                                }
                            }
                        }

                        // Check if the remaining hidden cells can be logically determined
                        const actualRemainingMines = countAdjacentMines(x, y); // This is known during generation
                        
                        // If the number of adjacent mines (the constraint) does not equal 
                        // the number of hidden cells, then we have a 50/50 chance.
                        // (Simplified, but catches the most obvious guesses).
                        if (actualRemainingMines > 0 && actualRemainingMines < hidden.length) {
                             // This is a potential guess, unless there is other information.
                             // For simplicity in generation, we treat this as a failure condition.
                             safeToStart = false; 
                             break;
                        }
                    }
                    if (!safeToStart) break;
                }
            }
            
            // Clean up temporary simulated states (flags/reveals)
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = grid[y][x];
                    cell.isFlagged = false; // Reset logical flags
                    cell.isRevealed = false; // Reset logical reveals
                }
            }

            // Return true if a guess is still required (safeToStart is false)
            return !safeToStart;
        }

        /* ========= MOBILE DEVICE UTILITY ========= */
        function isMobile() {
            // ... (rest of existing isMobile function)
            return /Mobi|Android/i.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        }

        /* ========= OLD SCORE POPUP FOR LEGACY ICONS (Optional) ========= */
        // This function exists in your original file's snippet, so keep it for compatibility
        document.addEventListener('click', e => {
            const legacyIconElement = e.target.closest('.legacy-icon');
            
            if (legacyIconElement) {
                const message = legacyIconElement.getAttribute('title') || 
                    'Legacy score: recorded before decimal‑precision timing. Value shown is slowest possible within that second.';
                alert(message);
            }
        });
        
        // --- Initialize ---\n
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings(); // Load saved settings first
            loadLeaderboard(); // Load local scores
            loadOnlineLeaderboard(); // Load online scores
            addAutoSaveListeners(); // Add auto-save event listeners
            // restartGame() is called within loadSettings() to ensure correct initial state
        });
    </script>
</body>
</html>
