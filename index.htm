<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minesweeper</title>
    <!-- Firebase App (include only once) -->
    <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-app-compat.js"></script>
    <!-- Firebase Firestore -->
    <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-firestore-compat.js"></script>
    <style>
        /* Base Styles (Dark Mode - Now Default) */
        :root {
            --bg-color: #333;
            --container-bg: #444;
            --grid-border-color: #666;
            --grid-bg-color: #555;
            --cell-bg-color: #666;
            --cell-border-color: #777;
            --revealed-cell-bg: #555;
            --revealed-cell-border: #888;
            --flagged-cell-bg: #4682B4;
            --flagged-cell-color: #FFD700;
            --mine-bg-color: #B22222;
            --mine-revealed-bg: #800000;
            --mine-revealed-color: white;
            --incorrect-flag-bg: #A0522D;
            --incorrect-flag-color: white;
            --text-color: white;
            --button-bg: #3e8e41;
            --button-hover-bg: #2e6e31;
            --button-text-color: white;
            --control-border-color: #aaa;
            --control-bg-color: #444;
            --cell-pressed-bg: #777; /* Added style for pressed cell */
        }

        /* Light Mode Styles */
        .light-mode {
            --bg-color: #e0e0e0;
            --container-bg: white;
            --grid-border-color: #a0a0a0;
            --grid-bg-color: #c0c0c0;
            --cell-bg-color: #d0d0d0;
            --cell-border-color: #f0f0f0;
            --revealed-cell-bg: #f8f8f8;
            --revealed-cell-border: #909090;
            --flagged-cell-bg: #87CEEB;
            --flagged-cell-color: #B22222;
            --mine-bg-color: #F08080;
            --mine-revealed-bg: #DC143C;
            --mine-revealed-color: white;
            --incorrect-flag-bg: #FFD700;
            --incorrect-flag-color: black;
            --text-color: black;
            --button-bg: #4CAF50;
            --button-hover-bg: #3e8e41;
            --button-text-color: white;
            --control-border-color: #808080;
            --control-bg-color: #f0f0f0;
            --cell-pressed-bg: #e8e8e8; /* Added style for pressed cell */
        }


        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation; /* Prevent double-tap zoom */
        }
         #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            overflow: hidden;
            background-color: var(--container-bg);
            padding: 10px;
        }

        #grid-container {
            display: grid;
            grid-gap: 1px;
            border: 3px solid var(--grid-border-color);
            background-color: var(--grid-bg-color);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
             user-select: none;
             -webkit-tap-highlight-color: transparent;
             /* touch-action: manipulation; might also be helpful here */
        }

        .cell {
            width: 28px;
            height: 28px;
            background-color: var(--cell-bg-color);
            border: 2px outset var(--cell-border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            transition: background-color 0.1s; /* Faster transition */
        }
        .cell.pressed { /* Style for when left mouse is down */
            background-color: var(--cell-pressed-bg);
            border-style: inset; /* Give pressed appearance */
        }
        .cell.revealed {
            border: 1px solid var(--revealed-cell-border);
            background-color: var(--revealed-cell-bg);
            cursor: default;
        }
        .cell.flagged {
            background-color: var(--flagged-cell-bg);
            color: var(--flagged-cell-color);
        }
        .cell.mine {
            background-color: var(--mine-bg-color);
        }
        .cell.mine-revealed {
            background-color: var(--mine-revealed-bg);
            color: var(--mine-revealed-color);
        }
        .cell.incorrect-flag {
            background-color: var(--incorrect-flag-bg);
            color: var(--incorrect-flag-color);
        }

        #controls {
            display: flex;
            justify-content: space-around;
            width: 90%;
            margin-bottom: 10px;
            align-items: center;
        }

        #timer, #mines-left {
            font-size: 1.1em;
            font-weight: bold;
            padding: 6px 12px;
            border: 2px solid var(--control-border-color);
            background-color: var(--control-bg-color);
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #timer-label, #mines-left-label {
            font-size: 0.8em;
            color: var(--text-color);
            margin-bottom: 2px;
        }

        #settings {
            margin-top: 20px;
        }

        #settings button {
            padding: 10px 20px;
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }

        #settings button:hover {
            background-color: var(--button-hover-bg);
        }

          #settings-panel {
            display: none;
            position: fixed;
            top: 50%; /* Start at 50% */
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--container-bg);
            color: var(--text-color);
            padding: 25px;
            border: 2px solid #888;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            z-index: 1000;
            width: 90%;
            max-width: 450px;
            border-radius: 12px;
            overflow-y: auto;  /* Enable vertical scrolling */
            max-height: 80vh; /* Limit height to 80% of viewport height */

        }
        #settings-panel label {
            display: block;
            margin-bottom: 6px;
            font-weight: bold;
        }

        #settings-panel input[type="number"],
        #settings-panel input[type="range"],
        #settings-panel input[type="text"] { /* Apply styles to text input too */
            width: 70px;
            margin-bottom: 12px;
            padding: 8px;
            border: 1px solid #bbb;
            border-radius: 5px;
            font-size: 1em;
        }
         #settings-panel input[type="text"]{
             width: calc(100% - 20px); /* Take full width minus padding */
         }

        #settings-panel input[type="range"] {
            width: 100%;
        }

        #settings-panel button {
            padding: 10px 20px;
            margin-top: 12px;
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }

        #settings-panel button:hover {
            background-color: var(--button-hover-bg);;
        }

        #settings-panel .setting-group {
           margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
          #settings-panel .difficulty-buttons {
            display: flex;
            justify-content: space-between; /* Evenly space buttons */
            margin-bottom: 15px;
        }
          #settings-panel .difficulty-buttons button {
            flex: 1; /* Each button takes equal width */
            margin: 0 5px; /* Space between buttons */
        }

        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 999;
        }

        #message-box {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--container-bg);
            color: var(--text-color);
            padding: 25px;
            border: 2px solid #888;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            text-align: center;
            border-radius: 12px;
            width: 80%;
            max-width: 400px;
        }
        #message-box button {
            padding: 10px 20px;
            margin-top: 12px;
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }

        #message-box button:hover {
            background-color: var(--button-hover-bg);
        }

        #message-text {
            font-size: 1.2em;
            margin-bottom: 15px;

        }

        /* Toggle switch styles */
        .switch {
          position: relative;
          display: inline-block;
          width: 60px;
          height: 34px;
          margin-bottom: 12px;
        }

        .switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }

        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ccc;
          -webkit-transition: .4s;
          transition: .4s;
          border-radius: 34px;
        }

        .slider:before {
          position: absolute;
          content: "";
          height: 26px;
          width: 26px;
          left: 4px;
          bottom: 4px;
          background-color: white;
          -webkit-transition: .4s;
          transition: .4s;
          border-radius: 50%;
        }

        input:checked + .slider {
          background-color: #2196F3;
        }

        input:focus + .slider {
          box-shadow: 0 0 1px #2196F3;
        }

        input:checked + .slider:before {
          -webkit-transform: translateX(26px);
          -ms-transform: translateX(26px);
          transform: translateX(26px);
        }
        #settings-panel select{
            margin-bottom: 10px;
            padding: 5px;
        }
        #leaderboard {
            margin-top: 20px;
            text-align: center;
        }

        #leaderboard h3 {
            margin-bottom: 10px;
        }

        #leaderboard table {
            width: 80%;
            margin: 0 auto;
            border-collapse: collapse;
        }

        #leaderboard th, #leaderboard td {
            padding: 8px;
            border: 1px solid var(--control-border-color);
            text-align: center;
        }

        #leaderboard th {
            background-color: var(--control-bg-color);
            color: var(--text-color);
        }
        .custom-settings {
            display: none; /* Initially hidden */
        }

        .custom-settings.active {
            display: block; /* Show when active */
        }
         #settings-panel #custom-difficulty-label{
            margin-top: 10px;
            font-size: 1.1em;
        }
        #leaderboard {
            margin-top: 20px;
            text-align: center;
        }

        #leaderboard h3 {
            margin-bottom: 10px;
        }

        #leaderboard table {
            width: 80%;
            margin: 0 auto;
            border-collapse: collapse;
        }

        #leaderboard th, #leaderboard td {
            padding: 8px;
            border: 1px solid var(--control-border-color);
            text-align: center;
        }

        #leaderboard th {
            background-color: var(--control-bg-color);
            color: var(--text-color);
       }
      #leaderboard-loading {
          margin-bottom: 10px;
      }
       /* Style for online leaderboard tables */
      #online-leaderboard-container {
        display: flex; /* Use flexbox for side-by-side tables */
        justify-content: space-around; /* Distribute space evenly */
        flex-wrap: wrap; /* Allow tables to wrap on smaller screens */
        width: 90%;
        margin: 20px auto;

      }

      #online-leaderboard-container table {
        width: 45%; /* Each table takes roughly half the container width */
        margin-bottom: 20px; /* Space between tables */
        border-collapse: collapse;
         box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
        #online-leaderboard-container th,
        #online-leaderboard-container td {
             padding: 8px;
              border: 1px solid var(--control-border-color);
              text-align: center;
        }
        #online-leaderboard-container th {
             background-color: var(--control-bg-color);
              color: var(--text-color);
               font-weight: bold;
        }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        #online-leaderboard-container {
          flex-direction: column; /* Stack tables vertically on smaller screens */
        }
          #online-leaderboard-container table {
            width: 90%; /* Tables take full width on smaller screens */
             margin: 10px auto;
          }
      }

    </style>
</head>
<body>
    <div id="game-container">
        <div id="controls">
            <div id="mines-left">
                <div id="mines-left-label">Mines</div>
                <div></div>
            </div>
            <div id="timer">
                 <div id="timer-label">Timer</div>
                <div>0</div>
            </div>
        </div>
        <div id="grid-container"></div>
    </div>
    <div id="settings">
        <button onclick="toggleSettings()">Settings</button>
    </div>

      <div id="settings-panel">
        <h2>Settings</h2>
        <div class="setting-group difficulty-buttons">
            <button onclick="setDifficulty('beginner')">Beginner</button>
            <button onclick="setDifficulty('intermediate')">Intermediate</button>
            <button onclick="setDifficulty('expert')">Expert</button>
            <button onclick="setDifficulty('custom')">Custom</button> <!-- Custom Difficulty Button -->
        </div>
        <div class="setting-group">
            <label for="player-name">Your Name:</label>
            <input type="text" id="player-name" value="Player" placeholder="Enter your name">
        </div>

        <div class="custom-settings setting-group">
            <label for="width">Width:</label>
            <input type="number" id="width" min="5" max="30" value="9">
            <label for="height">Height:</label>
            <input type="number" id="height" min="5" max="30" value="9">
            <label for="mines">Mines:</label>
            <input type="number" id="mines" min="1" max="99" value="10">
        </div>
        <div class="setting-group">
            <label for="light-mode">Light Mode:</label>
            <label class="switch">
                <input type="checkbox" id="light-mode">
                <span class="slider"></span>
            </label>
        </div>

        <div class="setting-group">
            <label for="flag-method">Flagging Method:</label>
            <select id="flag-method" onchange="updateFlagMethod()">
              <option value="longPress">Long Press</option>
              <option value="doubleTap">Double Tap</option>
              <option value="rightClick">Right Click</option>
            </select>
        </div>

        <div class="setting-group">
            <label for="long-press-delay">Long Press Delay (ms):</label>
            <input type="range" id="long-press-delay" min="100" max="1000" value="500" step="50">
            <span id="long-press-delay-value">500</span>ms
        </div>

        <div class="setting-group">
            <label for="chord-method">Chording Method:</label>
            <select id="chord-method">
                <option value="singleTap">Single Tap</option>
                <option value="doubleTap">Double Tap</option>
            </select>
        </div>
        <button onclick="applySettings()">Apply</button>
        <button onclick="toggleSettings()">Close</button>
    </div>

    <div id="overlay"></div>
     <div id="message-box">
      <p id="message-text"></p>
      <button onclick="restartGame()">Restart</button>
    </div>
      <div id="online-leaderboard-container">
        <div id="leaderboard-loading">Loading leaderboards...</div>
        <div id="leaderboard-error" style="color: red; display: none;">Error loading leaderboards.</div>

        <table>
            <thead><tr><th colspan="3">Beginner</th></tr></thead>
            <tbody id="leaderboard-beginner"></tbody>
        </table>

        <table>
             <thead><tr><th colspan="3">Intermediate</th></tr></thead>
            <tbody id="leaderboard-intermediate"></tbody>
        </table>

        <table>
            <thead><tr><th colspan="3">Expert</th></tr></thead>
            <tbody id="leaderboard-expert"></tbody>
        </table>
      </div>

      <div id="leaderboard">
        <h3>Local Leaderboard</h3>
        <table>
            <thead>
                <tr>
                    <th>Difficulty</th>
                    <th>Best time</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Beginner</td>
                    <td id="leaderboard-beginner-local">-</td>
                </tr>
                <tr>
                    <td>Intermediate</td>
                    <td id="leaderboard-intermediate-local">-</td>
                </tr>
                <tr>
                    <td>Expert</td>
                    <td id="leaderboard-expert-local">-</td>
                </tr>
            </tbody>
        </table>
    </div>

    <script>
     // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyAV_27osmUzqrYbJIatByVHigyKh0naSNM",
      authDomain: "min3s-d13d8.firebaseapp.com",
      projectId: "min3s-d13d8",
      storageBucket: "min3s-d13d8.firebasestorage.app",
      messagingSenderId: "561325595032",
      appId: "1:561325595032:web:19657730940427fb4073ed",
      measurementId: "G-N25M3ZT9NQ"
    };

    // Initialize Firebase
    const firebaseApp = firebase.initializeApp(firebaseConfig);
    const db = firebaseApp.firestore();

    let grid = [];
    let width = 9;
    let height = 9;
    let numMines = 10;
    let minesLeft = numMines;
    let timerInterval;
    let asdfghj = 0;
    let gameStarted = false;
    let gameOver = false;
    let firstClick = true;
    let touchLongPressTimerId = null;
    let mouseLongPressTimerId = null;
    let ignoreNextClick = false; // Specifically for preventing click after touch long press
    let longPressFlaggedThisTouch = false; // Flag set when touch long press timer completes
    let longPressJustFinishedMouse = false; // Flag for mouse long press completion
    let isLeftMouseDown = false;
    let pressedCellElement = null;
    let initialMouseDownCell = null;
    let longPressDelay = 500;
    let flagMethod = "longPress";
    let chordMethod = "singleTap";
    let doubleTapChordTimer = null;
    let doubleTapFlagTimer = null;
    let currentDifficulty = "beginner";
    let playerName = "Player";

    function createGrid() {
      const gridContainer = document.getElementById('grid-container');
      gridContainer.innerHTML = '';
      gridContainer.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
      grid = [];

      for (let y = 0; y < height; y++) {
        grid[y] = [];
        for (let x = 0; x < width; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.dataset.x = x;
          cell.dataset.y = y;
          cell.addEventListener('click', handleClick); // Keep click for touch taps
          cell.addEventListener('mousedown', handleCellMouseDown);
          cell.addEventListener('contextmenu', handleRightClick);
          cell.addEventListener('mouseover', handleCellMouseOver);
          cell.addEventListener('mouseout', handleCellMouseOut);

          // Apply touch/long press listeners based on settings
          updateFlagMethod(cell, x, y);

          gridContainer.appendChild(cell);
          grid[y][x] = {
            isMine: false,
            isRevealed: false,
            isFlagged: false,
            adjacentMines: 0,
            element: cell,
          };
        }
      }
      updateMinesLeftDisplay();
      updateTimerDisplay();
      gridContainer.addEventListener('contextmenu', (e) => { e.preventDefault(); });
      document.addEventListener('mouseup', handleDocumentMouseUp);
    }

    function handleRightClick(event) {
      event.preventDefault();
    }

    function handleCellMouseDown(event) {
        if (gameOver) return;

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;

        initialMouseDownCell = targetCell;

        if (event.button === 2) {
            event.preventDefault();
            if (flagMethod === 'rightClick' || flagMethod === 'longPress') {
                handleFlag(event);
            }
            return;
        }

        if (event.button === 0) {
             if (flagMethod === 'longPress') {
                 clearTimeout(mouseLongPressTimerId);
                 longPressJustFinishedMouse = false; // Reset mouse long press flag
                 mouseLongPressTimerId = setTimeout(() => {
                     handleFlag(event);
                     longPressJustFinishedMouse = true; // Set flag specific to mouse
                     mouseLongPressTimerId = null;
                     if (pressedCellElement) {
                        pressedCellElement.classList.remove('pressed');
                     }
                     pressedCellElement = null;
                 }, longPressDelay);
             }

             isLeftMouseDown = true;
             pressedCellElement = targetCell;
             const cellData = grid[parseInt(targetCell.dataset.y)][parseInt(targetCell.dataset.x)];
             if (!cellData.isRevealed) {
                pressedCellElement.classList.add('pressed');
             }
        }
    }

    function handleCellMouseOver(event) {
        if (!isLeftMouseDown || gameOver) return;

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;

        const cellData = grid[parseInt(targetCell.dataset.y)][parseInt(targetCell.dataset.x)];
        if (cellData.isRevealed) {
             if (pressedCellElement && pressedCellElement !== targetCell) {
                 pressedCellElement.classList.remove('pressed');
             }
             pressedCellElement = null;
             return;
        }

        if (targetCell !== pressedCellElement) {
            if (pressedCellElement) {
                pressedCellElement.classList.remove('pressed');
            }
            targetCell.classList.add('pressed');
            pressedCellElement = targetCell;
        }
    }

    function handleCellMouseOut(event) {
        if (!isLeftMouseDown || gameOver) return;

        const targetCell = event.target.closest('.cell');
        if (targetCell === pressedCellElement) {
             pressedCellElement.classList.remove('pressed');
             pressedCellElement = null;
        }
    }


    function handleDocumentMouseUp(event) {
        if (event.button !== 0 || !isLeftMouseDown) {
            if (pressedCellElement) {
                 pressedCellElement.classList.remove('pressed');
                 pressedCellElement = null;
            }
            isLeftMouseDown = false;
            clearTimeout(mouseLongPressTimerId); // Clear MOUSE long press timer
            mouseLongPressTimerId = null;
            initialMouseDownCell = null;
            return;
        }

        isLeftMouseDown = false;
        const mouseUpTargetElement = document.elementFromPoint(event.clientX, event.clientY);
        const mouseUpCellElement = mouseUpTargetElement ? mouseUpTargetElement.closest('.cell') : null;

        clearTimeout(mouseLongPressTimerId); // Clear any running MOUSE long press timer
        mouseLongPressTimerId = null;

        if (pressedCellElement) {
            pressedCellElement.classList.remove('pressed');
        }
        pressedCellElement = null;
        initialMouseDownCell = null;


        if (longPressJustFinishedMouse) { // Check MOUSE long press flag
            longPressJustFinishedMouse = false; // Reset mouse flag
            return; // Do not reveal/chord if mouse long press just flagged
        }

        if (gameOver) return;

        if (mouseUpCellElement) {
            const x = parseInt(mouseUpCellElement.dataset.x);
            const y = parseInt(mouseUpCellElement.dataset.y);

             if (firstClick) {
                 placeMines(x, y);
                 startTimer();
                 firstClick = false;
             }

            const cellData = grid[y][x];

            if (cellData.isRevealed) {
                 chord(x, y);
            } else {
                revealCell(x, y);
            }
        }
    }


    function updateFlagMethod(cell, x, y) {
        if(!cell){
            for(let r = 0; r < height; r++){
                for(let c = 0; c < width; c++){
                    if (grid[r] && grid[r][c]) {
                       updateFlagMethod(grid[r][c].element, c, r);
                    }
                }
            }
            return;
        }

        cell.removeEventListener('touchstart', handleDoubleTapFlag);
        removeLongPressListener(cell); // Remove previous listeners (touch and mouse leave)

        if (flagMethod === 'longPress') {
            addLongPressListener(cell, handleFlag); // Adds TOUCH listeners
        } else if (flagMethod === 'doubleTap') {
            cell.addEventListener('touchstart', handleDoubleTapFlag);
        } else if (flagMethod === 'rightClick') {
            // Handled in handleCellMouseDown
        }
    }
    function handleDoubleTapFlag(event){
        if(gameOver || flagMethod !== 'doubleTap') return;

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;

        if(doubleTapFlagTimer === null){
            doubleTapFlagTimer = setTimeout(() => {
                doubleTapFlagTimer = null;
                handleClick(event); // Use click handler for single tap logic
            }, 300)
        }
        else{
            clearTimeout(doubleTapFlagTimer);
            doubleTapFlagTimer = null;
            handleFlag(event);
        }
    }
    function handleDoubleTapChord(event){
        if(gameOver || chordMethod !== 'doubleTap') return;

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;
        const x = parseInt(targetCell.dataset.x);
        const y = parseInt(targetCell.dataset.y);

         if (doubleTapChordTimer === null) {
            doubleTapChordTimer = setTimeout(() => {
                doubleTapChordTimer = null;
            }, 300);
        } else {
            clearTimeout(doubleTapChordTimer);
            doubleTapChordTimer = null;
            chord(x, y);
        }
    }

    // --- placeMines, isNearSafeZone, calculateAdjacentMines, revealCell remain the same ---
    function placeMines(safeX, safeY) {
        let minesPlaced = 0;
        while (minesPlaced < numMines) {
            const x = Math.floor(Math.random() * width);
            const y = Math.floor(Math.random() * height);

            if (!grid[y][x].isMine && !(x === safeX && y === safeY) && !isNearSafeZone(x,y, safeX, safeY)) {
                grid[y][x].isMine = true;
                minesPlaced++;
            }
        }
        calculateAdjacentMines();
    }

    function isNearSafeZone(x, y, safeX, safeY){
        for(let dx = -1; dx <= 1; dx++){
            for(let dy = -1; dy <= 1; dy++){
                if(x + dx === safeX && y + dy === safeY){
                    return true;
                }
            }
        }
        return false;
    }

    function calculateAdjacentMines() {
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (!grid[y][x].isMine) {
                    let count = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const newX = x + dx;
                            const newY = y + dy;
                            if (newX >= 0 && newX < width && newY >= 0 && newY < height && grid[newY][newX].isMine) {
                                count++;
                            }
                        }
                    }
                    grid[y][x].adjacentMines = count;
                }
            }
        }
    }
    function revealCell(x, y) {
        if (isNaN(x) || isNaN(y) || !grid[y] || !grid[y][x]) return;

        const cell = grid[y][x];

        if (cell.isRevealed || cell.isFlagged || gameOver) return;

        cell.isRevealed = true;
        cell.element.classList.remove('pressed');
        cell.element.classList.add('revealed');

        if (cell.isMine) {
            revealAllMines();
            showMessage("Game Over!");
            displayFix();
            gameOver = true;

        } else {
            if (cell.adjacentMines > 0) {
                cell.element.textContent = cell.adjacentMines;
            } else {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const newX = x + dx;
                        const newY = y + dy;
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            revealCell(newX, newY);
                        }
                    }
                }
            }
        }
       checkWin();
    }

   // 'click' event handler PRIMARILY for TOUCH interactions now
   function handleClick(event) {
        // --- BUG FIX: Check ignoreNextClick FIRST ---
        if (ignoreNextClick) {
            ignoreNextClick = false; // Reset the flag
            return; // Prevent action after touch long press
        }
        // --- END BUG FIX ---

        if (gameOver) return;

        // Ignore left mouse clicks here (handled by mousedown/mouseup)
        if (event.pointerType === 'mouse' && event.button === 0) {
             return;
        }

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;
        const x = parseInt(targetCell.dataset.x);
        const y = parseInt(targetCell.dataset.y);
        const cell = grid[y][x];

        // First click logic (only for the very first valid touch action)
        if (firstClick) {
            if (!cell.isRevealed && !cell.isFlagged) {
                placeMines(x, y);
                startTimer();
                firstClick = false;
            } else {
                return;
            }
        }

        // Subsequent touch actions
        if (cell.isRevealed) { // Handle chording
            if (chordMethod === 'doubleTap') {
                 handleDoubleTapChord(event);
            } else {
                chord(x, y);
            }
        } else { // Handle revealing
             if (flagMethod !== 'doubleTap') {
                 revealCell(x, y);
             }
             // If flag method IS double tap, reveal is handled by handleDoubleTapFlag's timeout
        }
    }

    function handleFlag(event) {
      if (gameOver) return;

      const targetCell = event.target.closest('.cell');
      if (!targetCell) return;

      const x = parseInt(targetCell.dataset.x);
      const y = parseInt(targetCell.dataset.y);
      const cell = grid[y][x];

      if (!cell.isRevealed) {
        if (cell.isFlagged) {
          cell.isFlagged = false;
          cell.element.classList.remove('flagged');
          cell.element.textContent = '';
          minesLeft++;
        } else if (minesLeft > 0) {
          cell.isFlagged = true;
          cell.element.classList.add('flagged');
          cell.element.textContent = '🚩';
          minesLeft--;
        }
        updateMinesLeftDisplay();
      }
      checkWin();
    }

     function chord(x, y){
        if (isNaN(x) || isNaN(y) || !grid[y] || !grid[y][x]) return;
        const cell = grid[y][x];
        if(!cell.isRevealed || cell.adjacentMines === 0 || gameOver) return;

        let flaggedNeighbors = 0;
                    for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const newX = x + dx;
                const newY = y + dy;
                 if (newX >= 0 && newX < width && newY >= 0 && newY < height && grid[newY][newX].isFlagged) {
                       flaggedNeighbors++;
                  }
            }
          }
         if(flaggedNeighbors === cell.adjacentMines){
             for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const newX = x + dx;
                    const newY = y + dy;
                    if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                           revealCell(newX, newY);
                    }
                }
              }
         }
     }

     function revealAllMines() {
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                 if (grid[y] && grid[y][x] && grid[y][x].element) {
                     grid[y][x].element.classList.remove('pressed');
                     if (grid[y][x].isMine) {
                        grid[y][x].element.classList.add('mine-revealed');
                        grid[y][x].element.textContent = "💣";
                     }
                 }
            }
        }
    }
   function checkWin() {
      if (gameOver) return;
      let allNonMinesRevealed = true;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
           if (grid[y] && grid[y][x]) {
                if (!grid[y][x].isMine && !grid[y][x].isRevealed) {
                    allNonMinesRevealed = false;
                    break;
                }
           } else {
                allNonMinesRevealed = false;
                break;
           }
        }
          if (!allNonMinesRevealed) break;
      }
      if (allNonMinesRevealed) {
          flagIncorrectlyPlaced();
          displayFix();
          loseTheGame();
          showMessage("You Win! Time: " + asdfghj + " seconds");
          gameOver = true;
            if (pressedCellElement) { pressedCellElement.classList.remove('pressed'); pressedCellElement = null; }
            isLeftMouseDown = false;
      }
    }

    function flagIncorrectlyPlaced(){
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                 if (grid[y] && grid[y][x]) {
                    if(grid[y][x].isFlagged && !grid[y][x].isMine){
                        grid[y][x].element.classList.remove('flagged');
                        grid[y][x].element.classList.add('incorrect-flag');
                        grid[y][x].element.textContent = 'X';
                    }
                    if(!grid[y][x].isFlagged && grid[y][x].isMine){
                        if (!grid[y][x].element.classList.contains('flagged')) {
                           grid[y][x].element.classList.add('flagged');
                           grid[y][x].element.textContent = '🚩';
                        }
                    }
                 }
            }
        }
    }

    function startTimer() {
        if (!gameStarted) {
            gameStarted = true;
            timerInterval = setInterval(() => {
                asdfghj++;
                updateTimerDisplay();
            }, 1000);
        }
    }

    function displayFix() {
       clearInterval(timerInterval);
    }

   // --- Refined Long Press Listener for Touch ---
   function addLongPressListener(element, callback) {
       let elementTouchTimerId = null; // Timer ID specific to this element's touch
       longPressFlaggedThisTouch = false; // Reset this flag for the element

       const handleTouchStart = (e) => {
           if (e.touches.length === 1 && elementTouchTimerId === null) {
               longPressFlaggedThisTouch = false; // Reset on new touch start
               ignoreNextClick = false;          // Reset ignore flag too
               elementTouchTimerId = setTimeout(() => {
                   longPressFlaggedThisTouch = true; // Set flag: timer completed
                   callback(e);                      // Execute the flag callback
                   ignoreNextClick = true;           // Set flag to ignore upcoming click
                   elementTouchTimerId = null;       // Timer is done
               }, longPressDelay);
           }
       };

       const handleTouchEnd = (e) => {
           if (elementTouchTimerId !== null) {
               // Timer was cleared *before* it completed (short tap)
               clearTimeout(elementTouchTimerId);
               elementTouchTimerId = null;
           }
           if (longPressFlaggedThisTouch) {
                // Long press DID complete, try to prevent default action (click)
                e.preventDefault();
                longPressFlaggedThisTouch = false; // Reset for next interaction
                // ignoreNextClick is already true, handleClick will handle it
           }
       };

       const handleTouchMove = () => {
           if (elementTouchTimerId !== null) {
               clearTimeout(elementTouchTimerId);
               elementTouchTimerId = null;
               longPressFlaggedThisTouch = false; // Move cancels long press
               ignoreNextClick = false;         // Don't ignore click if moved
           }
       };

       // Add Touch Listeners: set passive: false on touchstart to allow preventDefault in touchend
       element.addEventListener('touchstart', handleTouchStart, { passive: false });
       element.addEventListener('touchend', handleTouchEnd);
       element.addEventListener('touchmove', handleTouchMove, { passive: true });

       // Store handlers for removal
       element._touchStartHandler = handleTouchStart;
       element._touchEndHandler = handleTouchEnd;
       element._touchMoveHandler = handleTouchMove;

       // Mouse long press is handled separately in handleCellMouseDown
       // Add mouseleave cleanup for mouse long press timer started in mousedown
        const handleMouseLeave = () => {
             clearTimeout(mouseLongPressTimerId); // Clear potential MOUSE timer
             mouseLongPressTimerId = null;
             longPressJustFinishedMouse = false; // Reset mouse flag
             if (isLeftMouseDown && pressedCellElement === element) { // If leaving the pressed cell
                element.classList.remove('pressed');
                // Keep pressedCellElement assigned until mouseup or mouseover elsewhere
             }
        };
        element.addEventListener('mouseleave', handleMouseLeave);
        element._mouseLeaveHandlerLP = handleMouseLeave; // Store for removal
   }

   function removeLongPressListener(element) {
        // Clear any active touch timer associated with this element (if it exists conceptually)
        // Note: Direct access to elementTouchTimerId isn't feasible here, rely on cleanup elsewhere.

        if (element._touchStartHandler) {
            element.removeEventListener('touchstart', element._touchStartHandler, { passive: false }); // Match options
            delete element._touchStartHandler;
        }
        if (element._touchEndHandler) {
            element.removeEventListener('touchend', element._touchEndHandler);
            delete element._touchEndHandler;
        }
        if (element._touchMoveHandler) {
            element.removeEventListener('touchmove', element._touchMoveHandler, { passive: true });
            delete element._touchMoveHandler;
        }
         // Remove mouse leave listener added by this function
         if (element._mouseLeaveHandlerLP) {
             element.removeEventListener('mouseleave', element._mouseLeaveHandlerLP);
             delete element._mouseLeaveHandlerLP;
         }
    }
    // --- END Refined Long Press ---


    function toggleSettings() {
        const settingsPanel = document.getElementById('settings-panel');
        const overlay = document.getElementById('overlay');
        if(settingsPanel.style.display === "block") {
            settingsPanel.style.display = "none";
            overlay.style.display = 'none';
        }
        else {
            settingsPanel.style.display = "block";
            overlay.style.display = 'block';
            document.getElementById('long-press-delay-value').textContent = longPressDelay;
            if (currentDifficulty === 'custom') {
               document.querySelector('.custom-settings').classList.add('active');
            } else {
               document.querySelector('.custom-settings').classList.remove('active');
            }
        }
    }
    function updateTimerDisplay(){
        if (document.querySelector('#timer > div:nth-child(2)')) {
            document.querySelector('#timer > div:nth-child(2)').textContent = asdfghj;
        }
    }
    function updateMinesLeftDisplay(){
         if (document.querySelector('#mines-left > div:nth-child(2)')) {
            document.querySelector('#mines-left > div:nth-child(2)').textContent = minesLeft;
         }
    }

    function setDifficulty(difficulty) {
      currentDifficulty = difficulty;
      const customSettings = document.querySelector('.custom-settings');

      switch (difficulty) {
        case 'beginner': width = 9; height = 9; numMines = 10; customSettings.classList.remove('active'); break;
        case 'intermediate': width = 16; height = 16; numMines = 40; customSettings.classList.remove('active'); break;
        case 'expert': width = 30; height = 16; numMines = 99; customSettings.classList.remove('active'); break;
        case 'custom':
          customSettings.classList.add('active');
            document.getElementById('width').value = width;
            document.getElementById('height').value = height;
            document.getElementById('mines').value = numMines;
            return;
      }
        document.getElementById('width').value = width;
        document.getElementById('height').value = height;
        document.getElementById('mines').value = numMines;
        minesLeft = numMines;
        restartGame();
    }

   function applySettings() {
        if (currentDifficulty === 'custom') {
            width = parseInt(document.getElementById('width').value);
            height = parseInt(document.getElementById('height').value);
            numMines = parseInt(document.getElementById('mines').value);
             if (isNaN(width) || width < 5 || width > 30) { alert('Width must be between 5 and 30.'); return; }
             if (isNaN(height) || height < 5 || height > 30) { alert('Height must be between 5 and 30.'); return; }
             if (isNaN(numMines) || numMines < 1 || numMines > (width * height) - 1) { alert(`Mines must be between 1 and ${width * height - 1}.`); return; }
        }
        playerName = document.getElementById('player-name').value.trim() || "Player";
        localStorage.setItem('playerName', playerName);
        document.getElementById('player-name').value = playerName;

        const lightModeCheckbox = document.getElementById('light-mode');
        flagMethod = document.getElementById('flag-method').value;
        longPressDelay = parseInt(document.getElementById('long-press-delay').value);
        chordMethod = document.getElementById('chord-method').value;

        localStorage.setItem('darkMode', lightModeCheckbox.checked ? 'enabled' : 'disabled');
        localStorage.setItem('flagMethod', flagMethod);
        localStorage.setItem('longPressDelay', longPressDelay);
        localStorage.setItem('chordMethod', chordMethod);
        localStorage.setItem('currentDifficulty', currentDifficulty);
        localStorage.setItem('width', width);
        localStorage.setItem('height', height);
        localStorage.setItem('numMines', numMines);

      if (lightModeCheckbox.checked) {
        document.body.classList.add('light-mode');
        document.getElementById('settings-panel').style.backgroundColor = "white";
        document.getElementById('message-box').style.backgroundColor = "white";
      } else {
        document.body.classList.remove('light-mode');
         document.getElementById('settings-panel').style.backgroundColor = "var(--container-bg)";
         document.getElementById('message-box').style.backgroundColor = "var(--container-bg)";
      }
        minesLeft = numMines;
        restartGame();
        toggleSettings();
    }

    function showMessage(message) {
        document.getElementById('message-text').textContent = message;
        document.getElementById('message-box').style.display = 'block';
        document.getElementById('overlay').style.display = 'block';
    }

    function restartGame() {
        displayFix();
        asdfghj = 0;
        updateTimerDisplay();
        gameStarted = false;
        firstClick = true;
        gameOver = false;
        minesLeft = numMines
        updateMinesLeftDisplay();

        // Reset ALL interaction states thoroughly
        ignoreNextClick = false;
        longPressFlaggedThisTouch = false; // Reset touch flag
        longPressJustFinishedMouse = false; // Reset mouse flag
        isLeftMouseDown = false;
         if (pressedCellElement) { pressedCellElement.classList.remove('pressed'); pressedCellElement = null; }
         initialMouseDownCell = null;
        clearTimeout(touchLongPressTimerId); touchLongPressTimerId = null; // Clear touch timer
        clearTimeout(mouseLongPressTimerId); mouseLongPressTimerId = null; // Clear mouse timer
        clearTimeout(doubleTapFlagTimer); doubleTapFlagTimer = null;
        clearTimeout(doubleTapChordTimer); doubleTapChordTimer = null;

        // Remove the global mouseup listener before creating the grid again
        document.removeEventListener('mouseup', handleDocumentMouseUp);

        createGrid(); // Recreate grid and reattach listeners
        document.getElementById('message-box').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
    }

    document.getElementById('long-press-delay').addEventListener('input', (event) => {
        document.getElementById('long-press-delay-value').textContent = event.target.value;
        longPressDelay = parseInt(event.target.value);
    });

      function loseTheGame() {
        if (currentDifficulty === 'beginner' || currentDifficulty === 'intermediate' || currentDifficulty === 'expert') {
            const currentName = document.getElementById('player-name').value.trim();
             if (!currentName) { alert("Please enter your name in Settings to submit score!"); return; }

            const scoresCollection = db.collection('leaderboard');
            scoresCollection.add({
                playerName: currentName, difficulty: currentDifficulty, score: asdfghj,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            }).then(() => {
                console.log("Score submitted to online leaderboard!");
                loadOnlineLeaderboard();
            }).catch((error) => {
                console.error("Error submitting score: ", error);
                document.getElementById('leaderboard-error').textContent = 'Error submitting score.';
                document.getElementById('leaderboard-error').style.display = 'block';
            });

            let bestTime = localStorage.getItem(`leaderboard-${currentDifficulty}`);
            if (bestTime === null || asdfghj < parseInt(bestTime)) {
                localStorage.setItem(`leaderboard-${currentDifficulty}`, asdfghj);
                bestTime = asdfghj;
            }
              document.getElementById(`leaderboard-${currentDifficulty}-local`).textContent = bestTime === null ? '-' : bestTime + 's';
        }
    }

async function fetchScoresRecursive(difficulty, targetCount, collectedScores = [], lastVisible = null) {
    // Define the base query
    let q = db.collection('leaderboard')
              .where('difficulty', '==', difficulty)
              .where('score', '>', 1) // Filter scores > 1 directly in Firestore
              .orderBy('score', 'asc');

    // If we have a document to start after (for pagination)
    if (lastVisible) {
        q = q.startAfter(lastVisible);
    }

    // Fetch a batch. Fetching slightly more than needed in case some future filter was added,
    // but with score > 1 in the query, we could calculate the exact remaining need.
    // Let's fetch batches of 'targetCount' for simplicity in this example.
    q = q.limit(targetCount); // Fetch up to targetCount in this batch

    try {
        const documentSnapshots = await q.get();

        // Get the last document for the next potential fetch
        const newLastVisible = documentSnapshots.docs[documentSnapshots.docs.length - 1];
        let addedCount = 0;

        documentSnapshots.forEach((doc) => {
            // Add scores to our collected list if we haven't reached the target yet
            if (collectedScores.length < targetCount) {
                collectedScores.push(doc.data());
                addedCount++;
            }
        });

        // If we haven't reached the target count AND we received a full batch
        // (implying there might be more), fetch the next batch.
        if (collectedScores.length < targetCount && addedCount > 0 && documentSnapshots.docs.length === targetCount && newLastVisible) {
             // console.log(`Fetching more for ${difficulty}. Found ${collectedScores.length}, need ${targetCount}`);
             return fetchScoresRecursive(difficulty, targetCount, collectedScores, newLastVisible);
        } else {
             // We have enough scores OR there are no more documents to fetch
             // console.log(`Finished fetching for ${difficulty}. Found ${collectedScores.length}`);
             return collectedScores; // Return the final list
        }
    } catch (error) {
        console.error(`Error fetching scores for ${difficulty}:`, error);
        throw error; // Re-throw the error to be caught by the main function
    }
}

async function loadOnlineLeaderboard() {
    document.getElementById('leaderboard-loading').style.display = 'block';
    document.getElementById('leaderboard-error').style.display = 'none';
    document.getElementById('leaderboard-beginner').innerHTML = '';
    document.getElementById('leaderboard-intermediate').innerHTML = '';
    document.getElementById('leaderboard-expert').innerHTML = '';

    const difficulties = ['beginner', 'intermediate', 'expert'];
    const targetScoreCount = 10; // We want 10 scores per difficulty

    // Use Promise.all to wait for all difficulties to load
    try {
        const promises = difficulties.map(async (difficulty) => {
            const leaderboardBody = document.getElementById(`leaderboard-${difficulty}`);
            if (!leaderboardBody) {
                console.error("Leaderboard body not found for:", difficulty);
                return; // Skip this difficulty if element doesn't exist
            }
            leaderboardBody.innerHTML = ''; // Clear previous entries

            // Fetch the required scores recursively
            const scores = await fetchScoresRecursive(difficulty, targetScoreCount);

            // Populate the table with the fetched scores
            let rank = 1;
            scores.forEach((data) => {
                const row = leaderboardBody.insertRow();
                row.insertCell().textContent = rank++;
                row.insertCell().textContent = data.playerName;
                row.insertCell().textContent = data.score + 's';
            });
        });

        // Wait for all fetching and rendering operations to complete
        await Promise.all(promises);

        // Hide loading indicator only after all promises resolve successfully
        document.getElementById('leaderboard-loading').style.display = 'none';

    } catch (error) {
        // Handle errors from any of the promises
        console.error("Error loading one or more online leaderboards:", error);
        document.getElementById('leaderboard-loading').style.display = 'none';
        document.getElementById('leaderboard-error').textContent = 'Error loading online leaderboards. Please try again later.';
        document.getElementById('leaderboard-error').style.display = 'block';
    }
}

    function loadLeaderboard() {
        const difficulties = ['beginner', 'intermediate', 'expert'];
        difficulties.forEach(difficulty => {
            const bestTime = localStorage.getItem(`leaderboard-${difficulty}`);
            const tdElement = document.getElementById(`leaderboard-${difficulty}-local`); // Get TD element
             if (tdElement) { // Check if element exists
                 tdElement.textContent = bestTime === null ? '-' : bestTime + 's';
             }
        });
    }

    function loadSettings() {
      playerName = localStorage.getItem('playerName') || 'Player';
      document.getElementById('player-name').value = playerName;

      const savedDarkMode = localStorage.getItem('darkMode');
      const lightModeCheckbox = document.getElementById('light-mode');
      if (savedDarkMode === 'enabled') {
          document.body.classList.add('light-mode');
          lightModeCheckbox.checked = true;
          document.getElementById('settings-panel').style.backgroundColor = "white";
          document.getElementById('message-box').style.backgroundColor = "white";
      } else {
           document.body.classList.remove('light-mode');
           lightModeCheckbox.checked = false;
            document.getElementById('settings-panel').style.backgroundColor = "var(--container-bg)";
            document.getElementById('message-box').style.backgroundColor = "var(--container-bg)";
      }

      flagMethod = localStorage.getItem('flagMethod') || 'longPress';
      document.getElementById('flag-method').value = flagMethod;
      longPressDelay = parseInt(localStorage.getItem('longPressDelay')) || 500;
      document.getElementById('long-press-delay').value = longPressDelay;
      document.getElementById('long-press-delay-value').textContent = longPressDelay;

      chordMethod = localStorage.getItem('chordMethod') || 'singleTap';
      document.getElementById('chord-method').value = chordMethod;

      currentDifficulty = localStorage.getItem('currentDifficulty') || 'beginner';
      width = parseInt(localStorage.getItem('width')) || 9;
      height = parseInt(localStorage.getItem('height')) || 9;
      numMines = parseInt(localStorage.getItem('numMines')) || 10;

      // Apply loaded settings - setDifficulty handles dimensions/restart for non-custom
      setDifficulty(currentDifficulty);

      // If loaded as custom, ensure dimensions are applied & restart if needed
      if(currentDifficulty === 'custom'){
           document.getElementById('width').value = width;
           document.getElementById('height').value = height;
           document.getElementById('mines').value = numMines;
           // If the *loaded* difficulty was custom, we need to restart to apply W/H/M
           // Check localStorage directly because setDifficulty doesn't restart for 'custom'
           if (localStorage.getItem('currentDifficulty') === 'custom') {
               minesLeft = numMines; // Ensure minesLeft is correct
               restartGame(); // Trigger restart to apply dimensions
           }
      }
      // Ensure flag listeners match loaded settings *after* potential restart
      updateFlagMethod();

    }

    // --- Initialize ---
    loadSettings();
    loadLeaderboard();
    loadOnlineLeaderboard();
    // createGrid() is called by loadSettings -> setDifficulty -> restartGame

    </script>
</body>
</html>