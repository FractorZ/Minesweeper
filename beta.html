<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Min3s â€“ Mobile Minesweeper Game No Guess with Leaderboards</title>
<meta name="description" content="Play Minesweeper online at Min3s.click! No ads, Mobile-friendly, no guess mode, and live global leaderboard.">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <!-- Firebase App (include only once) -->
    <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-app-compat.js"></script>
    <!-- Firebase Firestore -->
    <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-firestore-compat.js"></script>
    <style>
        /* Base Styles (Dark Mode - Now Default) */
        :root {
            --bg-color: #333;
            --container-bg: #444;
            --grid-border-color: #666;
            --grid-bg-color: #555;
            --cell-bg-color: #666;
            --cell-border-color: #777;
            --revealed-cell-bg: #555;
            --revealed-cell-border: #888;
            --flagged-cell-bg: #4682B4; /* Steel Blue */
            --flagged-cell-color: #FFD700; /* Gold */
            --mine-bg-color: #B22222; /* Firebrick - Not used directly, see .mine */
            --mine-revealed-bg: #800000; /* Maroon */
            --mine-revealed-color: white;
            --incorrect-flag-bg: #A0522D; /* Sienna */
            --incorrect-flag-color: white;
            --text-color: white;
            --button-bg: #3e8e41;
            --button-hover-bg: #2e6e31;
            --button-text-color: white;
            --control-border-color: #aaa;
            --control-bg-color: #444;
            --cell-pressed-bg: #777; /* Added style for pressed cell */

             /* Dark mode number colors (lighter) */
            --num-1-color-dark: #ADD8E6; /* Light Blue */
            --num-2-color-dark: #90EE90; /* Light Green */
            --num-3-color-dark: #F08080; /* Light Coral */
            --num-4-color-dark: #B0C4DE; /* Light Steel Blue */
            --num-5-color-dark: #FFA07A; /* Light Salmon */
            --num-6-color-dark: #20B2AA; /* Light Sea Green */
            --num-7-color-dark: #E6E6FA; /* Lavender (lighter than grey) */
            --num-8-color-dark: #D3D3D3; /* Light Gray */
        }

        /* Light Mode Styles */
        .light-mode {
            --bg-color: #e0e0e0;
            --container-bg: white;
            --grid-border-color: #a0a0a0;
            --grid-bg-color: #c0c0c0;
            --cell-bg-color: #d0d0d0;
            --cell-border-color: #f0f0f0;
            --revealed-cell-bg: #f8f8f8;
            --revealed-cell-border: #909090;
            --flagged-cell-bg: #87CEEB; /* Sky Blue */
            --flagged-cell-color: #B22222; /* Firebrick */
            /* --mine-bg-color: #F08080; */ /* Light Coral - Not used directly */
            --mine-revealed-bg: #DC143C; /* Crimson */
            --mine-revealed-color: white;
            --incorrect-flag-bg: #FFD700; /* Gold */
            --incorrect-flag-color: black;
            --text-color: black;
            --button-bg: #4CAF50;
            --button-hover-bg: #3e8e41;
            --button-text-color: white;
            --control-border-color: #808080;
            --control-bg-color: #f0f0f0;
            --cell-pressed-bg: #e8e8e8; /* Added style for pressed cell */
        }


        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation; /* Prevent double-tap zoom */
        }
         #game-container {
            display: flex;
            flex-direction: column;
            align-items: center; /* Center the header-area and grid */
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            overflow: hidden;
            background-color: var(--container-bg);
            padding: 10px;
        }

        /* Style for the header area containing logo and controls */
        #header-area {
            display: flex;
            align-items: center; /* Vertically align items */
            /* justify-content: space-between; Removed to group logo and controls */
            /* width: 100%; Removed to allow it to shrink to content width */
            margin-bottom: 10px; /* Space below the header area */
            padding: 0; /* Already handled by game-container padding */
            gap: 20px; /* Explicit gap between logo and controls */
        }

        #logo {
            height: 60px; /* Increased size */
            /* margin-right: 15px; Removed, using gap on header-area instead */
             flex-shrink: 0; /* Prevent logo from shrinking */
        }

        #grid-container {
            display: grid;
            grid-gap: 1px;
            border: 3px solid var(--grid-border-color);
            background-color: var(--grid-bg-color);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
             user-select: none;
             -webkit-tap-highlight-color: transparent;
             /* touch-action: manipulation; might also be helpful here */
        }

        .cell {
            width: 28px;
            height: 28px;
            background-color: var(--cell-bg-color);
            border: 2px outset var(--cell-border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            transition: background-color 0.1s; /* Faster transition */
        }
        .cell.pressed { /* Style for when left mouse is down */
            background-color: var(--cell-pressed-bg);
            border-style: inset; /* Give pressed appearance */
        }
        .cell.revealed {
            border: 1px solid var(--revealed-cell-border);
            background-color: var(--revealed-cell-bg);
            cursor: default;
        }
        .cell.flagged {
            background-color: var(--flagged-cell-bg);
            color: var(--flagged-cell-color);
        }
        .cell.mine { /* Style for the mine hit that ends the game */
             background-color: red !important; /* Make it stand out */
             color: white;
        }
        .cell.mine-revealed { /* Style for other mines shown on loss */
            background-color: var(--mine-revealed-bg);
            color: var(--mine-revealed-color);
        }
        .cell.incorrect-flag {
            background-color: var(--incorrect-flag-bg);
            color: var(--incorrect-flag-color);
        }

        /* Dark Mode Number colors */
        .cell[data-adjacent="1"] { color: var(--num-1-color-dark); }
        .cell[data-adjacent="2"] { color: var(--num-2-color-dark); }
        .cell[data-adjacent="3"] { color: var(--num-3-color-dark); }
        .cell[data-adjacent="4"] { color: var(--num-4-color-dark); }
        .cell[data-adjacent="5"] { color: var(--num-5-color-dark); }
        .cell[data-adjacent="6"] { color: var(--num-6-color-dark); }
        .cell[data-adjacent="7"] { color: var(--num-7-color-dark); }
        .cell[data-adjacent="8"] { color: var(--num-8-color-dark); }

        /* Light mode number colors (standard/original) */
        .light-mode .cell[data-adjacent="1"] { color: blue; }
        .light-mode .cell[data-adjacent="2"] { color: green; }
        .light-mode .cell[data-adjacent="3"] { color: red; }
        .light-mode .cell[data-adjacent="4"] { color: navy; }
        .light-mode .cell[data-adjacent="5"] { color: maroon; }
        .light-mode .cell[data-adjacent="6"] { color: teal; }
        .light-mode .cell[data-adjacent="7"] { color: black; }
        .light-mode .cell[data-adjacent="8"] { color: gray; }


        #controls {
            display: flex;
            /* justify-content: space-around; Removed as header-area handles spacing */
             gap: 10px; /* Gap between Mines and Timer */
            /* width: 90%; Removed */
            margin-bottom: 0; /* Removed */
            align-items: center;
            flex-shrink: 0; /* Prevent controls from shrinking */
        }

        #timer, #mines-left {
            font-size: 1.1em;
            font-weight: bold;
            padding: 6px 12px;
            border: 2px solid var(--control-border-color);
            background-color: var(--control-bg-color);
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #timer-label, #mines-left-label {
            font-size: 0.8em;
            color: var(--text-color);
            margin-bottom: 2px;
        }

        #settings {
            margin-top: 20px;
        }

        #settings button {
            padding: 10px 20px;
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }

        #settings button:hover {
            background-color: var(--button-hover-bg);
        }

          #settings-panel {
            display: none;
            position: fixed;
            top: 50%; /* Start at 50% */
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--container-bg);
            color: var(--text-color);
            padding: 25px;
            border: 2px solid #888;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            z-index: 1000;
            width: 90%;
            max-width: 450px;
            border-radius: 12px;
            overflow-y: auto;  /* Enable vertical scrolling */
            max-height: 80vh; /* Limit height to 80% of viewport height */

        }
        #settings-panel label {
            display: block;
            margin-bottom: 6px;
            font-weight: bold;
        }

        #settings-panel input[type="number"],
        #settings-panel input[type="range"],
        #settings-panel input[type="text"] { /* Apply styles to text input too */
            width: 70px;
            margin-bottom: 12px;
            padding: 8px;
            border: 1px solid #bbb;
            border-radius: 5px;
            font-size: 1em;
        }
         #settings-panel input[type="text"]{
             width: calc(100% - 20px); /* Take full width minus padding */
         }

        #settings-panel input[type="range"] {
            width: 100%;
        }

        #settings-panel button {
            padding: 10px 20px;
            margin-top: 12px;
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }

        #settings-panel button:hover {
            background-color: var(--button-hover-bg);;
        }

        #settings-panel .setting-group {
           margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
          #settings-panel .difficulty-buttons {
            display: flex;
            justify-content: space-between; /* Evenly space buttons */
            margin-bottom: 15px;
        }
          #settings-panel .difficulty-buttons button {
            flex: 1; /* Each button takes equal width */
            margin: 0 5px; /* Space between buttons */
        }

        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 999;
        }

        #message-box {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--container-bg);
            color: var(--text-color);
            padding: 25px;
            border: 2px solid #888;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            text-align: center;
            border-radius: 12px;
            width: 80%;
            max-width: 400px;
        }
        #message-box button {
            padding: 10px 20px;
            margin-top: 12px;
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }

        #message-box button:hover {
            background-color: var(--button-hover-bg);
        }

        #message-text {
            font-size: 1.2em;
            margin-bottom: 15px;

        }

        /* Toggle switch styles */
        .switch {
          position: relative;
          display: inline-block;
          width: 60px;
          height: 34px;
          margin-bottom: 12px;
          vertical-align: middle; /* Align with label */
        }

        .switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }

        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ccc;
          -webkit-transition: .4s;
          transition: .4s;
          border-radius: 34px;
        }

        .slider:before {
          position: absolute;
          content: "";
          height: 26px;
          width: 26px;
          left: 4px;
          bottom: 4px;
          background-color: white;
          -webkit-transition: .4s;
          transition: .4s;
          border-radius: 50%;
        }

        input:checked + .slider {
          background-color: #2196F3;
        }

        input:focus + .slider {
          box-shadow: 0 0 1px #2196F3;
        }

        input:checked + .slider:before {
          -webkit-transform: translateX(26px);
          -ms-transform: translateX(26px);
          transform: translateX(26px);
        }
        #settings-panel select{
            margin-bottom: 10px;
            padding: 5px;
        }
        #leaderboard {
            margin-top: 20px;
            text-align: center;
        }

        #leaderboard h3 {
            margin-bottom: 10px;
        }

        #leaderboard table {
            width: 80%;
            max-width: 500px; /* Limit width for local leaderboard */
            margin: 0 auto 20px auto; /* Center and add bottom margin */
            border-collapse: collapse;
        }


        #leaderboard th, #leaderboard td {
            padding: 8px;
            border: 1px solid var(--control-border-color);
            text-align: center;
        }

        #leaderboard th {
            background-color: var(--control-bg-color);
            color: var(--text-color);
        }
        .custom-settings {
            display: none; /* Initially hidden */
        }

        .custom-settings.active {
            display: block; /* Show when active */
        }
         #settings-panel #custom-difficulty-label{
            margin-top: 10px;
            font-size: 1.1em;
        }
        #leaderboard {
            margin-top: 20px;
            text-align: center;
        }

        #leaderboard h3 {
            margin-bottom: 10px;
        }

        #leaderboard th, #leaderboard td {
            padding: 8px;
            border: 1px solid var(--control-border-color);
            text-align: center;
        }

        #leaderboard th {
            background-color: var(--control-bg-color);
            color: var(--text-color);
       }
      #leaderboard-loading {
          margin-bottom: 10px;
          text-align: center; /* Center loading text */
          width: 100%;
      }
       /* Style for online leaderboard tables */
      #online-leaderboard-container {
        display: flex; /* Use flexbox for side-by-side tables */
        justify-content: space-around; /* Distribute space evenly */
        flex-wrap: wrap; /* Allow tables to wrap on smaller screens */
        width: 90%;
        max-width: 1200px; /* Optional max width for very large screens */
        margin: 20px auto;

      }
      /* Individual leaderboard section */
        .leaderboard-section {
            width: 48%; /* Slightly less than half to allow for spacing */
            margin-bottom: 20px; /* Space below each section */
            padding: 10px;
            background-color: var(--container-bg); /* Match container background */
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            box-sizing: border-box; /* Include padding in width calculation */
        }

       .leaderboard-section h4 {
           margin-top: 0;
           margin-bottom: 10px;
           text-align: center;
           color: var(--text-color);
       }

      .leaderboard-section table {
        width: 100%; /* Tables take full width of their section */
        border-collapse: collapse;
      }
        .leaderboard-section th,
        .leaderboard-section td {
             padding: 6px; /* Slightly reduced padding */
              border: 1px solid var(--control-border-color);
              text-align: center;
              font-size: 0.9em; /* Slightly smaller font */
        }
        .leaderboard-section th {
             background-color: var(--control-bg-color);
              color: var(--text-color);
               font-weight: bold;
        }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        #online-leaderboard-container {
          flex-direction: column; /* Stack tables vertically on smaller screens */
          align-items: center; /* Center sections */
        }
          .leaderboard-section {
            width: 90%; /* Sections take full width on smaller screens */
          }
      }
       #generation-attempts {
         margin-left: 10px;
         font-size: 0.9em;
         color: #aaa; /* Light gray color */
        }
        .light-mode #generation-attempts {
            color: #555; /* Darker gray for light mode */
        }
        h1 {
          position: absolute;
          left: -9999px;
        }



    </style>
</head>
<body>
    <h1>Mobile Minesweeper game No Guess Mode and Online Leaderboards</h1>
    <div id="game-container">
        <!-- New header area for logo and controls -->
        <div id="header-area">
            <!-- Logo Image - Default to Dark Mode -->
            <img id="logo" src="/DarkModeLogo.svg" alt="Min3s Logo">
            <div id="controls">
                <div id="mines-left">
                    <div id="mines-left-label">Mines</div>
                    <div></div>
                </div>
                <div id="timer">
                     <div id="timer-label">Timer</div>
                    <div>0</div>
                </div>
            </div>
        </div>
        <!-- End of header area -->

        <div id="grid-container"></div>
    </div>
    <div id="settings">
        <button onclick="toggleSettings()">Settings</button>
    </div>

      <div id="settings-panel">
        <h2>Settings</h2>
        <div class="setting-group difficulty-buttons">
            <button onclick="setDifficulty('beginner')">Beginner</button>
            <button onclick="setDifficulty('intermediate')">Intermediate</button>
            <button onclick="setDifficulty('expert')">Expert</button>
            <button onclick="setDifficulty('custom')">Custom</button> <!-- Custom Difficulty Button -->
        </div>
        <div class="setting-group">
            <label for="player-name">Your Name:</label>
            <input type="text" id="player-name" value="Player" placeholder="Enter your name">
        </div>

        <div class="custom-settings setting-group">
            <label for="width">Width:</label>
            <input type="number" id="width" min="5" max="50" value="9"> <!-- Increased max size -->
            <label for="height">Height:</label>
            <input type="number" id="height" min="5" max="50" value="9"> <!-- Increased max size -->
            <label for="mines">Mines:</label>
            <input type="number" id="mines" min="1" max="2491" value="10"> <!-- Max mines adjusted based on max w/h -->
        </div>
        <div class="setting-group">
             <label for="light-mode" style="display: inline-block; margin-right: 10px;">Light Mode:</label>
             <label class="switch">
                <input type="checkbox" id="light-mode">
                <span class="slider"></span>
             </label>
        </div>
        <div class="setting-group">
             <label for="no-guess-mode" style="display: inline-block; margin-right: 10px;">No Guess Mode:</label>
             <label class="switch">
                 <input type="checkbox" id="no-guess-mode">
                 <span class="slider"></span>
             </label>
             <span id="generation-attempts"></span> <!-- To display attempts -->
        </div>

        <div class="setting-group">
            <label for="flag-method">Flagging Method:</label>
            <select id="flag-method" onchange="updateFlagMethod()">
              <option value="longPress">Long Press</option>
              <option value="doubleTap">Double Tap</option>
              <option value="rightClick">Right Click</option>
            </select>
        </div>

        <div class="setting-group">
            <label for="long-press-delay">Long Press Delay (ms):</label>
            <input type="range" id="long-press-delay" min="100" max="1000" value="500" step="50">
            <span id="long-press-delay-value">500</span>ms
        </div>

        <div class="setting-group">
            <label for="chord-method">Chording Method:</label>
            <select id="chord-method">
                <option value="singleTap">Single Tap</option>
                <option value="doubleTap">Double Tap</option>
            </select>
        </div>
        <button onclick="applySettings()">Apply</button>
        <button onclick="toggleSettings()">Close</button>
    </div>

    <div id="overlay"></div>
     <div id="message-box">
      <p id="message-text"></p>
      <button onclick="restartGame()">Restart</button>
    </div>

     <!-- Online Leaderboards Container -->
      <div id="online-leaderboard-container">
         <div id="leaderboard-loading">Loading leaderboards...</div>
         <div id="leaderboard-error" style="color: red; display: none; width: 100%; text-align: center;">Error loading leaderboards.</div>

         <!-- Standard Leaderboards -->
         <div class="leaderboard-section">
             <h4>Beginner</h4>
             <table>
                 <thead><tr><th>#</th><th>Name</th><th>Time</th></tr></thead>
                 <tbody id="leaderboard-beginner"></tbody>
             </table>
         </div>
         <div class="leaderboard-section">
             <h4>Intermediate</h4>
             <table>
                 <thead><tr><th>#</th><th>Name</th><th>Time</th></tr></thead>
                 <tbody id="leaderboard-intermediate"></tbody>
             </table>
         </div>
         <div class="leaderboard-section">
             <h4>Expert</h4>
             <table>
                 <thead><tr><th>#</th><th>Name</th><th>Time</th></tr></thead>
                 <tbody id="leaderboard-expert"></tbody>
             </table>
         </div>

         <!-- No Guess Leaderboards -->
         <div class="leaderboard-section">
             <h4>Beginner (No Guess)</h4>
             <table>
                 <thead><tr><th>#</th><th>Name</th><th>Time</th></tr></thead>
                 <tbody id="leaderboard-beginner_noguess"></tbody>
             </table>
         </div>
          <div class="leaderboard-section">
             <h4>Intermediate (No Guess)</h4>
             <table>
                 <thead><tr><th>#</th><th>Name</th><th>Time</th></tr></thead>
                 <tbody id="leaderboard-intermediate_noguess"></tbody>
             </table>
         </div>
          <div class="leaderboard-section">
             <h4>Expert (No Guess)</h4>
             <table>
                 <thead><tr><th>#</th><th>Name</th><th>Time</th></tr></thead>
                 <tbody id="leaderboard-expert_noguess"></tbody>
             </table>
         </div>
      </div>

      <!-- Local Leaderboard Table -->
      <div id="leaderboard">
        <h3>Local Leaderboard</h3>
        <table>
            <thead>
                <tr>
                    <th>Difficulty</th>
                    <th>Best Time</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>Beginner</td><td id="leaderboard-beginner-local">-</td></tr>
                <tr><td>Intermediate</td><td id="leaderboard-intermediate-local">-</td></tr>
                <tr><td>Expert</td><td id="leaderboard-expert-local">-</td></tr>
                <tr><td>Beginner (No Guess)</td><td id="leaderboard-beginner_noguess-local">-</td></tr>
                <tr><td>Intermediate (No Guess)</td><td id="leaderboard-intermediate_noguess-local">-</td></tr>
                <tr><td>Expert (No Guess)</td><td id="leaderboard-expert_noguess-local">-</td></tr>
            </tbody>
        </table>
    </div>

    <script>
     // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyAV_27osmUzqrYbJIatByVHigyKh0naSNM",
      authDomain: "min3s-d13d8.firebaseapp.com",
      projectId: "min3s-d13d8",
      storageBucket: "min3s-d13d8.firebaseapp.com", // Corrected storageBucket
      messagingSenderId: "561325595032",
      appId: "1:561325595032:web:19657730940427fb4073ed",
      measurementId: "G-N25M3ZT9NQ"
    };

    // Initialize Firebase
    const firebaseApp = firebase.initializeApp(firebaseConfig);
    const db = firebaseApp.firestore();

    let grid = [];
    let width = 9;
    let height = 9;
    let numMines = 10;
    let minesLeft = numMines;
    let timerInterval;
    let time = 0;
    let gameStarted = false;
    let gameOver = false;
    let firstClick = true;
    let touchLongPressTimerId = null;
    let mouseLongPressTimerId = null;
    let ignoreNextClick = false; // Flag to ignore click after long press
    let longPressFlaggedThisTouch = false; // Flag set when touch long press timer completes
    let longPressJustFinishedMouse = false; // Flag for mouse long press completion
    let isLeftMouseDown = false; // Tracks if left mouse button is currently down
    let pressedCellElement = null; // Tracks the element currently visually pressed by mouse hover/down
    let initialMouseDownCell = null; // Tracks the element where the mouse down event originated
    let longPressDelay = 500;
    let flagMethod = "longPress";
    let chordMethod = "singleTap";
    let doubleTapChordTimer = null;
    let doubleTapFlagTimer = null;
    let currentDifficulty = "beginner"; // Stores the base difficulty: beginner, intermediate, expert, custom
    let playerName = "Player";
    let noGuessMode = false; // Stores the No Guess Mode state
    let generationAttempts = 0; // Added for No Guess Mode


    function createGrid() {
      const gridContainer = document.getElementById('grid-container');
      gridContainer.innerHTML = '';
      gridContainer.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
      grid = [];

      for (let y = 0; y < height; y++) {
        grid[y] = [];
        for (let x = 0; x < width; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.dataset.x = x;
          cell.dataset.y = y;
          cell.addEventListener('click', handleClick); // Handles taps
          cell.addEventListener('mousedown', handleCellMouseDown); // Handles mouse down (incl. long press start)
          cell.addEventListener('contextmenu', handleRightClick); // Handles right click flag
          cell.addEventListener('mouseover', handleCellMouseOver); // Handles mouse drag over cells
          cell.addEventListener('mouseout', handleCellMouseOut); // Handles mouse leaving cell while down

          // Apply touch/long press listeners based on settings
          updateFlagMethod(cell, x, y); // Attaches specific touch listeners

          gridContainer.appendChild(cell);
          grid[y][x] = {
            isMine: false,
            isRevealed: false,
            isFlagged: false,
            adjacentMines: 0,
            element: cell,
          };
        }
      }
      updateMinesLeftDisplay();
      updateTimerDisplay();
      // Prevent default context menu on the grid
      gridContainer.addEventListener('contextmenu', (e) => { e.preventDefault(); });
      // Global mouseup listener for releasing clicks outside the grid
      document.addEventListener('mouseup', handleDocumentMouseUp);
    }

    // --- Event Handlers ---

    function handleRightClick(event) {
        // This function's primary role now is just to prevent the default browser context menu
        // when the contextmenu event fires on a cell.
        // The actual flagging logic for right-click modes is handled in mousedown.
        event.preventDefault();
    }


    function handleCellMouseDown(event) {
        if (gameOver) return;

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;

        // --- Right Click (Button 2) ---
        if (event.button === 2) {
            event.preventDefault(); // Prevent context menu immediately on mousedown

            // Handle flagging immediately on mousedown for both 'rightClick' and 'longPress' modes
            if ((flagMethod === 'rightClick' || flagMethod === 'longPress') && !gameOver) {
                 handleFlag(event); // Flag instantly
            }
            // No further action needed for right mousedown
            return;
        }

        // --- Left Click (Button 0) ---
        if (event.button === 0) {
             initialMouseDownCell = targetCell; // Record where the press started
             isLeftMouseDown = true; // Set the flag indicating left button is down

             // --- Long Press Handling (for mouse) ---
             if (flagMethod === 'longPress') {
                 clearTimeout(mouseLongPressTimerId);
                 longPressJustFinishedMouse = false;
                 mouseLongPressTimerId = setTimeout(() => {
                     // Long press completed: Flag the cell
                     handleFlag(event);
                     longPressJustFinishedMouse = true;
                     mouseLongPressTimerId = null;
                     if (pressedCellElement) {
                        pressedCellElement.classList.remove('pressed');
                     }
                     pressedCellElement = null;
                     // End the "drag" state after long press action
                     isLeftMouseDown = false;
                 }, longPressDelay);
             }

             // --- Standard Left Mouse Down Visual ---
             const cellData = grid[parseInt(targetCell.dataset.y)][parseInt(targetCell.dataset.x)];
             if (cellData && !cellData.isRevealed && !cellData.isFlagged) {
                targetCell.classList.add('pressed');
                pressedCellElement = targetCell; // Track the visually pressed cell
             } else {
                pressedCellElement = null; // Don't track if revealed/flagged
             }
        }
    }

    function handleCellMouseOver(event) {
        if (!isLeftMouseDown || gameOver) return;

        const targetCell = event.target.closest('.cell');
        if (!targetCell) { // If mouse moved off the grid or between cells
             if(pressedCellElement) { // Remove press from the last cell hovered
                  pressedCellElement.classList.remove('pressed');
                  pressedCellElement = null;
             }
             return;
        }

        const cellData = grid[parseInt(targetCell.dataset.y)][parseInt(targetCell.dataset.x)];
        if (!cellData) return;

        // If hovering over a different cell than the one currently pressed
        if (targetCell !== pressedCellElement) {
            if (pressedCellElement) { // Remove pressed state from the old cell
                pressedCellElement.classList.remove('pressed');
            }

            // Apply pressed state to the new cell if it's valid
            if (!cellData.isRevealed && !cellData.isFlagged) {
                 targetCell.classList.add('pressed');
                 pressedCellElement = targetCell; // Update the visually pressed cell
            } else {
                 pressedCellElement = null; // Don't visually press revealed/flagged cells
            }
        }
    }

    function handleCellMouseOut(event) {
        // Only apply if left mouse button is currently held down
        if (!isLeftMouseDown || gameOver) return;

        const relatedTarget = event.relatedTarget; // Where the mouse is going
        // If mouse is leaving the grid container entirely, remove press state
        if (!relatedTarget || !relatedTarget.closest('#grid-container')) {
             if(pressedCellElement) {
                 pressedCellElement.classList.remove('pressed');
                 pressedCellElement = null;
             }
        }
        // The logic in handleCellMouseOver handles transferring the press state
        // when moving between cells, so this function primarily handles leaving the grid.
    }

    function handleDocumentMouseUp(event) {
         // --- Left Click Release (Button 0) ---
        if (event.button === 0 && isLeftMouseDown) { // Check if left button WAS down
             isLeftMouseDown = false; // Mouse button is now up
             const mouseUpTargetElement = document.elementFromPoint(event.clientX, event.clientY);
             const mouseUpCellElement = mouseUpTargetElement ? mouseUpTargetElement.closest('.cell') : null;

             // Clear any running MOUSE long press timer
             clearTimeout(mouseLongPressTimerId);
             mouseLongPressTimerId = null;

             // --- Check if a MOUSE long press just finished ---
             if (longPressJustFinishedMouse) {
                 longPressJustFinishedMouse = false; // Reset mouse flag
                 initialMouseDownCell = null; // Reset initial cell
                 // Ensure pressedCellElement is cleared after long press action
                 if (pressedCellElement) {
                     pressedCellElement.classList.remove('pressed');
                     pressedCellElement = null;
                 }
                 return; // Action was flag, do nothing else
             }

             // Remove visual pressed state from the cell that was last visually pressed
             if (pressedCellElement) {
                 pressedCellElement.classList.remove('pressed');
             }
              // Reset the visually pressed element tracker *after* removing the class
             pressedCellElement = null;

             if (gameOver) {
                 initialMouseDownCell = null;
                 return;
             }

             // --- Process the cell where mouse was released ---
             if (mouseUpCellElement) { // Ensure release happened over a cell
                 const x = parseInt(mouseUpCellElement.dataset.x);
                 const y = parseInt(mouseUpCellElement.dataset.y);
                 const cellData = grid[y]?.[x];

                 if (cellData) { // Cell data exists
                      if (firstClick) {
                          // Trigger first click based on the cell released over
                          handleFirstClick(x, y);
                      } else if (cellData.isRevealed) {
                           // CHORDING: Allow chording if released over ANY revealed number cell
                           chord(x, y);
                      } else if (!cellData.isFlagged) {
                           // REVEALING: Reveal the cell under the cursor on release
                           revealCell(x, y);
                      }
                      // If cell is flagged, do nothing on left mouse release.
                  }
             }
             // If mouse released outside grid or not over a cell, do nothing.

             initialMouseDownCell = null; // Reset initial cell tracking after processing
             // pressedCellElement is already null

        } else if (event.button === 2) {
             // Handle right mouse button up - usually does nothing, but reset state just in case.
            isLeftMouseDown = false; // Reset left mouse state (though it should be false anyway)
             clearTimeout(mouseLongPressTimerId);
             mouseLongPressTimerId = null;
             if (pressedCellElement) {
                  pressedCellElement.classList.remove('pressed');
                  pressedCellElement = null;
             }
             initialMouseDownCell = null;
             longPressJustFinishedMouse = false;
        } else {
             // Handle other mouseup scenarios or mouseup when not dragging
             isLeftMouseDown = false; // Ensure state is reset
             if (pressedCellElement) {
                  pressedCellElement.classList.remove('pressed');
                  pressedCellElement = null;
             }
             clearTimeout(mouseLongPressTimerId);
             mouseLongPressTimerId = null;
             initialMouseDownCell = null;
             longPressJustFinishedMouse = false;
        }
    }


    // --- Game Logic ---

    function handleFirstClick(x, y) {
         if (!firstClick || gameOver) return;

         const attemptsSpan = document.getElementById('generation-attempts');
         attemptsSpan.textContent = ''; // Clear previous attempts count

         if (noGuessMode) {
             generationAttempts = 0;
             let solvable = false;
             console.log("No Guess Mode: Starting generation...");
             attemptsSpan.textContent = 'Generating...';
             setTimeout(() => { // Use setTimeout to avoid freezing UI
                 while (!solvable) {
                     generationAttempts++;
                     for (let r = 0; r < height; r++) {
                         for (let c = 0; c < width; c++) {
                            if(grid[r]?.[c]){
                                 grid[r][c].isMine = false;
                                 grid[r][c].adjacentMines = 0;
                            }
                         }
                     }
                     placeMines(x, y);
                     if (isSolvableWithoutGuessing(x, y)) {
                         solvable = true;
                         console.log(`No Guess Mode: Solvable grid found after ${generationAttempts} attempts.`);
                         attemptsSpan.textContent = `(${generationAttempts} attempts)`;
                         startTimer();
                         firstClick = false;
                         revealCell(x, y);
                     } else {
                        if (generationAttempts % 100 === 0) {
                            console.log(`No Guess Mode: Attempt ${generationAttempts}...`);
                            attemptsSpan.textContent = `Generating... (${generationAttempts})`;
                        }
                        if (generationAttempts > 5000) {
                             console.error(`No Guess Mode: Generation timed out after ${generationAttempts} attempts.`);
                             alert(`Failed to generate a solvable grid in No Guess Mode after ${generationAttempts} tries. Try reducing density or grid size, or disable No Guess Mode.`);
                             attemptsSpan.textContent = '(Generation Failed)';
                             restartGame();
                             return;
                        }
                     }
                 }
             }, 0);

         } else {
             // Normal mode
             placeMines(x, y);
             startTimer();
             firstClick = false;
             revealCell(x, y);
         }
     }

    function updateFlagMethod(cell, x, y) {
        if(!cell){
            for(let r = 0; r < height; r++){
                for(let c = 0; c < width; c++){
                    if (grid[r]?.[c]?.element) {
                       updateFlagMethod(grid[r][c].element, c, r);
                    }
                }
            }
            return;
        }
        cell.removeEventListener('touchstart', handleDoubleTapFlag);
        removeLongPressListener(cell);
        if (flagMethod === 'longPress') {
            addLongPressListener(cell, handleFlag);
        } else if (flagMethod === 'doubleTap') {
            cell.addEventListener('touchstart', handleDoubleTapFlag);
        }
    }

    function handleDoubleTapFlag(event){
        if(gameOver || flagMethod !== 'doubleTap') return;
        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;
        if(doubleTapFlagTimer === null){
            doubleTapFlagTimer = setTimeout(() => { doubleTapFlagTimer = null; }, 300);
        } else {
            clearTimeout(doubleTapFlagTimer);
            doubleTapFlagTimer = null;
            handleFlag(event);
            ignoreNextClick = true;
            if(pressedCellElement) { pressedCellElement.classList.remove('pressed'); pressedCellElement = null; }
            isLeftMouseDown = false;
        }
    }
    function handleDoubleTapChord(event){
        if(gameOver || chordMethod !== 'doubleTap') return;
        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;
        const x = parseInt(targetCell.dataset.x);
        const y = parseInt(targetCell.dataset.y);
        if (doubleTapChordTimer === null) {
            doubleTapChordTimer = setTimeout(() => { doubleTapChordTimer = null; }, 300);
        } else {
            clearTimeout(doubleTapChordTimer);
            doubleTapChordTimer = null;
            chord(x, y);
            ignoreNextClick = true;
        }
    }

    function placeMines(safeX, safeY) {
        let minesPlaced = 0;
        let availableSquares = [];
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                 let isSafe = false;
                 for(let dy = -1; dy <= 1; dy++){
                     for(let dx = -1; dx <= 1; dx++){
                         if(x === safeX + dx && y === safeY + dy){ isSafe = true; break; }
                     }
                     if(isSafe) break;
                 }
                 if (!isSafe) availableSquares.push({x, y});
            }
        }
        for (let i = availableSquares.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableSquares[i], availableSquares[j]] = [availableSquares[j], availableSquares[i]];
        }
        const minesToPlace = Math.min(numMines, availableSquares.length);
        for (let i = 0; i < minesToPlace; i++) {
            const { x, y } = availableSquares[i];
             if(grid[y]?.[x]) { grid[y][x].isMine = true; minesPlaced++; }
        }
         if (minesPlaced < numMines) console.warn(`Could only place ${minesPlaced}/${numMines} mines.`);
        calculateAdjacentMines();
    }

    function calculateAdjacentMines() {
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const cell = grid[y]?.[x];
                if (cell && !cell.isMine) {
                    let count = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const newX = x + dx; const newY = y + dy;
                            if (newX >= 0 && newX < width && newY >= 0 && newY < height && grid[newY]?.[newX]?.isMine) {
                                count++;
                            }
                        }
                    }
                    cell.adjacentMines = count;
                    if(cell.element) cell.element.dataset.adjacent = count;
                } else if (cell) {
                     cell.adjacentMines = -1;
                     if(cell.element) delete cell.element.dataset.adjacent;
                }
            }
        }
    }

    function revealCell(x, y) {
        if (isNaN(x) || isNaN(y) || x < 0 || x >= width || y < 0 || y >= height || gameOver) return;
        const cell = grid[y]?.[x];
        if (!cell || cell.isRevealed || cell.isFlagged) return;

        cell.isRevealed = true;
        cell.element.classList.remove('pressed', 'flagged');
        cell.element.classList.add('revealed');
        cell.element.textContent = '';

        if (cell.isMine) {
            cell.element.classList.add('mine');
            cell.element.textContent = "ðŸ’£";
            revealAllMines(x, y);
            showMessage("Game Over!");
            stopTimer();
        } else {
             cell.element.dataset.adjacent = cell.adjacentMines;
            if (cell.adjacentMines > 0) {
                cell.element.textContent = cell.adjacentMines;
            } else {
                 cell.element.textContent = '';
                // Non-recursive flood fill using a queue
                const revealQueue = [];
                 for (let dy = -1; dy <= 1; dy++) {
                     for (let dx = -1; dx <= 1; dx++) {
                          if (dx === 0 && dy === 0) continue;
                          const nextX = x + dx; const nextY = y + dy;
                          if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height) {
                              const neighborCell = grid[nextY]?.[nextX];
                              if(neighborCell && !neighborCell.isRevealed && !neighborCell.isFlagged){
                                 revealQueue.push({nx: nextX, ny: nextY});
                              }
                          }
                     }
                 }

                let processed = new Set([`${x},${y}`]);
                while(revealQueue.length > 0) {
                    const current = revealQueue.shift();
                    const currentX = current.nx; const currentY = current.ny;
                    const currentKey = `${currentX},${currentY}`;
                    if (processed.has(currentKey) || currentX < 0 || currentX >= width || currentY < 0 || currentY >= height) continue;

                    const currentCell = grid[currentY]?.[currentX];
                    if (!currentCell || currentCell.isRevealed || currentCell.isFlagged) {
                         processed.add(currentKey); continue;
                    }

                    processed.add(currentKey);
                    currentCell.isRevealed = true;
                    currentCell.element.classList.add('revealed');
                    currentCell.element.classList.remove('pressed', 'flagged');
                    currentCell.element.textContent = '';
                    currentCell.element.dataset.adjacent = currentCell.adjacentMines;

                    if (currentCell.adjacentMines > 0) {
                        currentCell.element.textContent = currentCell.adjacentMines;
                    } else {
                        currentCell.element.textContent = '';
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nextX = currentX + dx; const nextY = currentY + dy;
                                const nextKey = `${nextX},${nextY}`;
                                if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height && !processed.has(nextKey)) {
                                    const neighborCell = grid[nextY]?.[nextX];
                                    if(neighborCell && !neighborCell.isRevealed && !neighborCell.isFlagged){
                                        revealQueue.push({nx: nextX, ny: nextY});
                                    } else {
                                         processed.add(nextKey);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
       if (!gameOver) checkWin();
    }

    function handleClick(event) {
        if (ignoreNextClick) {
            ignoreNextClick = false; return;
        }
        if (gameOver) return;
        if (event.pointerType === 'mouse' && event.button === 0) return; // Mouse handled separately

        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;
        const x = parseInt(targetCell.dataset.x);
        const y = parseInt(targetCell.dataset.y);

        if (firstClick) {
             handleFirstClick(x, y); return;
        }

        const cell = grid[y]?.[x];
        if (!cell) return;

        if (cell.isRevealed) {
            if (chordMethod === 'doubleTap') handleDoubleTapChord(event);
            else chord(x, y);
        } else if (!cell.isFlagged) {
             if (flagMethod === 'doubleTap') {
                  if (doubleTapFlagTimer === null) revealCell(x, y);
             } else {
                 revealCell(x, y);
             }
        }
    }

    function handleFlag(event) {
      if (gameOver) return;
      const targetCell = event.target.closest('.cell');
      if (!targetCell) return;
      const x = parseInt(targetCell.dataset.x);
      const y = parseInt(targetCell.dataset.y);
      const cell = grid[y]?.[x];
      if (!cell || cell.isRevealed) return;

      if (cell.isFlagged) {
          cell.isFlagged = false;
          cell.element.classList.remove('flagged');
          cell.element.textContent = '';
          minesLeft++;
      } else if (minesLeft > 0) {
          cell.isFlagged = true;
          cell.element.classList.add('flagged');
          cell.element.textContent = 'ðŸš©';
          minesLeft--;
      }
      updateMinesLeftDisplay();
      checkWin(); // Check win only needed if maybe all mines flagged now
    }

     function chord(x, y){
        if (isNaN(x) || isNaN(y) || x < 0 || x >= width || y < 0 || y >= height || gameOver) return;
        const cell = grid[y]?.[x];
        if(!cell || !cell.isRevealed || cell.adjacentMines <= 0) return;

        let flaggedNeighbors = 0;
        let unknownAndUnflaggedNeighbors = [];
         for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const newX = x + dx; const newY = y + dy;
                 if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                      const neighbor = grid[newY]?.[newX];
                      if (neighbor) {
                          if (neighbor.isFlagged) flaggedNeighbors++;
                          else if (!neighbor.isRevealed) unknownAndUnflaggedNeighbors.push({x: newX, y: newY});
                      }
                 }
            }
          }
         if(flaggedNeighbors === cell.adjacentMines){
             unknownAndUnflaggedNeighbors.forEach(pos => revealCell(pos.x, pos.y));
         }
         // revealCell calls checkWin if game state changes
     }

     function revealAllMines(clickedX, clickedY) {
        if (gameOver) return;
        gameOver = true;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                 const cell = grid[y]?.[x];
                 if (cell?.element) {
                     cell.element.classList.remove('pressed');
                     if (cell.isMine) {
                         if (!cell.isFlagged) { // Only reveal unflagged mines
                             cell.element.classList.add('mine-revealed');
                             cell.element.textContent = "ðŸ’£";
                             if (x === clickedX && y === clickedY) {
                                 cell.element.classList.add('mine'); // Special style for the hit mine
                             }
                         }
                     } else if (cell.isFlagged) { // Incorrectly flagged non-mine
                         cell.element.classList.remove('flagged');
                         cell.element.classList.add('incorrect-flag');
                         cell.element.textContent = 'X';
                     }
                 }
            }
        }
    }

    function checkWin() {
      if (gameOver || firstClick) return; // Already over or not started

      let revealedCount = 0;
      let mineCount = 0; // Count actual mines on the grid for this check
      let unrevealedNonMines = 0; // Count hidden safe squares

      for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
              const cell = grid[y]?.[x];
              if (!cell) continue; // Skip if cell data doesn't exist

              if (cell.isMine) {
                  mineCount++;
              } else { // If it's not a mine
                  if (cell.isRevealed) {
                      revealedCount++;
                  } else { // Count hidden (unrevealed & potentially flagged) non-mines
                       unrevealedNonMines++;
                  }
              }
          }
      }

       // Use the *expected* number of mines for win condition checks
       const effectiveMineCount = numMines; // Use the game setting
       if (mineCount !== effectiveMineCount && mineCount > 0) { // Only warn if mines have been placed and differ
           console.warn(`Internal mine count (${mineCount}) differs from setting (${effectiveMineCount}). Using setting for win check.`);
       }

      // Standard Win Condition: All non-mine squares are revealed.
      const totalSquares = width * height;
      const expectedNonMineSquares = totalSquares - effectiveMineCount;

      // Check if the number of revealed squares equals the total number of non-mine squares.
      // Also ensure there are no unrevealed non-mines left.
      if (revealedCount === expectedNonMineSquares && unrevealedNonMines === 0) {
            // If this condition is met, all safe squares are open. Trigger win.
            winGame(true); // Auto-flag remaining mines (if any) and declare win.
      }
      // No other win conditions. Flagging all mines does not trigger a win.
    }

    function winGame(autoFlag = false) {
        if (gameOver) return;
        gameOver = true;
        stopTimer();
        console.log("Win condition met!");
        let flagsToPlace = 0;
        if (autoFlag) {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = grid[y]?.[x];
                    if (cell?.isMine && !cell.isFlagged && !cell.isRevealed) {
                        cell.isFlagged = true;
                        if(cell.element) {
                            cell.element.classList.add('flagged');
                            cell.element.textContent = 'ðŸš©';
                        }
                        flagsToPlace++;
                    }
                }
            }
             minesLeft = 0;
             updateMinesLeftDisplay();
        }
        flagIncorrectlyPlaced();
        updateLeaderboard();
        showMessage("You Win! Time: " + time + " seconds");
        if (pressedCellElement) { pressedCellElement.classList.remove('pressed'); pressedCellElement = null; }
        isLeftMouseDown = false;
    }

    function flagIncorrectlyPlaced(){
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                 const cell = grid[y]?.[x];
                 if (cell?.isFlagged && !cell.isMine) {
                    if(cell.element){
                        cell.element.classList.remove('flagged');
                        cell.element.classList.add('incorrect-flag');
                        cell.element.textContent = 'X';
                    }
                 }
            }
        }
    }

    function startTimer() {
        if (!gameStarted) {
            gameStarted = true; time = 0; updateTimerDisplay();
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (!gameOver) { time++; updateTimerDisplay(); }
                else { stopTimer(); }
            }, 1000);
        }
    }
    function stopTimer() { clearInterval(timerInterval); }

    // --- Touch / Long Press Handling ---
   function addLongPressListener(element, callback) {
       let elementTouchTimerId = null; longPressFlaggedThisTouch = false;
       let startX, startY;
       const handleTouchStart = (e) => {
           if (e.touches.length === 1 && elementTouchTimerId === null) {
               longPressFlaggedThisTouch = false; ignoreNextClick = false;
               startX = e.touches[0].clientX; startY = e.touches[0].clientY;
               elementTouchTimerId = setTimeout(() => {
                   longPressFlaggedThisTouch = true; callback(e); ignoreNextClick = true;
                   elementTouchTimerId = null; e.preventDefault();
                   const tc = e.target.closest('.cell'); if (tc) tc.classList.remove('pressed');
               }, longPressDelay);
                const tc = e.target.closest('.cell');
                if (tc && !tc.classList.contains('revealed') && !tc.classList.contains('flagged')) {
                    tc.classList.add('pressed');
                }
           }
       };
       const handleTouchEnd = (e) => {
            const tc = e.target.closest('.cell'); if (tc) tc.classList.remove('pressed');
           if (elementTouchTimerId !== null) { clearTimeout(elementTouchTimerId); elementTouchTimerId = null; }
           if (longPressFlaggedThisTouch) { longPressFlaggedThisTouch = false; e.preventDefault(); }
       };
       const handleTouchMove = (e) => {
           if (elementTouchTimerId !== null) {
                 const currentX = e.touches[0].clientX; const currentY = e.touches[0].clientY;
                 const deltaX = Math.abs(currentX - startX); const deltaY = Math.abs(currentY - startY);
                 if (deltaX > 10 || deltaY > 10) {
                     clearTimeout(elementTouchTimerId); elementTouchTimerId = null;
                     longPressFlaggedThisTouch = false; ignoreNextClick = false;
                     const tc = e.target.closest('.cell'); if (tc) tc.classList.remove('pressed');
                 }
           }
       };
        element.addEventListener('touchstart', handleTouchStart, { passive: false });
        element.addEventListener('touchend', handleTouchEnd, { passive: false });
        element.addEventListener('touchmove', handleTouchMove, { passive: false });
       element._touchStartHandler = handleTouchStart; element._touchEndHandler = handleTouchEnd; element._touchMoveHandler = handleTouchMove;
        const handleMouseLeave = () => {
             clearTimeout(mouseLongPressTimerId); mouseLongPressTimerId = null;
             longPressJustFinishedMouse = false;
             if (isLeftMouseDown && pressedCellElement === element) {
                element.classList.remove('pressed'); pressedCellElement = null;
             }
        };
        element.addEventListener('mouseleave', handleMouseLeave);
        element._mouseLeaveHandlerLP = handleMouseLeave;
   }
   function removeLongPressListener(element) {
        if (element._touchStartHandler) { element.removeEventListener('touchstart', element._touchStartHandler, { passive: false }); delete element._touchStartHandler; }
        if (element._touchEndHandler) { element.removeEventListener('touchend', element._touchEndHandler, { passive: false }); delete element._touchEndHandler; }
        if (element._touchMoveHandler) { element.removeEventListener('touchmove', element._touchMoveHandler, { passive: false }); delete element._touchMoveHandler; }
        if (element._mouseLeaveHandlerLP) { element.removeEventListener('mouseleave', element._mouseLeaveHandlerLP); delete element._mouseLeaveHandlerLP; }
    }

    // --- Settings / UI ---
    function toggleSettings() {
        const settingsPanel = document.getElementById('settings-panel');
        const overlay = document.getElementById('overlay');
        const attemptsSpan = document.getElementById('generation-attempts');
        if(settingsPanel.style.display === "block") {
            settingsPanel.style.display = "none"; overlay.style.display = 'none';
             if (noGuessMode && firstClick && generationAttempts > 0) attemptsSpan.textContent = `(${generationAttempts} attempts)`;
             else attemptsSpan.textContent = '';
        } else {
            settingsPanel.style.display = "block"; overlay.style.display = 'block';
            document.getElementById('long-press-delay-value').textContent = longPressDelay;
             const widthInput = document.getElementById('width'); const heightInput = document.getElementById('height'); const minesInput = document.getElementById('mines');
            if (currentDifficulty === 'custom') {
               document.querySelector('.custom-settings').classList.add('active');
                const maxMines = (parseInt(widthInput.value) * parseInt(heightInput.value)) - 9;
                minesInput.max = maxMines > 0 ? maxMines : 1;
            } else {
               document.querySelector('.custom-settings').classList.remove('active');
                const maxMinesStd = (width * height) - 9; minesInput.max = maxMinesStd > 0 ? maxMinesStd : 1;
            }
             attemptsSpan.textContent = '';
        }
    }
    function updateTimerDisplay(){ const e = document.querySelector('#timer > div:nth-child(2)'); if (e) e.textContent = time; }
    function updateMinesLeftDisplay(){ const e = document.querySelector('#mines-left > div:nth-child(2)'); if (e) e.textContent = minesLeft < 0 ? 0 : minesLeft; }

    function setDifficulty(difficulty) {
      currentDifficulty = difficulty;
      const customSettings = document.querySelector('.custom-settings');
      const minesInput = document.getElementById('mines'); const widthInput = document.getElementById('width'); const heightInput = document.getElementById('height');
      document.getElementById('generation-attempts').textContent = '';
      switch (difficulty) {
        case 'beginner': width = 9; height = 9; numMines = 10; customSettings.classList.remove('active'); break;
        case 'intermediate': width = 16; height = 16; numMines = 40; customSettings.classList.remove('active'); break;
        case 'expert': width = 30; height = 16; numMines = 99; customSettings.classList.remove('active'); break;
        case 'custom':
          customSettings.classList.add('active');
            widthInput.value = width; heightInput.value = height; minesInput.value = numMines;
            const maxMinesCustom = (width * height) - 9; minesInput.max = maxMinesCustom > 0 ? maxMinesCustom : 1;
            return;
      }
        widthInput.value = width; heightInput.value = height; minesInput.value = numMines;
        const maxMinesStandard = (width * height) - 9; minesInput.max = maxMinesStandard > 0 ? maxMinesStandard : 1;
        localStorage.setItem('currentDifficulty', currentDifficulty); localStorage.setItem('width', width); localStorage.setItem('height', height); localStorage.setItem('numMines', numMines);
        minesLeft = numMines;
        restartGame();
    }

   function applySettings() {
        const widthInput = document.getElementById('width'); const heightInput = document.getElementById('height'); const minesInput = document.getElementById('mines');
        if (currentDifficulty === 'custom') {
            const newWidth = parseInt(widthInput.value); const newHeight = parseInt(heightInput.value); const newNumMines = parseInt(minesInput.value);
             if (isNaN(newWidth) || newWidth < 5 || newWidth > 50) { alert('Width must be between 5 and 50.'); return; }
             if (isNaN(newHeight) || newHeight < 5 || newHeight > 50) { alert('Height must be between 5 and 50.'); return; }
             const maxMines = (newWidth * newHeight) - 9; minesInput.max = maxMines > 0 ? maxMines : 1;
             if (isNaN(newNumMines) || newNumMines < 1 || newNumMines > maxMines) { alert(`Mines must be between 1 and ${maxMines}.`); return; }
             width = newWidth; height = newHeight; numMines = newNumMines;
        } else {
              switch (currentDifficulty) {
                  case 'beginner': width = 9; height = 9; numMines = 10; break;
                  case 'intermediate': width = 16; height = 16; numMines = 40; break;
                  case 'expert': width = 30; height = 16; numMines = 99; break;
              }
               widthInput.value = width; heightInput.value = height; minesInput.value = numMines;
               const maxMinesStd = (width * height) - 9; minesInput.max = maxMinesStd > 0 ? maxMinesStd : 1;
        }
        playerName = document.getElementById('player-name').value.trim() || "Player"; localStorage.setItem('playerName', playerName); document.getElementById('player-name').value = playerName;
        const lightModeCheckbox = document.getElementById('light-mode');
        flagMethod = document.getElementById('flag-method').value;
        longPressDelay = parseInt(document.getElementById('long-press-delay').value);
        chordMethod = document.getElementById('chord-method').value;
        noGuessMode = document.getElementById('no-guess-mode').checked;

        localStorage.setItem('darkMode', lightModeCheckbox.checked ? 'enabled' : 'disabled');
        localStorage.setItem('flagMethod', flagMethod);
        localStorage.setItem('longPressDelay', longPressDelay);
        localStorage.setItem('chordMethod', chordMethod);
        localStorage.setItem('noGuessMode', noGuessMode);
        localStorage.setItem('currentDifficulty', currentDifficulty);
        localStorage.setItem('width', width);
        localStorage.setItem('height', height);
        localStorage.setItem('numMines', numMines);

        // Update theme and logo based on light mode state
        const logoElement = document.getElementById('logo');
        if (lightModeCheckbox.checked) {
            document.body.classList.add('light-mode');
            document.getElementById('settings-panel').style.backgroundColor="white";
            document.getElementById('message-box').style.backgroundColor="white";
            if (logoElement) logoElement.src = "/LightModeLogo.svg"; // Set light mode logo
        } else {
            document.body.classList.remove('light-mode');
            document.getElementById('settings-panel').style.backgroundColor="var(--container-bg)";
            document.getElementById('message-box').style.backgroundColor="var(--container-bg)";
             if (logoElement) logoElement.src = "/DarkModeLogo.svg"; // Set dark mode logo
        }

        minesLeft = numMines; restartGame(); toggleSettings();
    }
    function showMessage(message) { document.getElementById('message-text').textContent = message; document.getElementById('message-box').style.display = 'block'; document.getElementById('overlay').style.display = 'block'; }
    function restartGame() {
        stopTimer(); time = 0; updateTimerDisplay(); gameStarted = false; firstClick = true; gameOver = false; minesLeft = numMines; updateMinesLeftDisplay(); generationAttempts = 0;
        const attemptsSpan = document.getElementById('generation-attempts'); if(attemptsSpan) attemptsSpan.textContent = '';
        ignoreNextClick = false; longPressFlaggedThisTouch = false; longPressJustFinishedMouse = false; isLeftMouseDown = false;
        if (pressedCellElement) { pressedCellElement.classList.remove('pressed'); pressedCellElement = null; } initialMouseDownCell = null;
        clearTimeout(touchLongPressTimerId); touchLongPressTimerId = null; clearTimeout(mouseLongPressTimerId); mouseLongPressTimerId = null; clearTimeout(doubleTapFlagTimer); doubleTapFlagTimer = null; clearTimeout(doubleTapChordTimer); doubleTapChordTimer = null;
        document.removeEventListener('mouseup', handleDocumentMouseUp);
        createGrid();
        document.getElementById('message-box').style.display = 'none'; document.getElementById('overlay').style.display = 'none';
        updateFlagMethod();
    }
    document.getElementById('long-press-delay').addEventListener('input', (event) => { document.getElementById('long-press-delay-value').textContent = event.target.value; longPressDelay = parseInt(event.target.value); });

    // --- Leaderboard Handling ---
    function getLeaderboardDifficultyString() { if (currentDifficulty === 'custom') return null; let ds = currentDifficulty; if (noGuessMode) ds += "_noguess"; return ds; }
    function updateLeaderboard() {
        const difficultyString = getLeaderboardDifficultyString(); if (!difficultyString) { console.log("Score not submitted for custom."); return; }
         const currentName = document.getElementById('player-name').value.trim();
          if (!currentName || currentName.toLowerCase() === "player") {
              console.log(`Score not submitted for ${difficultyString}: Enter name.`);
              let bt = localStorage.getItem(`leaderboard-${difficultyString}`); if (bt === null || time < parseInt(bt)) { localStorage.setItem(`leaderboard-${difficultyString}`, time); bt = time; }
              const td = document.getElementById(`leaderboard-${difficultyString}-local`); if (td) td.textContent = bt === null ? '-' : bt + 's'; return;
          }
         db.collection('leaderboard').add({ playerName: currentName, difficulty: difficultyString, score: time, timestamp: firebase.firestore.FieldValue.serverTimestamp() })
             .then(() => { console.log(`Score submitted for ${difficultyString}!`); loadOnlineLeaderboard(); })
             .catch((error) => { console.error(`Error submitting score for ${difficultyString}: `, error); document.getElementById('leaderboard-error').textContent='Error submitting score.'; document.getElementById('leaderboard-error').style.display='block'; });
         let bt = localStorage.getItem(`leaderboard-${difficultyString}`); if (bt === null || time < parseInt(bt)) { localStorage.setItem(`leaderboard-${difficultyString}`, time); bt = time; }
         const td = document.getElementById(`leaderboard-${difficultyString}-local`); if (td) td.textContent = bt === null ? '-' : bt + 's';
    }
    async function fetchScoresRecursive(difficulty, targetCount, collectedScores = [], lastVisible = null) {
        let q = db.collection('leaderboard').where('difficulty', '==', difficulty).where('score', '>', 1).orderBy('score', 'asc');
        if (lastVisible) q = q.startAfter(lastVisible);
        q = q.limit(targetCount);
        try {
            const snaps = await q.get(); const nextLastVisible = snaps.docs[snaps.docs.length - 1]; let added = 0;
            snaps.forEach((doc) => {
                const data = doc.data();
                if (typeof data.score === 'number' && data.score > 0 && typeof data.playerName === 'string' && collectedScores.length < targetCount) { collectedScores.push(data); added++; }
                 else console.warn("Skipping invalid score data:", data);
            });
            if (collectedScores.length < targetCount && added > 0 && nextLastVisible && snaps.docs.length === targetCount) {
                return fetchScoresRecursive(difficulty, targetCount - collectedScores.length, collectedScores, nextLastVisible);
            } else { collectedScores.sort((a, b) => a.score - b.score); return collectedScores; }
        } catch (error) { console.error(`Error fetching ${difficulty}:`, error); const eDiv=document.getElementById('leaderboard-error'); if(eDiv){eDiv.textContent=`Error loading ${difficulty}.`; eDiv.style.display='block';} return collectedScores; }
    }
    async function loadOnlineLeaderboard() {
        const loadingDiv = document.getElementById('leaderboard-loading'); const errorDiv = document.getElementById('leaderboard-error');
        loadingDiv.style.display = 'block'; errorDiv.style.display = 'none';
        const difficulties = ['beginner', 'intermediate', 'expert', 'beginner_noguess', 'intermediate_noguess', 'expert_noguess'];
        const targetScoreCount = 10;
        difficulties.forEach(d => { const lb = document.getElementById(`leaderboard-${d}`); if(lb) lb.innerHTML = ''; });
        try {
            const promises = difficulties.map(async (difficulty) => {
                const lb = document.getElementById(`leaderboard-${difficulty}`); if (!lb) return;
                lb.innerHTML = '<tr><td colspan="3">Loading...</td></tr>';
                const scores = await fetchScoresRecursive(difficulty, targetScoreCount, []);
                lb.innerHTML = '';
                if (scores.length > 0) { let rank = 1; scores.forEach((data) => { const r = lb.insertRow(); r.insertCell().textContent = rank++; const nc = r.insertCell(); nc.textContent = String(data.playerName||'Anon').substring(0, 20); r.insertCell().textContent = data.score + 's'; }); }
                 else lb.innerHTML = '<tr><td colspan="3">No scores yet.</td></tr>';
            });
            await Promise.all(promises); loadingDiv.style.display = 'none';
        } catch (error) { console.error("Leaderboard loading error:", error); loadingDiv.style.display = 'none'; if (errorDiv.style.display === 'none') { errorDiv.textContent = 'Error loading leaderboards.'; errorDiv.style.display = 'block'; } }
    }
    function loadLeaderboard() { const difficulties = ['beginner','intermediate','expert','beginner_noguess','intermediate_noguess','expert_noguess']; difficulties.forEach(d => { const bt = localStorage.getItem(`leaderboard-${d}`); const td = document.getElementById(`leaderboard-${d}-local`); if (td) td.textContent = bt === null ? '-' : bt + 's'; }); }
    function loadSettings() {
      playerName = localStorage.getItem('playerName') || 'Player'; document.getElementById('player-name').value = playerName;
      const savedDarkMode = localStorage.getItem('darkMode'); const lightModeCheckbox = document.getElementById('light-mode');
       const logoElement = document.getElementById('logo'); // Get logo element here
      if (savedDarkMode === 'enabled') {
          document.body.classList.add('light-mode');
          lightModeCheckbox.checked = true;
          document.getElementById('settings-panel').style.backgroundColor="white";
          document.getElementById('message-box').style.backgroundColor="white";
          if (logoElement) logoElement.src = "/LightModeLogo.svg"; // Set light mode logo
      }
      else {
          document.body.classList.remove('light-mode');
          lightModeCheckbox.checked = false;
          document.getElementById('settings-panel').style.backgroundColor="var(--container-bg)";
          document.getElementById('message-box').style.backgroundColor="var(--container-bg)";
           if (logoElement) logoElement.src = "/DarkModeLogo.svg"; // Set dark mode logo
      }

      flagMethod = localStorage.getItem('flagMethod') || 'longPress'; document.getElementById('flag-method').value = flagMethod; longPressDelay = parseInt(localStorage.getItem('longPressDelay')) || 500; document.getElementById('long-press-delay').value = longPressDelay; document.getElementById('long-press-delay-value').textContent = longPressDelay; chordMethod = localStorage.getItem('chordMethod') || 'singleTap'; document.getElementById('chord-method').value = chordMethod; noGuessMode = localStorage.getItem('noGuessMode') === 'true'; document.getElementById('no-guess-mode').checked = noGuessMode; document.getElementById('generation-attempts').textContent = '';
      currentDifficulty = localStorage.getItem('currentDifficulty') || 'beginner'; width = parseInt(localStorage.getItem('width')) || 9; height = parseInt(localStorage.getItem('height')) || 9; numMines = parseInt(localStorage.getItem('numMines')) || 10;
      const minesInput = document.getElementById('mines'); const widthInput = document.getElementById('width'); const heightInput = document.getElementById('height');
       setDifficulty(currentDifficulty); // This handles non-custom restart
      if (currentDifficulty === 'custom') { // Handle custom load
           widthInput.value = width; heightInput.value = height; minesInput.value = numMines;
           const maxMines = (width * height) - 9; minesInput.max = maxMines > 0 ? maxMines : 1; document.querySelector('.custom-settings').classList.add('active');
           minesLeft = numMines; restartGame(); // Manual restart for custom
      }
      updateFlagMethod();
    }

    // --- No Guess Mode Solver Logic (unchanged) ---
    function getNeighbors(x, y, W, H) { const n = []; for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) { if (dx === 0 && dy === 0) continue; const nx = x + dx, ny = y + dy; if (nx >= 0 && nx < W && ny >= 0 && ny < H) n.push({ x: nx, y: ny }); } return n; }
     function isSolvableWithoutGuessing(startX, startY) {
         const solverGrid = Array(height).fill(null).map(() => Array(width).fill(null).map(() => ({ state: -2 })));
         let revealedCount = 0; let minesFound = 0; const totalNonMines = (width * height) - numMines; const processQueue = []; const W = width; const H = height;
         const solverReveal = (x, y) => { if (x < 0 || x >= W || y < 0 || y >= H || solverGrid[y]?.[x]?.state !== -2) return false; const cd = grid[y]?.[x]; if (!cd || cd.isMine) return false; const adj = cd.adjacentMines; solverGrid[y][x].state = adj; revealedCount++; if (adj === 0) getNeighbors(x, y, W, H).forEach(n => { if (solverGrid[n.y]?.[n.x]?.state === -2) processQueue.push(n); }); return true; };
         const solverFlag = (x, y) => { if (x < 0 || x >= W || y < 0 || y >= H || solverGrid[y]?.[x]?.state !== -2) return false; const cd = grid[y]?.[x]; if (!cd || !cd.isMine) return false; solverGrid[y][x].state = -1; minesFound++; return true; };
         for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) { const cx=startX+dx, cy=startY+dy; if (cx>=0 && cx<W && cy>=0 && cy<H) solverReveal(cx, cy); }
         let madeProgress = true;
         while (madeProgress) {
             madeProgress = false;
             while (processQueue.length > 0) { const { x, y } = processQueue.shift(); if (solverGrid[y]?.[x]?.state === -2 && solverReveal(x, y)) madeProgress = true; }
             let innerProgress = true;
             while(innerProgress){
                 innerProgress = false;
                 for (let y = 0; y < H; y++) { for (let x = 0; x < W; x++) { if (!solverGrid[y]?.[x]) continue; const cs = solverGrid[y][x].state; if (cs >= 1 && cs <= 8) { const ng = getNeighbors(x, y, W, H); let unk = []; let flg = 0; ng.forEach(n => { const ns = solverGrid[n.y]?.[n.x]?.state; if (ns === -2) unk.push(n); else if (ns === -1) flg++; }); if (flg === cs && unk.length > 0) { unk.forEach(n => { if (solverReveal(n.x, n.y)) { innerProgress = true; madeProgress = true; } }); if(innerProgress) continue; } if (unk.length > 0 && flg + unk.length === cs) { let fail = false; unk.forEach(n => { if (!solverFlag(n.x, n.y)) fail = true; else { innerProgress = true; madeProgress = true; } }); if(fail) return false; if(innerProgress) continue; } } } }
                 while (processQueue.length > 0) { const { x, y } = processQueue.shift(); if (solverGrid[y]?.[x]?.state === -2 && solverReveal(x, y)) { innerProgress = true; madeProgress = true; } }
             }
         }
         return revealedCount === totalNonMines;
     }

    // --- Initialize ---
    loadSettings(); loadLeaderboard(); loadOnlineLeaderboard();
    </script>
</body>
</html>
