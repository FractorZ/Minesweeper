<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Min3s – Mobile Minesweeper Game No Guess with Leaderboards</title>
    <meta name="description" content="Play Minesweeper online at Min3s.click! No ads, Mobile‑friendly, no‑guess mode, and live global leaderboard.">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <!-- Firebase App (include only once) -->
    <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-app-compat.js"></script>
    <!-- Firebase Firestore -->
    <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-firestore-compat.js"></script>
    <style>
        /* Base Styles (Dark Mode - Now Default) */
        :root {
            --bg-color: #333;
            --container-bg: #444;
            --grid-border-color: #666;
            --grid-bg-color: #555;
            --cell-bg-color: #666;
            --cell-border-color: #777;
            --revealed-cell-bg: #555;
            --revealed-cell-border: #888;
            --flagged-cell-bg: #4682B4; /* Steel Blue */
            --flagged-cell-color: #FFD700; /* Gold */
            --mine-bg-color: #B22222; /* Firebrick - Not used directly, see .mine */
            --mine-revealed-bg: #800000; /* Maroon */
            --mine-revealed-color: white;
            --incorrect-flag-bg: #A0522D; /* Sienna */
            --incorrect-flag-color: white;
            --text-color: white;
            --button-bg: #3e8e41;
            --button-hover-bg: #2e6e31;
            --button-text-color: white;
            --control-border-color: #aaa;
            --control-bg-color: #444;
            --cell-pressed-bg: #777; /* Added style for pressed cell */
            --input-bg-color: #555; /* Added for inputs */
            --input-border-color: #777; /* Added for inputs */
            --input-text-color: white; /* Added for inputs */
            --settings-panel-width: 300px; /* Width for the side panel */

             /* Dark mode number colors (lighter) */
            --num-1-color-dark: #ADD8E6; /* Light Blue */
            --num-2-color-dark: #90EE90; /* Light Green */
            --num-3-color-dark: #F08080; /* Light Coral */
            --num-4-color-dark: #B0C4DE; /* Light Steel Blue */
            --num-5-color-dark: #FFA07A; /* Light Salmon */
            --num-6-color-dark: #20B2AA; /* Light Sea Green */
            --num-7-color-dark: #E6E6FA; /* Lavender (lighter than grey) */
            --num-8-color-dark: #D3D3D3; /* Light Gray */
        }

        /* Light Mode Styles */
        .light-mode {
            --bg-color: #e0e0e0;
            --container-bg: white;
            --grid-border-color: #a0a0a0;
            --grid-bg-color: #c0c0c0;
            --cell-bg-color: #d0d0d0;
            --cell-border-color: #f0f0f0;
            --revealed-cell-bg: #f8f8f8;
            --revealed-cell-border: #909090;
            --flagged-cell-bg: #87CEEB; /* Sky Blue */
            --flagged-cell-color: #B22222; /* Firebrick */
            /* --mine-bg-color: #F08080; */ /* Light Coral - Not used directly */
            --mine-revealed-bg: #DC143C; /* Crimson */
            --mine-revealed-color: white;
            --incorrect-flag-bg: #FFD700; /* Gold */
            --incorrect-flag-color: black;
            --text-color: black;
            --button-bg: #4CAF50;
            --button-hover-bg: #3e8e41;
            --button-text-color: white;
            --control-border-color: #808080;
            --control-bg-color: #f0f0f0;
            --cell-pressed-bg: #e8e8e8; /* Added style for pressed cell */
            --input-bg-color: #fdfdfd; /* Added for inputs */
            --input-border-color: #bbb; /* Added for inputs */
            --input-text-color: black; /* Added for inputs */
        }


        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to the top */
            min-height: 100vh;
            margin: 0;
            padding-top: 20px; /* Add some padding at the top */
            background-color: var(--bg-color);
            color: var(--text-color);
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation; /* Prevent double-tap zoom */
            box-sizing: border-box;
        }
         #game-container {
            display: flex;
            flex-direction: column;
            align-items: center; /* Center the header-area and grid */
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            overflow: visible; /* Allow difficulty dropdown to overflow visually */
            background-color: var(--container-bg);
            padding: 15px; /* Increased padding slightly */
            position: relative; /* Needed for absolute positioning if used, but flex is fine */
        }

        /* Style for the header area containing logo and controls */
        #header-area {
            display: flex;
            align-items: center; /* Vertically align items */
            justify-content: center; /* Center the items horizontally */
            width: 100%; /* Take full width of the container */
            margin-bottom: 15px; /* Space below the header area */
            padding: 0;
            transition: gap 0.3s ease; /* Add smooth transition for gap changes */
        }

         /* CSS for dynamic header gap */
        #header-area.header-gap-small { gap: 20px; }
        #header-area.header-gap-medium { gap: 50px; }
        #header-area.header-gap-large { gap: 100px; }

        /* CSS for dynamic controls gap */
        #controls.controls-gap-small { gap: 10px; }
        #controls.controls-gap-medium { gap: 25px; }
        #controls.controls-gap-large { gap: 40px; }


        #logo {
            height: 70px;
            flex-shrink: 0;
        }

        /* New Difficulty Selector Area */
        #difficulty-selector-area {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px; /* Space below the dropdown */
            width: 100%;
        }

        #difficulty-selector-area label {
            margin-right: 10px;
            font-weight: bold;
        }

        #difficulty-selector {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--control-border-color);
            background-color: var(--input-bg-color);
            color: var(--text-color);
            font-size: 1em;
            cursor: pointer;
        }
        #difficulty-selector:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--button-bg);
        }


        #grid-container {
            display: grid;
            grid-gap: 1px;
            border: 3px solid var(--grid-border-color);
            background-color: var(--grid-bg-color);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
             user-select: none;
             -webkit-tap-highlight-color: transparent;
        }

        .cell {
            width: 28px;
            height: 28px;
            background-color: var(--cell-bg-color);
            border: 2px outset var(--cell-border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            transition: background-color 0.1s; /* Faster transition */
        }
        .cell.pressed { /* Style for when left mouse is down */
            background-color: var(--cell-pressed-bg);
            border-style: inset; /* Give pressed appearance */
        }
        .cell.revealed {
            border: 1px solid var(--revealed-cell-border);
            background-color: var(--revealed-cell-bg);
            cursor: default;
        }
        .cell.flagged {
            background-color: var(--flagged-cell-bg);
            color: var(--flagged-cell-color);
        }
        .cell.mine { /* Style for the mine hit that ends the game */
             background-color: red !important; /* Make it stand out */
             color: white;
        }
        .cell.mine-revealed { /* Style for other mines shown on loss */
            background-color: var(--mine-revealed-bg);
            color: var(--mine-revealed-color);
        }
        .cell.incorrect-flag {
            background-color: var(--incorrect-flag-bg);
            color: var(--incorrect-flag-color);
        }

        /* Dark Mode Number colors */
        .cell[data-adjacent="1"] { color: var(--num-1-color-dark); }
        .cell[data-adjacent="2"] { color: var(--num-2-color-dark); }
        .cell[data-adjacent="3"] { color: var(--num-3-color-dark); }
        .cell[data-adjacent="4"] { color: var(--num-4-color-dark); }
        .cell[data-adjacent="5"] { color: var(--num-5-color-dark); }
        .cell[data-adjacent="6"] { color: var(--num-6-color-dark); }
        .cell[data-adjacent="7"] { color: var(--num-7-color-dark); }
        .cell[data-adjacent="8"] { color: var(--num-8-color-dark); }

        /* Light mode number colors (standard/original) */
        .light-mode .cell[data-adjacent="1"] { color: blue; }
        .light-mode .cell[data-adjacent="2"] { color: green; }
        .light-mode .cell[data-adjacent="3"] { color: red; }
        .light-mode .cell[data-adjacent="4"] { color: navy; }
        .light-mode .cell[data-adjacent="5"] { color: maroon; }
        .light-mode .cell[data-adjacent="6"] { color: teal; }
        .light-mode .cell[data-adjacent="7"] { color: black; }
        .light-mode .cell[data-adjacent="8"] { color: gray; }


        #controls {
            display: flex;
            /* gap: 10px; -- Removed fixed gap, now controlled by classes */
            margin-bottom: 0;
            align-items: center;
            flex-shrink: 0;
            transition: gap 0.3s ease; /* Add smooth transition for gap changes */
        }

        #timer, #mines-left {
            font-size: 1.1em;
            font-weight: bold;
            padding: 6px 12px;
            border: 2px solid var(--control-border-color);
            background-color: var(--control-bg-color);
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 80px; /* Increased min-width to accommodate decimals */
            text-align: center;
        }
        #timer-label, #mines-left-label {
            font-size: 0.8em;
            color: var(--text-color);
            margin-bottom: 2px;
        }

        /* REMOVED OLD SETTINGS BUTTON DIV */
        /* #settings {
            margin-top: 20px;
        } */

        /* Settings Toggle Button (New Side Button) */
        #settings-toggle-button {
            position: fixed;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            writing-mode: vertical-rl; /* Rotate text */
            text-orientation: mixed;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            padding: 15px 8px;
            font-size: 1.1em;
            cursor: pointer;
            border-radius: 8px 0 0 8px; /* Rounded corners on the left */
            box-shadow: -2px 0px 5px rgba(0,0,0,0.2);
            z-index: 1005; /* Above game, below panel overlay */
            transition: background-color 0.3s;
        }

        #settings-toggle-button:hover {
            background-color: var(--button-hover-bg);
        }

         /* Settings Panel (New Side Panel) */
        #settings-panel {
            display: block; /* Always block, position controls visibility */
            position: fixed;
            top: 0;
            right: calc(-1 * var(--settings-panel-width) - 10px); /* Start hidden off-screen */
            width: var(--settings-panel-width);
            height: 100vh; /* Full viewport height */
            background-color: var(--container-bg);
            color: var(--text-color);
            padding: 25px;
            border-left: 2px solid var(--grid-border-color); /* Border on the visible edge */
            box-shadow: -5px 0px 15px rgba(0,0,0,0.3);
            z-index: 1010; /* Above toggle button and overlay */
            overflow-y: auto;  /* Enable vertical scrolling */
            box-sizing: border-box; /* Include padding in width */
            transition: right 0.3s ease-in-out; /* Slide animation */
        }

        #settings-panel.open {
            right: 0; /* Slide into view */
        }

        #settings-panel h2 {
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
        }

        #settings-panel label {
            display: block;
            margin-bottom: 6px;
            font-weight: bold;
        }

        #settings-panel input[type="number"],
        #settings-panel input[type="range"],
        #settings-panel input[type="text"],
        #settings-panel select { /* Apply styles to select too */
            width: calc(100% - 20px); /* Adjusted width calculation */
            margin-bottom: 12px;
            padding: 8px;
            border: 1px solid var(--input-border-color);
            border-radius: 5px;
            font-size: 1em;
            background-color: var(--input-bg-color);
            color: var(--input-text-color);
            box-sizing: border-box;
        }

        #settings-panel input[type="number"] {
             width: 70px; /* Keep number inputs smaller */
        }

        #settings-panel input[type="range"] {
            width: 100%;
            padding: 0; /* Remove padding for range */
        }

        #settings-panel button {
            padding: 10px 20px;
            margin-top: 12px;
            margin-right: 10px; /* Space between buttons */
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }
        #settings-panel button:last-of-type {
             margin-right: 0;
        }

        #settings-panel button:hover {
            background-color: var(--button-hover-bg);
        }

        #settings-panel .setting-group {
           margin-bottom: 20px; /* Increased spacing */
            border-bottom: 1px solid var(--grid-border-color); /* Use grid border color */
            padding-bottom: 15px;
        }
        #settings-panel .setting-group:last-of-type {
            border-bottom: none; /* No border on the last group */
        }

        /* REMOVED Old Difficulty Buttons Style */
        /* #settings-panel .difficulty-buttons { ... } */


        #overlay {
            display: none; /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 1000; /* Below settings panel, above content */
        }

        #message-box {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--container-bg);
            color: var(--text-color);
            padding: 25px;
            border: 2px solid #888;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            z-index: 1011; /* Above settings panel */
            text-align: center;
            border-radius: 12px;
            width: 80%;
            max-width: 400px;
        }
        #message-box button {
            padding: 10px 20px;
            margin-top: 12px;
            font-size: 1.1em;
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }

        #message-box button:hover {
            background-color: var(--button-hover-bg);
        }

        #message-text {
            font-size: 1.2em;
            margin-bottom: 15px;
        }

        /* Toggle switch styles */
        .switch-container { /* Container for label and switch */
             display: flex;
             align-items: center;
             margin-bottom: 12px;
        }
        .switch-container label {
            margin-bottom: 0; /* Remove bottom margin from label */
            margin-right: 10px; /* Space between label and switch */
        }
        .switch {
          position: relative;
          display: inline-block;
          width: 60px;
          height: 34px;
          /* margin-bottom: 12px; Removed */
          vertical-align: middle; /* Align with label */
        }

        .switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }

        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ccc;
          -webkit-transition: .4s;
          transition: .4s;
          border-radius: 34px;
        }

        .slider:before {
          position: absolute;
          content: "";
          height: 26px;
          width: 26px;
          left: 4px;
          bottom: 4px;
          background-color: white;
          -webkit-transition: .4s;
          transition: .4s;
          border-radius: 50%;
        }

        input:checked + .slider {
          background-color: #2196F3;
        }

        input:focus + .slider {
          box-shadow: 0 0 1px #2196F3;
        }

        input:checked + .slider:before {
          -webkit-transform: translateX(26px);
          -ms-transform: translateX(26px);
          transform: translateX(26px);
        }

        #leaderboard {
            margin-top: 30px; /* Increased margin */
            text-align: center;
             width: 95%; /* Make leaderboards wider */
            max-width: 1200px; /* Max width for very large screens */
             margin-left: auto;
             margin-right: auto;
        }

        #leaderboard h3 {
            margin-bottom: 15px;
        }

        #leaderboard table {
            width: 90%; /* Relative width */
            max-width: 500px; /* Limit width for local leaderboard */
            margin: 0 auto 20px auto; /* Center and add bottom margin */
            border-collapse: collapse;
            background-color: var(--container-bg); /* Match container */
             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
             border-radius: 8px;
             overflow: hidden; /* Clip corners */
        }


        #leaderboard th, #leaderboard td {
            padding: 10px; /* Increased padding */
            border: 1px solid var(--grid-border-color);
            text-align: center;
        }

        #leaderboard th {
            background-color: var(--control-bg-color);
            color: var(--text-color);
            font-weight: bold;
        }
        .custom-settings {
            display: none; /* Initially hidden */
        }

        .custom-settings.active {
            display: block; /* Show when active */
        }
         #settings-panel #custom-difficulty-label{
            margin-top: 10px;
            font-size: 1.1em;
        }

      #leaderboard-loading, #leaderboard-error {
          margin-bottom: 15px;
          text-align: center; /* Center loading/error text */
          width: 100%;
          font-size: 1.1em;
      }
       /* Style for online leaderboard tables */
      #online-leaderboard-container {
        display: flex; /* Use flexbox for side-by-side tables */
        justify-content: space-around; /* Distribute space evenly */
        flex-wrap: wrap; /* Allow tables to wrap on smaller screens */
        width: 95%; /* Make leaderboards wider */
        max-width: 1200px; /* Optional max width for very large screens */
        margin: 30px auto; /* Center and add vertical margin */
        gap: 20px; /* Add gap between sections */

      }
      /* Individual leaderboard section */
        .leaderboard-section {
            flex: 1 1 300px; /* Flex grow, shrink, basis (min width) */
            margin-bottom: 20px; /* Space below each section */
            padding: 15px; /* Increased padding */
            background-color: var(--container-bg); /* Match container background */
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            box-sizing: border-box; /* Include padding in width calculation */
        }

       .leaderboard-section h4 {
           margin-top: 0;
           margin-bottom: 15px; /* Increased spacing */
           text-align: center;
           color: var(--text-color);
           font-size: 1.2em; /* Slightly larger title */
       }

      .leaderboard-section table {
        width: 100%; /* Tables take full width of their section */
        border-collapse: collapse;
      }
        .leaderboard-section th,
        .leaderboard-section td {
             padding: 8px; /* Standard padding */
              border: 1px solid var(--grid-border-color);
              text-align: center;
              font-size: 0.95em; /* Standard font size */
        }
        .leaderboard-section th {
             background-color: var(--control-bg-color);
              color: var(--text-color);
               font-weight: bold;
        }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        #online-leaderboard-container {
          /* Keep flex-direction row, rely on wrapping */
          justify-content: center; /* Center items when they wrap */
        }
          .leaderboard-section {
            flex-basis: 90%; /* Allow sections to take more width */
          }
          #settings-panel {
              width: 280px; /* Slightly narrower panel on mobile */
              right: calc(-280px - 10px);
              :root { --settings-panel-width: 280px; } /* Update CSS variable */
          }
          #settings-toggle-button {
              padding: 12px 6px; /* Adjust padding */
              font-size: 1em;
          }
      }
       #generation-attempts {
         margin-left: 10px;
         font-size: 0.9em;
         color: #aaa; /* Light gray color */
        }
        .light-mode #generation-attempts {
            color: #555; /* Darker gray for light mode */
        }
        h1 {
          position: absolute;
          left: -9999px;
        }

        /* === ADDED: Legacy-icon tooltip / pointer === */
        .legacy-icon {
          cursor: help; /* shows ? cursor on hover */
          margin-left: 4px; /* Add slight space before icon */
        }

    </style>
</head>
<body>
    <h1>Mobile Minesweeper game No Guess Mode and Online Leaderboards</h1>

    <!-- Settings Toggle Button -->
    <button id="settings-toggle-button" onclick="toggleSettings()">Settings</button>

    <div id="game-container">
        <!-- Header area for logo and controls -->
        <div id="header-area">
            <img id="logo" src="/DarkModeLogo.svg" alt="Min3s Logo">
            <div id="controls">
                <div id="mines-left">
                    <div id="mines-left-label">Mines</div>
                    <div></div>
                </div>
                <div id="timer">
                     <div id="timer-label">Timer</div>
                    <div>0.000</div> <!-- Initial display with decimals -->
                </div>
            </div>
        </div>
        <!-- End of header area -->

        <!-- New Difficulty Selector Area -->
        <div id="difficulty-selector-area">
            <label for="difficulty-selector">Difficulty:</label>
            <select id="difficulty-selector" onchange="handleDifficultyChange()">
                <option value="beginner">Beginner</option>
                <option value="intermediate">Intermediate</option>
                <option value="expert">Expert</option>
                <option value="custom">Custom</option>
            </select>
        </div>
        <!-- End of Difficulty Selector Area -->

        <div id="grid-container"></div>
    </div>

      <!-- Settings Side Panel -->
      <div id="settings-panel">
        <h2>Settings</h2>

        <!-- Removed Difficulty Buttons Section -->
        <!-- <div class="setting-group difficulty-buttons"> ... </div> -->

        <div class="setting-group">
            <label for="player-name">Your Name:</label>
            <input type="text" id="player-name" value="Player" placeholder="Enter your name">
        </div>

        <!-- Custom settings appear only when difficulty is custom -->
        <div class="custom-settings setting-group">
            <h3 id="custom-difficulty-label">Custom Difficulty</h3>
             <label for="width">Width:</label>
             <input type="number" id="width" min="5" max="50" value="9">
             <br> <!-- Simple line break for better spacing -->
             <label for="height">Height:</label>
             <input type="number" id="height" min="5" max="50" value="9">
             <br>
             <label for="mines">Mines:</label>
             <input type="number" id="mines" min="1" max="2491" value="10">
        </div>

        <div class="setting-group">
             <div class="switch-container">
                 <label for="light-mode">Light Mode:</label>
                 <label class="switch">
                    <input type="checkbox" id="light-mode">
                    <span class="slider"></span>
                 </label>
             </div>
        </div>
        <div class="setting-group">
             <div class="switch-container">
                 <label for="no-guess-mode">No Guess Mode:</label>
                 <label class="switch">
                     <input type="checkbox" id="no-guess-mode">
                     <span class="slider"></span>
                 </label>
             </div>
             <span id="generation-attempts"></span> <!-- To display attempts -->
        </div>

        <div class="setting-group">
            <label for="flag-method">Flagging Method:</label>
            <select id="flag-method"> <!-- Removed onchange, will be handled by auto-save listener -->
              <option value="longPress">Long Press</option>
              <option value="doubleTap">Double Tap</option>
              <option value="rightClick">Right Click</option>
            </select>
        </div>

        <div class="setting-group">
            <label for="long-press-delay">Long Press Delay (ms):</label>
            <input type="range" id="long-press-delay" min="100" max="1000" value="500" step="50">
            <span id="long-press-delay-value">500</span>ms
        </div>

        <div class="setting-group">
            <label for="chord-method">Chording Method:</label>
            <select id="chord-method">
                <option value="singleTap">Single Tap</option>
                <option value="doubleTap">Double Tap</option>
            </select>
        </div>
        <!-- Buttons at the bottom -->
        <div>
             <button onclick="applySettings()">Apply & Close</button>
             <button onclick="toggleSettings()">Close</button>
        </div>
    </div>

    <!-- Overlay for Settings Panel and Message Box -->
    <div id="overlay" onclick="closePanels()"></div>

     <div id="message-box">
      <p id="message-text"></p>
      <button onclick="restartGame()">Restart</button>
    </div>

     <!-- Online Leaderboards Container -->
      <div id="online-leaderboard-container">
         <div id="leaderboard-loading">Loading leaderboards...</div>
         <div id="leaderboard-error" style="color: red; display: none; width: 100%; text-align: center;">Error loading leaderboards.</div>

         <!-- Standard Leaderboards -->
         <div class="leaderboard-section">
             <h4>Beginner</h4>
             <table>
                 <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                 <tbody id="leaderboard-beginner"></tbody>
             </table>
         </div>
         <div class="leaderboard-section">
             <h4>Intermediate</h4>
             <table>
                 <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                 <tbody id="leaderboard-intermediate"></tbody>
             </table>
         </div>
         <div class="leaderboard-section">
             <h4>Expert</h4>
             <table>
                 <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                 <tbody id="leaderboard-expert"></tbody>
             </table>
         </div>

         <!-- No Guess Leaderboards -->
         <div class="leaderboard-section">
             <h4>Beginner (No Guess)</h4>
             <table>
                 <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                 <tbody id="leaderboard-beginner_noguess"></tbody>
             </table>
         </div>
          <div class="leaderboard-section">
             <h4>Intermediate (No Guess)</h4>
             <table>
                 <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                 <tbody id="leaderboard-intermediate_noguess"></tbody>
             </table>
         </div>
          <div class="leaderboard-section">
             <h4>Expert (No Guess)</h4>
             <table>
                 <thead><tr><th>#</th><th>Name</th><th>Time (s)</th></tr></thead> <!-- Added (s) -->
                 <tbody id="leaderboard-expert_noguess"></tbody>
             </table>
         </div>
      </div>

      <!-- Local Leaderboard Table -->
      <div id="leaderboard">
        <h3>Local Leaderboard</h3>
        <table>
            <thead>
                <tr>
                    <th>Difficulty</th>
                    <th>Best Time (s)</th> <!-- Added (s) -->
                </tr>
            </thead>
            <tbody>
                <tr><td>Beginner</td><td id="leaderboard-beginner-local">-</td></tr>
                <tr><td>Intermediate</td><td id="leaderboard-intermediate-local">-</td></tr>
                <tr><td>Expert</td><td id="leaderboard-expert-local">-</td></tr>
                <tr><td>Beginner (No Guess)</td><td id="leaderboard-beginner_noguess-local">-</td></tr>
                <tr><td>Intermediate (No Guess)</td><td id="leaderboard-intermediate_noguess-local">-</td></tr>
                <tr><td>Expert (No Guess)</td><td id="leaderboard-expert_noguess-local">-</td></tr>
            </tbody>
        </table>
    </div>

    <script>
     /* =========  SANITISE UTILITY  ========= */
    function sanitize (str) {
      // Basic sanitization for leaderboard display
      if (typeof str !== 'string') return ''; // Handle non-string input
      return str.replace(/[&<>"'`=\\/]/g, s => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;', '`': '&#96;', '=': '&#61;', '/': '&#x2F;'
      })[s] || s); // Fallback for safety, although regex should cover all
    }

    /* =========  FIREBASE CONFIG  ========= */
    const firebaseConfig = {
      apiKey: "AIzaSyAV_27osmUzqrYbJIatByVHigyKh0naSNM",
      authDomain: "min3s-d13d8.firebaseapp.com",
      projectId: "min3s-d13d8",
      storageBucket: "min3s-d13d8.appspot.com",
      messagingSenderId: "561325595032",
      appId: "1:561325595032:web:19657730940427fb4073ed",
      measurementId: "G-N25M3ZT9NQ"
    };
    const firebaseApp = firebase.initializeApp(firebaseConfig);
    const db = firebaseApp.firestore();

    // --- Global Variables ---
    let grid = [];
    let width = 9;
    let height = 9;
    let numMines = 10;
    let minesLeft = numMines;
    let timerDisplayInterval = null; // Renamed from timerInterval
    let timerStartTime = null; // Timestamp when the timer started (using performance.now())
    let time = 0.000; // Current elapsed time in seconds
    const timerUpdateDelay = 50; // How often to update the DISPLAY (in ms) - doesn't affect accuracy
    let gameStarted = false;
    let gameOver = false;
    let firstClick = true;
    let touchLongPressTimerId = null;
    let mouseLongPressTimerId = null;
    let ignoreNextClick = false;
    let longPressFlaggedThisTouch = false;
    let longPressJustFinishedMouse = false;
    let isLeftMouseDown = false;
    let pressedCellElement = null;
    let initialMouseDownCell = null;
    let longPressDelay = 500;
    let flagMethod = "longPress";
    let chordMethod = "singleTap";
    let doubleTapChordTimer = null;
    let doubleTapFlagTimer = null;
    let currentDifficulty = "beginner";
    let playerName = "Player";
    let noGuessMode = false;
    let generationAttempts = 0;

    // --- DOM Elements Cache ---
    const gridContainer = document.getElementById('grid-container');
    const timerDisplay = document.querySelector('#timer > div:nth-child(2)');
    const minesLeftDisplay = document.querySelector('#mines-left > div:nth-child(2)');
    const settingsPanel = document.getElementById('settings-panel');
    const overlay = document.getElementById('overlay');
    const messageBox = document.getElementById('message-box');
    const messageText = document.getElementById('message-text');
    const difficultySelector = document.getElementById('difficulty-selector');
    const customSettingsDiv = document.querySelector('.custom-settings');
    const widthInput = document.getElementById('width');
    const heightInput = document.getElementById('height');
    const minesInput = document.getElementById('mines');
    const playerNameInput = document.getElementById('player-name');
    const lightModeCheckbox = document.getElementById('light-mode');
    const noGuessCheckbox = document.getElementById('no-guess-mode');
    const flagMethodSelect = document.getElementById('flag-method');
    const longPressDelayInput = document.getElementById('long-press-delay');
    const longPressDelayValueSpan = document.getElementById('long-press-delay-value');
    const chordMethodSelect = document.getElementById('chord-method');
    const attemptsSpan = document.getElementById('generation-attempts');
    const logoElement = document.getElementById('logo');
    const headerArea = document.getElementById('header-area');
    const controlsDiv = document.getElementById('controls');
    const leaderboardLoadingDiv = document.getElementById('leaderboard-loading');
    const leaderboardErrorDiv = document.getElementById('leaderboard-error');


    // --- Grid Creation ---
    function createGrid() {
      gridContainer.innerHTML = '';
      gridContainer.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
      grid = [];

      for (let y = 0; y < height; y++) {
        grid[y] = [];
        for (let x = 0; x < width; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.dataset.x = x;
          cell.dataset.y = y;
          cell.addEventListener('click', handleClick);
          cell.addEventListener('mousedown', handleCellMouseDown);
          cell.addEventListener('contextmenu', handleRightClick);
          cell.addEventListener('mouseover', handleCellMouseOver);
          cell.addEventListener('mouseout', handleCellMouseOut);

          updateFlagMethodListeners(cell, x, y); // Attach specific touch/long press listeners

          gridContainer.appendChild(cell);
          grid[y][x] = {
            isMine: false,
            isRevealed: false,
            isFlagged: false,
            adjacentMines: 0,
            element: cell,
          };
        }
      }
      updateMinesLeftDisplay();
      updateTimerDisplay(); // Update timer display on creation (shows 0.000)
      gridContainer.addEventListener('contextmenu', (e) => { e.preventDefault(); });
      document.addEventListener('mouseup', handleDocumentMouseUp); // Global listener remains
    }

    // --- Event Handlers ---

    function handleRightClick(event) {
        event.preventDefault(); // Always prevent context menu on cells
    }

    function handleCellMouseDown(event) {
        if (gameOver) return;
        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;

        // --- Right Click (Button 2) ---
        if (event.button === 2) {
            event.preventDefault(); // Prevent context menu immediately
            if (flagMethod === 'rightClick' && !gameOver) { // Only flag if method is rightClick
                 handleFlag(event);
            }
            return;
        }

        // --- Left Click (Button 0) ---
        if (event.button === 0) {
             initialMouseDownCell = targetCell;
             isLeftMouseDown = true;

             // Long Press Handling (Mouse)
             if (flagMethod === 'longPress') {
                 clearTimeout(mouseLongPressTimerId);
                 longPressJustFinishedMouse = false;
                 mouseLongPressTimerId = setTimeout(() => {
                     handleFlag(event); // Flag on long press
                     longPressJustFinishedMouse = true;
                     mouseLongPressTimerId = null;
                     if (pressedCellElement) pressedCellElement.classList.remove('pressed');
                     pressedCellElement = null;
                     isLeftMouseDown = false; // End "drag" after long press action
                 }, longPressDelay);
             }

             // Standard Left Mouse Down Visual
             const cellData = grid[parseInt(targetCell.dataset.y)][parseInt(targetCell.dataset.x)];
             if (cellData && !cellData.isRevealed && !cellData.isFlagged) {
                targetCell.classList.add('pressed');
                pressedCellElement = targetCell;
             } else {
                pressedCellElement = null;
             }
        }
    }

    function handleCellMouseOver(event) {
        if (!isLeftMouseDown || gameOver) return;
        const targetCell = event.target.closest('.cell');
        if (!targetCell) { // Moved off grid
             if(pressedCellElement) {
                  pressedCellElement.classList.remove('pressed');
                  pressedCellElement = null;
             }
             return;
        }

        const cellData = grid[parseInt(targetCell.dataset.y)][parseInt(targetCell.dataset.x)];
        if (!cellData) return;

        if (targetCell !== pressedCellElement) {
            if (pressedCellElement) {
                pressedCellElement.classList.remove('pressed');
            }
            if (!cellData.isRevealed && !cellData.isFlagged) {
                 targetCell.classList.add('pressed');
                 pressedCellElement = targetCell;
            } else {
                 pressedCellElement = null;
            }
        }
    }

    function handleCellMouseOut(event) {
        if (!isLeftMouseDown || gameOver) return;
        const relatedTarget = event.relatedTarget;
        if (!relatedTarget || !relatedTarget.closest('#grid-container')) { // Leaving grid container
             if(pressedCellElement) {
                 pressedCellElement.classList.remove('pressed');
                 pressedCellElement = null;
             }
        }
    }

    function handleDocumentMouseUp(event) {
        if (event.button === 0 && isLeftMouseDown) { // Left button release
             isLeftMouseDown = false;
             const mouseUpTargetElement = document.elementFromPoint(event.clientX, event.clientY);
             const mouseUpCellElement = mouseUpTargetElement ? mouseUpTargetElement.closest('.cell') : null;

             clearTimeout(mouseLongPressTimerId); // Clear MOUSE long press timer
             mouseLongPressTimerId = null;

             if (longPressJustFinishedMouse) { // Was it a long press flag?
                 longPressJustFinishedMouse = false;
                 initialMouseDownCell = null;
                 if (pressedCellElement) { // Should already be null, but belt & braces
                     pressedCellElement.classList.remove('pressed');
                     pressedCellElement = null;
                 }
                 return; // Do nothing else
             }

             // Remove final pressed state
             if (pressedCellElement) {
                 pressedCellElement.classList.remove('pressed');
             }
             pressedCellElement = null; // Reset tracked pressed element

             if (gameOver) {
                 initialMouseDownCell = null;
                 return;
             }

             // Process release action if over a valid cell
             if (mouseUpCellElement) {
                 const x = parseInt(mouseUpCellElement.dataset.x);
                 const y = parseInt(mouseUpCellElement.dataset.y);
                 const cellData = grid[y]?.[x];

                 if (cellData) {
                      if (firstClick) {
                          handleFirstClick(x, y);
                      } else if (cellData.isRevealed) {
                          // CHORDING: Trigger on the cell released over
                          chord(x, y);
                      } else if (!cellData.isFlagged) {
                          // REVEALING: Trigger on the cell released over
                          revealCell(x, y);
                      }
                      // If flagged, left release does nothing
                  }
             }
             initialMouseDownCell = null; // Reset initial cell tracking

        } else { // Other mouse button up or not dragging
             isLeftMouseDown = false;
             clearTimeout(mouseLongPressTimerId);
             mouseLongPressTimerId = null;
             if (pressedCellElement) {
                  pressedCellElement.classList.remove('pressed');
                  pressedCellElement = null;
             }
             initialMouseDownCell = null;
             longPressJustFinishedMouse = false;
        }
    }

    // Simplified handleClick for Taps (reveal or chord)
     function handleClick(event) {
         if (ignoreNextClick) {
             ignoreNextClick = false; return;
         }
         if (gameOver) return;
         // Let mousedown/mouseup handle mouse clicks
         if (event.pointerType === 'mouse' && event.button === 0) return;

         const targetCell = event.target.closest('.cell');
         if (!targetCell) return;
         const x = parseInt(targetCell.dataset.x);
         const y = parseInt(targetCell.dataset.y);
         const cell = grid[y]?.[x];
         if (!cell) return;

         if (firstClick) {
              handleFirstClick(x, y); return;
         }

         if (cell.isRevealed) {
             // Chording: Handle single tap chord or first tap of double tap chord
             if (chordMethod === 'doubleTap') {
                 handleDoubleTapChord(event); // Check for double tap chord
             } else {
                 chord(x, y); // Chord on single tap
             }
         } else if (!cell.isFlagged) {
              // Revealing: Handle first tap of double tap flag, or normal reveal
              if (flagMethod === 'doubleTap') {
                   // If doubleTapFlagTimer is running, this click does nothing (handled by double tap)
                   // If it's null, this click might start the timer OR reveal if no second tap comes
                   if (doubleTapFlagTimer === null) {
                        // We don't reveal immediately, wait to see if it's a double tap flag
                        // Instead, let the doubleTapFlag handler manage it or let the timer expire.
                        // If double tap isn't used for flagging, we just reveal.
                         revealCell(x, y);
                    }
               } else {
                  revealCell(x, y); // Reveal normally if not double tap flag mode
              }
         }
         // If flagged, tap does nothing unless it's part of a double tap sequence? (Current logic: does nothing)
     }

    // --- Game Logic ---

    function handleFirstClick(x, y) {
         if (!firstClick || gameOver) return;
         attemptsSpan.textContent = ''; // Clear previous attempts count

         if (noGuessMode) {
             generationAttempts = 0;
             let solvable = false;
             console.log("No Guess Mode: Starting generation...");
             attemptsSpan.textContent = 'Generating...';
             setTimeout(() => { // Use setTimeout to avoid freezing UI
                 while (!solvable) {
                     generationAttempts++;
                     // Reset grid mines/adjacencies
                     for (let r = 0; r < height; r++) {
                         for (let c = 0; c < width; c++) {
                            if(grid[r]?.[c]){
                                 grid[r][c].isMine = false;
                                 grid[r][c].adjacentMines = 0;
                                 // Don't reset revealed/flagged state here
                            }
                         }
                     }
                     placeMines(x, y); // Place mines avoiding the start area
                     if (isSolvableWithoutGuessing(x, y)) {
                         solvable = true;
                         console.log(`No Guess Mode: Solvable grid found after ${generationAttempts} attempts.`);
                         attemptsSpan.textContent = `(${generationAttempts} attempts)`;
                         startTimer(); // Start the timer AFTER generation
                         firstClick = false;
                         revealCell(x, y); // Reveal the first clicked cell
                     } else {
                        if (generationAttempts % 100 === 0) {
                            console.log(`No Guess Mode: Attempt ${generationAttempts}...`);
                            attemptsSpan.textContent = `Generating... (${generationAttempts})`;
                        }
                        if (generationAttempts > 50000) { // Timeout
                             console.error(`No Guess Mode: Generation timed out after ${generationAttempts} attempts.`);
                             alert(`Failed to generate a solvable grid in No Guess Mode after ${generationAttempts} tries. Try reducing density or grid size, or disable No Guess Mode.`);
                             attemptsSpan.textContent = '(Generation Failed)';
                             restartGame(); // Go back to initial state
                             return; // Stop generation attempt
                        }
                     }
                 }
             }, 0); // End setTimeout

         } else {
             // Normal mode: place mines and reveal
             placeMines(x, y);
             startTimer(); // Start the timer
             firstClick = false;
             revealCell(x, y);
         }
     }

     function updateFlagMethodListeners(cell, x, y) {
        if(!cell) return; // Safety check

        // Remove existing listeners first to avoid duplicates
        removeLongPressListener(cell);
        cell.removeEventListener('touchstart', handleDoubleTapFlag);

        // Add listeners based on the current setting
        if (flagMethod === 'longPress') {
            addLongPressListener(cell, handleFlag); // Add touch long press for flagging
            // Right-click flagging is handled in handleCellMouseDown
        } else if (flagMethod === 'doubleTap') {
            cell.addEventListener('touchstart', handleDoubleTapFlag); // Add touch double tap for flagging
        }
        // 'rightClick' flagging is handled purely in handleCellMouseDown
    }

    // Call this when flagMethod setting changes
    function updateAllFlagMethodListeners() {
        for(let r = 0; r < height; r++){
            for(let c = 0; c < width; c++){
                if (grid[r]?.[c]?.element) {
                   updateFlagMethodListeners(grid[r][c].element, c, r);
                }
            }
        }
    }

    function handleDoubleTapFlag(event){
        if(gameOver || flagMethod !== 'doubleTap') return;
        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;

        if(doubleTapFlagTimer === null){ // First tap
            // Prevent default action slightly delayed to allow scrolling if not double-tapped
            const timerId = setTimeout(() => event.preventDefault(), 150);
            doubleTapFlagTimer = setTimeout(() => {
                 doubleTapFlagTimer = null; // Timer expired, not a double tap
                 clearTimeout(timerId); // Clear the preventDefault timer
                 // If it wasn't a double tap, treat the first tap as a reveal
                 handleClick(event); // Re-process the initial tap as a single tap/click
            }, 300); // 300ms window for double tap
            // Add visual feedback for first tap
             if (!targetCell.classList.contains('revealed') && !targetCell.classList.contains('flagged')) {
                 targetCell.classList.add('pressed');
                 // Remove pressed state shortly after if no second tap comes
                 setTimeout(() => {
                     if (doubleTapFlagTimer !== null) { // Only remove if timer still active (no second tap yet)
                        targetCell.classList.remove('pressed');
                     }
                 }, 150);
             }

        } else { // Second tap
            clearTimeout(doubleTapFlagTimer); // Clear the timer
            doubleTapFlagTimer = null;
            targetCell.classList.remove('pressed'); // Remove press state from first tap
            handleFlag(event); // Execute the flag action
            ignoreNextClick = true; // Prevent the click event after double tap
            event.preventDefault(); // Prevent zoom/other default actions
        }
    }
    function handleDoubleTapChord(event){
        if(gameOver || chordMethod !== 'doubleTap') return;
        const targetCell = event.target.closest('.cell');
        if (!targetCell) return;
        const x = parseInt(targetCell.dataset.x);
        const y = parseInt(targetCell.dataset.y);
        const cell = grid[y]?.[x];

        if(!cell || !cell.isRevealed) return; // Can only chord revealed cells

        if (doubleTapChordTimer === null) { // First tap
             const timerId = setTimeout(() => event.preventDefault(), 150);
            doubleTapChordTimer = setTimeout(() => {
                doubleTapChordTimer = null; // Timer expired
                clearTimeout(timerId);
                 // If timer expires, the first tap does nothing in double-tap chord mode
                 targetCell.classList.remove('pressed'); // Remove visual feedback
            }, 300);
             // Add visual feedback
             targetCell.classList.add('pressed');

        } else { // Second tap
            clearTimeout(doubleTapChordTimer);
            doubleTapChordTimer = null;
            targetCell.classList.remove('pressed');
            chord(x, y); // Execute chord action
            ignoreNextClick = true; // Prevent click event
            event.preventDefault();
        }
    }

    function placeMines(safeX, safeY) {
        let minesPlaced = 0;
        let availableSquares = [];
        // Define the 3x3 safe zone around the first click
        const safeZone = new Set();
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                safeZone.add(`${safeX + dx},${safeY + dy}`);
            }
        }

        // Collect all squares NOT in the safe zone
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                 if (!safeZone.has(`${x},${y}`)) {
                     availableSquares.push({x, y});
                 }
            }
        }

        // Shuffle the available squares
        for (let i = availableSquares.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableSquares[i], availableSquares[j]] = [availableSquares[j], availableSquares[i]];
        }

        // Place mines in the shuffled available squares
        const minesToPlace = Math.min(numMines, availableSquares.length);
        for (let i = 0; i < minesToPlace; i++) {
            const { x, y } = availableSquares[i];
             if(grid[y]?.[x]) {
                 grid[y][x].isMine = true;
                 minesPlaced++;
             }
        }

         if (minesPlaced < numMines) {
            console.warn(`Could only place ${minesPlaced}/${numMines} mines due to safe zone size.`);
            // Optionally: Update numMines to reflect actual placed mines? Or alert user?
            // For now, just proceed with the placed mines. The game logic uses numMines setting.
         }
        calculateAdjacentMines();
    }

    function calculateAdjacentMines() {
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const cell = grid[y]?.[x];
                if (cell && !cell.isMine) {
                    let count = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const newX = x + dx; const newY = y + dy;
                            if (newX >= 0 && newX < width && newY >= 0 && newY < height && grid[newY]?.[newX]?.isMine) {
                                count++;
                            }
                        }
                    }
                    cell.adjacentMines = count;
                    if(cell.element) cell.element.dataset.adjacent = count; // Update data attribute for CSS
                } else if (cell) {
                     cell.adjacentMines = -1; // Indicate mine or error
                     if(cell.element) delete cell.element.dataset.adjacent;
                }
            }
        }
    }

    function revealCell(x, y) {
        if (isNaN(x) || isNaN(y) || x < 0 || x >= width || y < 0 || y >= height || gameOver) return;
        const cell = grid[y]?.[x];
        if (!cell || cell.isRevealed || cell.isFlagged) return;

        cell.isRevealed = true;
        cell.element.classList.remove('pressed', 'flagged'); // Remove pressed/flagged states
        cell.element.classList.add('revealed');
        cell.element.textContent = ''; // Clear flag text if any

        if (cell.isMine) {
            cell.element.classList.add('mine');
            cell.element.textContent = "💣";
            revealAllMines(x, y);
            showMessage("Game Over!");
        } else {
            cell.element.dataset.adjacent = cell.adjacentMines;
            if (cell.adjacentMines > 0) {
                cell.element.textContent = cell.adjacentMines;
            } else {
                 cell.element.textContent = '';
                const revealQueue = [];
                 for (let dy = -1; dy <= 1; dy++) {
                     for (let dx = -1; dx <= 1; dx++) {
                          if (dx === 0 && dy === 0) continue;
                          const nextX = x + dx; const nextY = y + dy;
                          if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height) {
                              const neighborCell = grid[nextY]?.[nextX];
                              if(neighborCell && !neighborCell.isRevealed && !neighborCell.isFlagged){
                                 revealQueue.push({nx: nextX, ny: nextY});
                              }
                          }
                     }
                 }
                let processed = new Set([`${x},${y}`]);
                while(revealQueue.length > 0) {
                    const current = revealQueue.shift();
                    const currentX = current.nx; const currentY = current.ny;
                    const currentKey = `${currentX},${currentY}`;
                    if (processed.has(currentKey) || currentX < 0 || currentX >= width || currentY < 0 || currentY >= height) continue;
                    const currentCell = grid[currentY]?.[currentX];
                    if (!currentCell || currentCell.isRevealed || currentCell.isFlagged) {
                         processed.add(currentKey);
                         continue;
                    }
                    processed.add(currentKey);
                    currentCell.isRevealed = true;
                    currentCell.element.classList.add('revealed');
                    currentCell.element.classList.remove('pressed', 'flagged');
                    currentCell.element.textContent = '';
                    currentCell.element.dataset.adjacent = currentCell.adjacentMines;
                    if (currentCell.adjacentMines > 0) {
                        currentCell.element.textContent = currentCell.adjacentMines;
                    } else {
                        currentCell.element.textContent = '';
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nextX = currentX + dx; const nextY = currentY + dy;
                                const nextKey = `${nextX},${nextY}`;
                                if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height && !processed.has(nextKey)) {
                                    const neighborCell = grid[nextY]?.[nextX];
                                    if(neighborCell && !neighborCell.isRevealed && !neighborCell.isFlagged){
                                        revealQueue.push({nx: nextX, ny: nextY});
                                    } else {
                                         processed.add(nextKey);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
       if (!gameOver) checkWin();
    }

    function handleFlag(event) {
      if (gameOver) return;
      const targetCell = event.target.closest('.cell');
      if (!targetCell) return;
      const x = parseInt(targetCell.dataset.x);
      const y = parseInt(targetCell.dataset.y);
      const cell = grid[y]?.[x];
      if (!cell || cell.isRevealed) return;

      if (cell.isFlagged) {
          cell.isFlagged = false;
          cell.element.classList.remove('flagged');
          cell.element.textContent = '';
          minesLeft++;
      } else if (minesLeft > 0) {
          cell.isFlagged = true;
          cell.element.classList.add('flagged');
          cell.element.textContent = '🚩';
          minesLeft--;
      } else {
          console.log("No flags left!");
      }
      updateMinesLeftDisplay();
      checkWin();
    }

     function chord(x, y){
        if (isNaN(x) || isNaN(y) || x < 0 || x >= width || y < 0 || y >= height || gameOver) return;
        const cell = grid[y]?.[x];
        if(!cell || !cell.isRevealed || cell.adjacentMines <= 0) return;

        let flaggedNeighbors = 0;
        let unknownAndUnflaggedNeighbors = [];
         for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const newX = x + dx; const newY = y + dy;
                 if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                      const neighbor = grid[newY]?.[newX];
                      if (neighbor) {
                          if (neighbor.isFlagged) {
                              flaggedNeighbors++;
                          } else if (!neighbor.isRevealed) {
                              unknownAndUnflaggedNeighbors.push({x: newX, y: newY});
                          }
                      }
                 }
            }
          }
         if(flaggedNeighbors === cell.adjacentMines){
             unknownAndUnflaggedNeighbors.forEach(pos => {
                revealCell(pos.x, pos.y);
             });
         }
     }

     function revealAllMines(clickedX, clickedY) {
        gameOver = true;
        stopTimer();

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                 const cell = grid[y]?.[x];
                 if (cell?.element) {
                     cell.element.classList.remove('pressed');
                     if (cell.isMine) {
                         if (!cell.isFlagged) {
                             cell.element.classList.add('mine-revealed');
                             cell.element.textContent = "💣";
                             if (x === clickedX && y === clickedY) {
                                 cell.element.classList.remove('mine-revealed');
                                 cell.element.classList.add('mine');
                             }
                         }
                     } else if (cell.isFlagged) {
                         cell.element.classList.remove('flagged');
                         cell.element.classList.add('incorrect-flag');
                         cell.element.textContent = 'X';
                     }
                 }
            }
        }
    }

    function checkWin() {
      if (gameOver || firstClick) return;
      let revealedNonMineCount = 0;
      let totalNonMineCells = 0;
      for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
              const cell = grid[y]?.[x];
              if (!cell) continue;
              if (!cell.isMine) {
                  totalNonMineCells++;
                  if (cell.isRevealed) {
                      revealedNonMineCount++;
                  }
              }
          }
      }
      if (revealedNonMineCount === totalNonMineCells && totalNonMineCells > 0) {
            const expectedNonMines = (width * height) - numMines;
            if(totalNonMineCells !== expectedNonMines) {
                 console.warn(`Win check discrepancy: Actual non-mines (${totalNonMineCells}) vs Expected (${expectedNonMines}). Win declared based on actual.`);
            }
            winGame(true);
      }
    }

    function winGame(autoFlag = true) {
        if (gameOver) return;
        gameOver = true;
        stopTimer();
        console.log("Win condition met!");
        let flagsPlaced = 0;
        if (autoFlag) {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = grid[y]?.[x];
                    if (cell?.isMine && !cell.isRevealed && !cell.isFlagged) {
                        cell.isFlagged = true;
                        if(cell.element) {
                            cell.element.classList.add('flagged');
                            cell.element.textContent = '🚩';
                        }
                        flagsPlaced++;
                    }
                }
            }
             minesLeft -= flagsPlaced;
             if(minesLeft < 0) minesLeft = 0;
             updateMinesLeftDisplay();
        }
        flagIncorrectlyPlaced();
        updateLeaderboard();
        showMessage("You Win! Time: " + time.toFixed(3) + " seconds");
        if (pressedCellElement) { pressedCellElement.classList.remove('pressed'); pressedCellElement = null; }
        isLeftMouseDown = false;
        clearTimeout(touchLongPressTimerId); touchLongPressTimerId = null;
        clearTimeout(mouseLongPressTimerId); mouseLongPressTimerId = null;
        clearTimeout(doubleTapFlagTimer); doubleTapFlagTimer = null;
        clearTimeout(doubleTapChordTimer); doubleTapChordTimer = null;
    }

    function flagIncorrectlyPlaced(){
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                 const cell = grid[y]?.[x];
                 if (cell?.isFlagged && !cell.isMine) {
                    if(cell.element){
                        cell.element.classList.remove('flagged');
                        cell.element.classList.add('incorrect-flag');
                        cell.element.textContent = 'X';
                    }
                 }
            }
        }
    }

    function startTimer() {
        if (!gameStarted && timerStartTime === null) {
            gameStarted = true;
            timerStartTime = performance.now();
            time = 0.000;
            updateTimerDisplay();
            clearInterval(timerDisplayInterval);
            timerDisplayInterval = setInterval(() => {
                if (!gameOver && timerStartTime !== null) {
                    const now = performance.now();
                    time = (now - timerStartTime) / 1000;
                    updateTimerDisplay();
                } else {
                    clearInterval(timerDisplayInterval);
                    timerDisplayInterval = null;
                }
            }, timerUpdateDelay);
        }
    }

    function stopTimer() {
        clearInterval(timerDisplayInterval);
        timerDisplayInterval = null;
        if (gameStarted && timerStartTime !== null) {
            const endTime = performance.now();
            time = (endTime - timerStartTime) / 1000;
            timerStartTime = null;
        }
        timerStartTime = null;
        updateTimerDisplay();
    }

   function addLongPressListener(element, callback) {
       let elementTouchTimerId = null; longPressFlaggedThisTouch = false;
       let startX, startY;
       const handleTouchStart = (e) => {
           if (e.touches.length === 1 && elementTouchTimerId === null) {
               longPressFlaggedThisTouch = false;
               ignoreNextClick = false;
               startX = e.touches[0].clientX; startY = e.touches[0].clientY;
               elementTouchTimerId = setTimeout(() => {
                   longPressFlaggedThisTouch = true;
                   callback(e);
                   ignoreNextClick = true;
                   elementTouchTimerId = null;
                   e.preventDefault();
                   const tc = e.target.closest('.cell'); if (tc) tc.classList.remove('pressed');
               }, longPressDelay);
                const tc = e.target.closest('.cell');
                if (tc && !tc.classList.contains('revealed') && !tc.classList.contains('flagged')) {
                    tc.classList.add('pressed');
                }
           }
       };
       const handleTouchEnd = (e) => {
            const tc = e.target.closest('.cell'); if (tc) tc.classList.remove('pressed');
           if (elementTouchTimerId !== null) {
               clearTimeout(elementTouchTimerId);
               elementTouchTimerId = null;
           }
           if (longPressFlaggedThisTouch) {
               longPressFlaggedThisTouch = false;
               e.preventDefault();
           }
       };
       const handleTouchMove = (e) => {
           if (elementTouchTimerId !== null) {
                 const currentX = e.touches[0].clientX; const currentY = e.touches[0].clientY;
                 const deltaX = Math.abs(currentX - startX); const deltaY = Math.abs(currentY - startY);
                 if (deltaX > 10 || deltaY > 10) {
                     clearTimeout(elementTouchTimerId);
                     elementTouchTimerId = null;
                     longPressFlaggedThisTouch = false;
                     ignoreNextClick = false;
                     const tc = e.target.closest('.cell'); if (tc) tc.classList.remove('pressed');
                 }
           }
       };
        element.addEventListener('touchstart', handleTouchStart, { passive: false });
        element.addEventListener('touchend', handleTouchEnd, { passive: false });
        element.addEventListener('touchmove', handleTouchMove, { passive: false });
       element._touchStartHandlerLP = handleTouchStart;
       element._touchEndHandlerLP = handleTouchEnd;
       element._touchMoveHandlerLP = handleTouchMove;
   }

   function removeLongPressListener(element) {
        if (element._touchStartHandlerLP) {
            element.removeEventListener('touchstart', element._touchStartHandlerLP, { passive: false });
            delete element._touchStartHandlerLP;
        }
        if (element._touchEndHandlerLP) {
            element.removeEventListener('touchend', element._touchEndHandlerLP, { passive: false });
            delete element._touchEndHandlerLP;
        }
        if (element._touchMoveHandlerLP) {
            element.removeEventListener('touchmove', element._touchMoveHandlerLP, { passive: false });
            delete element._touchMoveHandlerLP;
        }
    }

    // --- Settings / UI ---

    function handleDifficultyChange() {
        const selectedDifficulty = difficultySelector.value;
        setDifficulty(selectedDifficulty);
    }

    function toggleSettings() {
        const isOpen = settingsPanel.classList.contains('open');
        if (isOpen) {
            settingsPanel.classList.remove('open');
            overlay.style.display = 'none';
             if (noGuessMode && firstClick && generationAttempts > 0) {
                 attemptsSpan.textContent = `(${generationAttempts} attempts)`;
             } else if (!firstClick && noGuessMode) {
                 attemptsSpan.textContent = `(${generationAttempts} attempts)`;
             }
             else {
                attemptsSpan.textContent = '';
             }
        } else {
            longPressDelayValueSpan.textContent = longPressDelay;
            longPressDelayInput.value = longPressDelay;
            widthInput.value = width;
            heightInput.value = height;
            minesInput.value = numMines;
            playerNameInput.value = playerName;
            lightModeCheckbox.checked = document.body.classList.contains('light-mode');
            noGuessCheckbox.checked = noGuessMode;
            flagMethodSelect.value = flagMethod;
            chordMethodSelect.value = chordMethod;
             if (currentDifficulty === 'custom') {
                customSettingsDiv.classList.add('active');
                updateCustomMinesMax(); // Ensure max is correct when opening
             } else {
                customSettingsDiv.classList.remove('active');
             }
            attemptsSpan.textContent = '';
            settingsPanel.classList.add('open');
            overlay.style.display = 'block';
        }
    }

    function closePanels() {
        if (settingsPanel.classList.contains('open')) {
            toggleSettings();
        }
    }

    function updateTimerDisplay(){
        if (timerDisplay) {
            timerDisplay.textContent = time.toFixed(3);
        }
    }
    function updateMinesLeftDisplay(){ if (minesLeftDisplay) minesLeftDisplay.textContent = minesLeft < 0 ? 0 : minesLeft; }

    function setDifficulty(difficulty) {
      const needsRestart = currentDifficulty !== difficulty || difficulty === 'custom';
      currentDifficulty = difficulty;
      difficultySelector.value = currentDifficulty;

      attemptsSpan.textContent = '';

      if (difficulty === 'custom') {
          customSettingsDiv.classList.add('active');
          if (!customSettingsDiv.classList.contains('active-before-change')) {
               widthInput.value = width;
               heightInput.value = height;
               minesInput.value = numMines;
          }
          updateCustomMinesMax(); // Ensure max is correct
          customSettingsDiv.classList.add('active-before-change');
          // For custom, restart only happens via "Apply & Close" if values change
          // Or if switching *from* custom to standard.
          // If just selecting "Custom" in dropdown, don't restart yet.
          if (currentDifficulty === difficulty && !needsRestart) return; // Avoid restart if just re-selecting custom
      } else {
           customSettingsDiv.classList.remove('active');
           customSettingsDiv.classList.remove('active-before-change');
           switch (difficulty) {
               case 'beginner': width = 9; height = 9; numMines = 10; break;
               case 'intermediate': width = 16; height = 16; numMines = 40; break;
               case 'expert': width = 30; height = 16; numMines = 99; break;
           }
            widthInput.value = width;
            heightInput.value = height;
            minesInput.value = numMines;
            updateCustomMinesMax(); // Update max for safety, though not visible for standard

            localStorage.setItem('width', width); // Save standard difficulty dimensions
            localStorage.setItem('height', height);
            localStorage.setItem('numMines', numMines);
      }
        localStorage.setItem('currentDifficulty', currentDifficulty);
        minesLeft = numMines;

        if (needsRestart) { // This will be true if difficulty changed (e.g. beginner -> expert)
            restartGame();
        }
    }

    // --- Auto-Save Setup ---
    function setupAutoSaveListeners() {
        playerNameInput.addEventListener('change', () => {
            const oldPlayerName = playerName;
            playerName = playerNameInput.value.trim() || "Player";
            playerNameInput.value = playerName;
            if (oldPlayerName !== playerName) {
                localStorage.setItem('playerName', playerName);
                console.log("Auto-saved: Player Name to", playerName);
            }
        });

        lightModeCheckbox.addEventListener('change', () => {
            const isLightMode = lightModeCheckbox.checked;
            const bodyHasLightMode = document.body.classList.contains('light-mode');
            if (bodyHasLightMode !== isLightMode) {
                if (isLightMode) {
                    document.body.classList.add('light-mode');
                    if (logoElement) logoElement.src = "/LightModeLogo.svg";
                } else {
                    document.body.classList.remove('light-mode');
                    if (logoElement) logoElement.src = "/DarkModeLogo.svg";
                }
                localStorage.setItem('darkMode', isLightMode ? 'enabled' : 'disabled');
                console.log("Auto-applied & saved: Light Mode to", isLightMode);
            }
        });

        flagMethodSelect.addEventListener('change', () => {
            const newFlagMethod = flagMethodSelect.value;
            if (flagMethod !== newFlagMethod) {
                flagMethod = newFlagMethod;
                updateAllFlagMethodListeners();
                localStorage.setItem('flagMethod', flagMethod);
                console.log("Auto-applied & saved: Flag Method to", flagMethod);
            }
        });

        longPressDelayInput.addEventListener('input', (event) => {
            longPressDelayValueSpan.textContent = event.target.value;
            // Save on 'change' to reduce localStorage writes
        });
        longPressDelayInput.addEventListener('change', (event) => {
            const newLongPressDelay = parseInt(event.target.value);
            if (longPressDelay !== newLongPressDelay) {
                longPressDelay = newLongPressDelay;
                localStorage.setItem('longPressDelay', longPressDelay);
                console.log("Auto-saved: Long Press Delay to", longPressDelay);
            }
        });

        chordMethodSelect.addEventListener('change', () => {
            const newChordMethod = chordMethodSelect.value;
            if (chordMethod !== newChordMethod) {
                chordMethod = newChordMethod;
                localStorage.setItem('chordMethod', chordMethod);
                console.log("Auto-saved: Chord Method to", chordMethod);
            }
        });

        // Listeners for custom W/H to update max mines dynamically
        widthInput.addEventListener('input', updateCustomMinesMax);
        heightInput.addEventListener('input', updateCustomMinesMax);
    }

    function updateCustomMinesMax() {
        // This function is relevant only when custom settings are active and visible
        // It doesn't save anything, just updates the UI for mines input.
        if (customSettingsDiv.classList.contains('active')) {
            const w = parseInt(widthInput.value) || 0;
            const h = parseInt(heightInput.value) || 0;
            const maxMinesVal = (w * h) - 9;
            minesInput.max = maxMinesVal > 0 ? maxMinesVal : 1;
             // Optional: If current mines value exceeds new max, adjust it.
            // if (parseInt(minesInput.value) > minesInput.max) {
            //     minesInput.value = minesInput.max;
            // }
        }
    }


   function applySettings() {
        let gameNeedsRestart = false;

        // --- Read all values from panel inputs ---
        const panelPlayerName = playerNameInput.value.trim() || "Player";
        const panelIsLightMode = lightModeCheckbox.checked;
        const panelFlagMethod = flagMethodSelect.value;
        const panelLongPressDelay = parseInt(longPressDelayInput.value);
        const panelChordMethod = chordMethodSelect.value;
        const panelNoGuessMode = noGuessCheckbox.checked;

        // --- Update JS variables and check for changes that need restart ---

        // Player Name (JS var updated by auto-save, this is a final sync from panel)
        playerName = panelPlayerName;


        // Light Mode (Theme applied by auto-save, this ensures consistency if event missed)
        const bodyHasLightMode = document.body.classList.contains('light-mode');
        if (bodyHasLightMode !== panelIsLightMode) {
            if (panelIsLightMode) {
                document.body.classList.add('light-mode');
                if (logoElement) logoElement.src = "/LightModeLogo.svg";
            } else {
                document.body.classList.remove('light-mode');
                if (logoElement) logoElement.src = "/DarkModeLogo.svg";
            }
        }

        // Flag Method (Listeners updated by auto-save, this ensures consistency)
        if (flagMethod !== panelFlagMethod) {
            flagMethod = panelFlagMethod;
            updateAllFlagMethodListeners();
        }

        // Long Press Delay (JS var updated by auto-save)
        longPressDelay = panelLongPressDelay;


        // Chord Method (JS var updated by auto-save)
        chordMethod = panelChordMethod;


        // No Guess Mode (Requires Restart)
        if (noGuessMode !== panelNoGuessMode) {
            noGuessMode = panelNoGuessMode;
            gameNeedsRestart = true;
        }

        // Custom Difficulty (Requires Restart if changed)
        if (currentDifficulty === 'custom') {
            const panelWidth = parseInt(widthInput.value);
            const panelHeight = parseInt(heightInput.value);
            const panelNumMines = parseInt(minesInput.value);

            // Validation before updating game vars
            if (isNaN(panelWidth) || panelWidth < 5 || panelWidth > 50) { alert('Width must be between 5 and 50.'); return; }
            if (isNaN(panelHeight) || panelHeight < 5 || panelHeight > 50) { alert('Height must be between 5 and 50.'); return; }
            const maxMinesVal = (panelWidth * panelHeight) - 9;
            // Ensure minesInput.max is up-to-date for validation, though updateCustomMinesMax should handle it
            minesInput.max = maxMinesVal > 0 ? maxMinesVal : 1;
            if (isNaN(panelNumMines) || panelNumMines < 1 || panelNumMines > (maxMinesVal > 0 ? maxMinesVal : 1)) {
                alert(`Mines must be between 1 and ${maxMinesVal > 0 ? maxMinesVal : 1}.`); return;
            }

            if (width !== panelWidth || height !== panelHeight || numMines !== panelNumMines) {
                width = panelWidth;
                height = panelHeight;
                numMines = panelNumMines;
                gameNeedsRestart = true;
            }
        }

        // --- Save ALL current settings (now synced with panel) to localStorage ---
        localStorage.setItem('playerName', playerName);
        localStorage.setItem('darkMode', panelIsLightMode ? 'enabled' : 'disabled');
        localStorage.setItem('flagMethod', flagMethod);
        localStorage.setItem('longPressDelay', longPressDelay);
        localStorage.setItem('chordMethod', chordMethod);
        localStorage.setItem('noGuessMode', noGuessMode);

        localStorage.setItem('currentDifficulty', currentDifficulty);
        // These dimensions are saved regardless of whether it's custom or standard.
        // For standard, they're set by setDifficulty. For custom, by the logic above.
        localStorage.setItem('width', width);
        localStorage.setItem('height', height);
        localStorage.setItem('numMines', numMines);

        // --- Restart game if needed ---
        if (gameNeedsRestart) {
            minesLeft = numMines; // Ensure minesLeft is correct for the new settings
            restartGame();
        }

        toggleSettings(); // Close the settings panel
    }

    function showMessage(message) {
         messageText.textContent = message;
         messageBox.style.display = 'block';
         overlay.style.display = 'block';
         if (settingsPanel.classList.contains('open')) {
            settingsPanel.classList.remove('open');
         }
    }

    function restartGame() {
        stopTimer();
        time = 0.000;
        updateTimerDisplay();
        gameStarted = false;
        firstClick = true;
        gameOver = false;
        minesLeft = numMines;
        updateMinesLeftDisplay();
        generationAttempts = 0;
        if(attemptsSpan) attemptsSpan.textContent = '';

        ignoreNextClick = false;
        longPressFlaggedThisTouch = false;
        longPressJustFinishedMouse = false;
        isLeftMouseDown = false;
        if (pressedCellElement) {
            pressedCellElement.classList.remove('pressed');
            pressedCellElement = null;
        }
        initialMouseDownCell = null;
        clearTimeout(touchLongPressTimerId); touchLongPressTimerId = null;
        clearTimeout(mouseLongPressTimerId); mouseLongPressTimerId = null;
        clearTimeout(doubleTapFlagTimer); doubleTapFlagTimer = null;
        clearTimeout(doubleTapChordTimer); doubleTapChordTimer = null;
        document.removeEventListener('mouseup', handleDocumentMouseUp);

        if (headerArea && controlsDiv) {
            headerArea.classList.remove('header-gap-small', 'header-gap-medium', 'header-gap-large');
            controlsDiv.classList.remove('controls-gap-small', 'controls-gap-medium', 'controls-gap-large');
            if (width <= 12) {
                headerArea.classList.add('header-gap-small');
                controlsDiv.classList.add('controls-gap-small');
            } else if (width <= 22) {
                headerArea.classList.add('header-gap-medium');
                controlsDiv.classList.add('controls-gap-medium');
            } else {
                headerArea.classList.add('header-gap-large');
                controlsDiv.classList.add('controls-gap-large');
            }
        }
        createGrid();
        messageBox.style.display = 'none';
        if (!settingsPanel.classList.contains('open')) {
            overlay.style.display = 'none';
        }
        updateAllFlagMethodListeners();
    }

    // Listener for long press delay slider (moved to setupAutoSaveListeners)

    function getLeaderboardDifficultyString() {
        if (currentDifficulty === 'custom') return null;
        let ds = currentDifficulty;
        if (noGuessMode) ds += "_noguess";
        return ds;
    }

    function updateLeaderboard() {
        const difficultyString = getLeaderboardDifficultyString();
         if (!difficultyString) {
             console.log("Score not submitted for custom difficulty.");
             return;
         }
         const finalTime = time;
         const currentName = playerNameInput.value.trim() || "Player";
          if (!currentName || currentName.toLowerCase() === "player") {
              console.log(`Score not submitted for ${difficultyString}: Enter a unique name.`);
              let bestTimeLocalStr = localStorage.getItem(`leaderboard-${difficultyString}`);
              let bestTimeLocal = parseFloat(bestTimeLocalStr);
              if (bestTimeLocalStr === null || isNaN(bestTimeLocal) || finalTime < bestTimeLocal) {
                   localStorage.setItem(`leaderboard-${difficultyString}`, finalTime.toString());
                   bestTimeLocal = finalTime;
              }
              const localTimeCell = document.getElementById(`leaderboard-${difficultyString}-local`);
              if (localTimeCell) localTimeCell.textContent = bestTimeLocalStr === null || isNaN(bestTimeLocal) ? '-' : bestTimeLocal.toFixed(3);
              return;
          }
          db.collection('leaderboard').add({
              playerName: currentName,
              difficulty: difficultyString,
              score: finalTime,
              timestamp: firebase.firestore.FieldValue.serverTimestamp()
          })
             .then(() => {
                 console.log(`Score submitted for ${difficultyString}!`);
                 loadOnlineLeaderboard();
             })
             .catch((error) => {
                 console.error(`Error submitting score for ${difficultyString}: `, error);
                 leaderboardErrorDiv.textContent='Error submitting score.';
                 leaderboardErrorDiv.style.display='block';
                 leaderboardLoadingDiv.style.display = 'none';
             });
         let bestTimeLocalStr = localStorage.getItem(`leaderboard-${difficultyString}`);
         let bestTimeLocal = parseFloat(bestTimeLocalStr);
         if (bestTimeLocalStr === null || isNaN(bestTimeLocal) || finalTime < bestTimeLocal) {
              localStorage.setItem(`leaderboard-${difficultyString}`, finalTime.toString());
              bestTimeLocal = finalTime;
         }
         const localTimeCell = document.getElementById(`leaderboard-${difficultyString}-local`);
         if (localTimeCell) localTimeCell.textContent = bestTimeLocalStr === null || isNaN(bestTimeLocal) ? '-' : bestTimeLocal.toFixed(3);
    }

    async function fetchScoresRecursive(difficulty, targetCount, collectedScores = [], lastVisible = null) {
        let q = db.collection('leaderboard')
                  .where('difficulty', '==', difficulty)
                  .where('score', '>', 0)
                  .orderBy('score', 'asc');
        if (lastVisible) {
            q = q.startAfter(lastVisible);
        }
        q = q.limit(targetCount * 2);
        try {
            const querySnapshot = await q.get();
            const nextLastVisible = querySnapshot.docs[querySnapshot.docs.length - 1];
            let addedCount = 0;
            querySnapshot.forEach((doc) => {
                if (collectedScores.length >= targetCount) return;
                const data = doc.data();
                if (typeof data.score === 'number' && data.score >= 0 &&
                    typeof data.playerName === 'string' && data.playerName.trim() !== '')
                {
                    collectedScores.push(data);
                    addedCount++;
                } else {
                    console.warn("Skipping invalid score data:", data);
                }
            });
            if (collectedScores.length < targetCount && addedCount > 0 && nextLastVisible && querySnapshot.docs.length === (targetCount * 2)) {
                 console.log(`Fetching more for ${difficulty}, currently have ${collectedScores.length}/${targetCount}`);
                return fetchScoresRecursive(difficulty, targetCount, collectedScores, nextLastVisible);
            } else {
                return collectedScores;
            }
        } catch (error) {
            console.error(`Error fetching scores for ${difficulty}:`, error);
            const errorDisplay = document.getElementById('leaderboard-error');
            if(errorDisplay) {
                 errorDisplay.textContent=`Error loading ${difficulty} leaderboard.`;
                 errorDisplay.style.display='block';
            }
            return collectedScores;
        }
    }

    async function loadOnlineLeaderboard() {
      leaderboardLoadingDiv.style.display = 'block';
      leaderboardErrorDiv.style.display = 'none';
      const difficulties = [
        'beginner','intermediate','expert',
        'beginner_noguess','intermediate_noguess','expert_noguess'
      ];
      const targetCount = 10;
      difficulties.forEach(d => {
        const tbody = document.getElementById(`leaderboard-${d}`);
        if (tbody) tbody.innerHTML = '';
      });
      try {
        const promises = difficulties.map(async diff => {
          const tbody = document.getElementById(`leaderboard-${diff}`);
          if (!tbody) return;
          tbody.innerHTML = '<tr><td colspan="3">Loading...</td></tr>';
          const rawScores = await fetchScoresRecursive(diff, targetCount * 2, []);
          tbody.innerHTML = '';
          const adjusted = rawScores.map(s => {
            const legacy = Number.isInteger(s.score);
            const adjustedScore = legacy ? s.score + 0.999 : s.score;
            return { ...s, adjustedScore, legacy };
          }).sort((a,b) => a.adjustedScore - b.adjustedScore)
            .slice(0, targetCount);
          if(adjusted.length === 0){
            tbody.innerHTML = '<tr><td colspan="3">No scores yet.</td></tr>';
            return;
          }
          let rank = 1;
          adjusted.forEach(data => {
            const row = tbody.insertRow();
            row.insertCell().textContent = rank++;
            const nameCell = row.insertCell();
            nameCell.textContent = sanitize(String(data.playerName || 'Anonymous').slice(0, 20));
            const scoreCell = row.insertCell();
            const scoreString = data.adjustedScore.toFixed(3);
            const legacyIconHtml = data.legacy
                ? ` <span class="legacy-icon" title="Legacy score recorded under the old integer timing system – displayed as the slowest possible time for that second.">🕰️</span>`
                : '';
            scoreCell.innerHTML = `${scoreString}${legacyIconHtml}`;
          });
        });
        await Promise.all(promises);
        leaderboardLoadingDiv.style.display = 'none';
      } catch (err) {
        console.error("Overall leaderboard loading/rendering error:", err);
        leaderboardLoadingDiv.style.display = 'none';
        if (leaderboardErrorDiv.style.display === 'none') {
             leaderboardErrorDiv.textContent = 'Error loading one or more leaderboards.';
             leaderboardErrorDiv.style.display = 'block';
        }
      }
    }


    function loadLeaderboard() {
        const difficulties = ['beginner','intermediate','expert','beginner_noguess','intermediate_noguess','expert_noguess'];
        difficulties.forEach(d => {
            const bestTimeStr = localStorage.getItem(`leaderboard-${d}`);
            const bestTime = parseFloat(bestTimeStr);
            const timeCell = document.getElementById(`leaderboard-${d}-local`);
            if (timeCell) {
                 timeCell.textContent = bestTimeStr === null || isNaN(bestTime) ? '-' : bestTime.toFixed(3);
            }
        });
    }

    function loadSettings() {
      playerName = localStorage.getItem('playerName') || 'Player';
      playerNameInput.value = playerName;

      const savedDarkMode = localStorage.getItem('darkMode');
      const isLightMode = savedDarkMode === 'enabled';
      lightModeCheckbox.checked = isLightMode;
      if (isLightMode) {
          document.body.classList.add('light-mode');
          if (logoElement) logoElement.src = "/LightModeLogo.svg";
      } else {
          document.body.classList.remove('light-mode');
          if (logoElement) logoElement.src = "/DarkModeLogo.svg";
      }

      flagMethod = localStorage.getItem('flagMethod') || 'longPress';
      flagMethodSelect.value = flagMethod;

      longPressDelay = parseInt(localStorage.getItem('longPressDelay')) || 500;
      longPressDelayInput.value = longPressDelay;
      longPressDelayValueSpan.textContent = longPressDelay;

      chordMethod = localStorage.getItem('chordMethod') || 'singleTap';
      chordMethodSelect.value = chordMethod;

      noGuessMode = localStorage.getItem('noGuessMode') === 'true';
      noGuessCheckbox.checked = noGuessMode;
      attemptsSpan.textContent = '';

      currentDifficulty = localStorage.getItem('currentDifficulty') || 'beginner';
      width = parseInt(localStorage.getItem('width')) || 9; // Default for beginner
      height = parseInt(localStorage.getItem('height')) || 9; // Default for beginner
      numMines = parseInt(localStorage.getItem('numMines')) || 10; // Default for beginner

      // If loaded difficulty is standard, override W/H/M with standard values
      // This ensures consistency if localStorage had custom values but difficulty was standard.
      if (currentDifficulty === 'beginner') { width = 9; height = 9; numMines = 10; }
      else if (currentDifficulty === 'intermediate') { width = 16; height = 16; numMines = 40; }
      else if (currentDifficulty === 'expert') { width = 30; height = 16; numMines = 99; }
      // If 'custom', the loaded W/H/M from localStorage are used.

      setDifficulty(currentDifficulty); // Syncs dropdown, updates inputs for custom, possibly restarts

       if (currentDifficulty === 'custom') {
           widthInput.value = width; // Ensure custom inputs reflect loaded custom values
           heightInput.value = height;
           minesInput.value = numMines;
           updateCustomMinesMax();
           customSettingsDiv.classList.add('active');
       } else {
           customSettingsDiv.classList.remove('active');
       }

      minesLeft = numMines; // This is set again in setDifficulty, but good to have here
      // restartGame() is called by setDifficulty if needed, or if not, it will be implicitly called by
      // the end of loadSettings if a restart is always desired on page load.
      // Let's ensure restartGame() IS called to build the initial grid with loaded settings.
      // Note: setDifficulty might already call restartGame. If so, this could be redundant.
      // For safety and to ensure the grid always reflects the fully loaded state:
      if (! (currentDifficulty !== (localStorage.getItem('currentDifficulty') || 'beginner')) ) {
           // if setDifficulty didn't already trigger a restart (e.g. loaded difficulty was already set)
           // then call restartGame here.
           // However, a simpler approach is that loadSettings always culminates in a restart.
      }
      // The existing structure where setDifficulty calls restart if needed,
      // and is called by loadSettings, should be sufficient.
      // The last call in loadSettings should be restartGame AFTER all vars are set.
      // Let's simplify: loadSettings prepares all variables, then calls restartGame once.
      // setDifficulty will be called to set up UI elements like custom inputs, but not necessarily to restart.

      // Modified flow for loadSettings:
      // 1. Load all basic settings (playerName, theme, methods, noGuess, custom W/H/M, currentDifficulty type)
      // 2. Based on currentDifficulty type, determine the definitive W/H/M for the game.
      // 3. Update UI input elements in settings panel to reflect these definitive values.
      // 4. Call restartGame() once to build the grid.

      // Re-evaluating loadSettings logic slightly:
      // `setDifficulty` is good because it centralizes the logic for setting W/H/M based on difficulty type
      // and for updating UI elements. It also calls `restartGame` if the difficulty *type* changes.
      // If `currentDifficulty` loaded from localStorage is, say, 'beginner', `setDifficulty('beginner')`
      // will set standard W/H/M and restart. This is fine.
      // If 'custom', it sets custom inputs and doesn't restart from `setDifficulty` itself.
      // So, a final `restartGame()` after `loadSettings` logic is still a good idea if `setDifficulty`
      // for 'custom' doesn't trigger it.
      // The current `setDifficulty` already calls `restartGame` if `needsRestart` is true.
      // And `needsRestart` is true if `currentDifficulty !== difficulty` (initial call with loaded value)
      // OR if `difficulty === 'custom'`.
      // This means `setDifficulty` when called from `loadSettings` with 'custom' will trigger a restart.

      // It seems `loadSettings()` should be fine as it is structured, as `setDifficulty` will handle the restart.
    }


    function getNeighbors(x, y, W, H) { const n = []; for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) { if (dx === 0 && dy === 0) continue; const nx = x + dx, ny = y + dy; if (nx >= 0 && nx < W && ny >= 0 && ny < H) n.push({ x: nx, y: ny }); } return n; }
     function isSolvableWithoutGuessing(startX, startY) {
         const solverGrid = Array(height).fill(null).map(() => Array(width).fill(null).map(() => ({ state: -2 })));
         let revealedCount = 0; let minesFound = 0; const totalNonMines = (width * height) - numMines;
         const processQueue = []; const W = width; const H = height;
         const solverReveal = (x, y) => {
             if (x < 0 || x >= W || y < 0 || y >= H || solverGrid[y]?.[x]?.state !== -2) return false;
             const actualCellData = grid[y]?.[x];
             if (!actualCellData || actualCellData.isMine) return false;
             const adjacentMines = actualCellData.adjacentMines;
             solverGrid[y][x].state = adjacentMines;
             revealedCount++;
             if (adjacentMines === 0) {
                 getNeighbors(x, y, W, H).forEach(n => {
                     if (solverGrid[n.y]?.[n.x]?.state === -2) {
                         processQueue.push(n);
                     }
                 });
             }
             return true;
         };
         const solverFlag = (x, y) => {
             if (x < 0 || x >= W || y < 0 || y >= H || solverGrid[y]?.[x]?.state !== -2) return false;
             const actualCellData = grid[y]?.[x];
             if (!actualCellData || !actualCellData.isMine) return false;
             solverGrid[y][x].state = -1;
             minesFound++;
             return true;
         };
         if(startX >= 0 && startX < W && startY >= 0 && startY < H){
             for (let dy = -1; dy <= 1; dy++) {
                 for (let dx = -1; dx <= 1; dx++) {
                     const cx = startX + dx, cy = startY + dy;
                     if (cx >= 0 && cx < W && cy >= 0 && cy < H) {
                         if(!grid[cy]?.[cx]?.isMine){
                              solverReveal(cx, cy);
                         }
                     }
                 }
             }
         } else {
              console.error("Invalid start coordinates for solver:", startX, startY);
              return false;
         }
         let madeProgress = true;
         while (madeProgress) {
             madeProgress = false;
             while (processQueue.length > 0) {
                 const { x, y } = processQueue.shift();
                 if (solverGrid[y]?.[x]?.state === -2 && solverReveal(x, y)) {
                     madeProgress = true;
                 }
             }
             let innerProgress = true;
             while(innerProgress){
                 innerProgress = false;
                 for (let y = 0; y < H; y++) {
                     for (let x = 0; x < W; x++) {
                         if (!solverGrid[y]?.[x]) continue;
                         const cellState = solverGrid[y][x].state;
                         if (cellState >= 1 && cellState <= 8) {
                             const neighbors = getNeighbors(x, y, W, H);
                             let unknownNeighbors = [];
                             let flaggedNeighborCount = 0;
                             neighbors.forEach(n => {
                                 const neighborState = solverGrid[n.y]?.[n.x]?.state;
                                 if (neighborState === -2) { unknownNeighbors.push(n); }
                                 else if (neighborState === -1) { flaggedNeighborCount++; }
                             });
                             if (flaggedNeighborCount === cellState && unknownNeighbors.length > 0) {
                                 unknownNeighbors.forEach(n => {
                                     if (solverReveal(n.x, n.y)) {
                                         innerProgress = true; madeProgress = true;
                                     }
                                 });
                                 if(innerProgress) continue;
                             }
                             if (unknownNeighbors.length > 0 && (flaggedNeighborCount + unknownNeighbors.length === cellState)) {
                                 let failedFlag = false;
                                 unknownNeighbors.forEach(n => {
                                     if (!solverFlag(n.x, n.y)) {
                                         if(solverGrid[n.y]?.[n.x]?.state !== -1) {
                                             failedFlag = true;
                                         }
                                     } else {
                                         innerProgress = true; madeProgress = true;
                                     }
                                 });
                                 if(failedFlag) { console.error("Solver inconsistency: Tried to flag a cell that couldn't be flagged as a mine."); return false; }
                                 if(innerProgress) continue;
                             }
                         }
                     }
                 }
                 while (processQueue.length > 0) {
                    const { x, y } = processQueue.shift();
                    if (solverGrid[y]?.[x]?.state === -2 && solverReveal(x, y)) {
                        innerProgress = true; madeProgress = true;
                    }
                 }
             }
             if (!madeProgress) break;
         }
         return revealedCount === totalNonMines && revealedCount > 0;
     }

    document.addEventListener('click', e => {
      const legacyIconElement = e.target.closest('.legacy-icon');
      if (legacyIconElement) {
        const message = legacyIconElement.getAttribute('title') || 'Legacy score: recorded before decimal‑precision timing. Value shown is slowest possible within that second.';
        alert(message);
      }
    });

    document.addEventListener('DOMContentLoaded', () => {
        loadSettings();         // Load saved settings first
        setupAutoSaveListeners(); // Setup auto-save listeners for settings panel
        loadLeaderboard();      // Load local scores
        loadOnlineLeaderboard(); // Load online scores
        // restartGame() is effectively called within loadSettings via setDifficulty
    });

    </script>
</body>
</html>
